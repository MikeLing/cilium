# SOME DESCRIPTIVE TITLE.
# Copyright (C) Cilium Authors
# This file is distributed under the same license as the Cilium package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Cilium \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-05-25 00:09+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../policy/index.rst:3 ../../policy/intro.rst:3
#: ../../policy/kubernetes.rst:3 ../../policy/language.rst:3
#: ../../policy/lifecycle.rst:3 ../../policy/troubleshooting.rst:3
#: ../../policy/visibility.rst:3
msgid ""
"WARNING: You are looking at unreleased Cilium documentation. Please use "
"the official rendered version released here: https://docs.cilium.io"
msgstr ""

#: ../../policy/index.rst:12
msgid "Network Policy"
msgstr ""

#: ../../policy/index.rst:14
msgid ""
"This chapter documents the policy language used to configure network "
"policies in Cilium. Security policies can be specified and imported via "
"the following mechanisms:"
msgstr ""

#: ../../policy/index.rst:18
msgid ""
"Using Kubernetes `NetworkPolicy`, `CiliumNetworkPolicy` and "
"`CiliumClusterwideNetworkPolicy` resources. See the section "
":ref:`k8s_policy` for more details. In this mode, Kubernetes will "
"automatically distribute the policies to all agents."
msgstr ""

#: ../../policy/index.rst:22
msgid ""
"Directly imported into the agent via CLI or :ref:`api_ref` of the agent. "
"This method does not automatically distribute policies to all agents. It "
"is in the responsibility of the user to import the policy in all required"
" agents."
msgstr ""

#: ../../policy/intro.rst:12
msgid "Policy Enforcement Modes"
msgstr ""

#: ../../policy/intro.rst:14
msgid ""
"The configuration of the Cilium agent and the Cilium Network Policy "
"determines whether an endpoint accepts traffic from a source or not. The "
"agent can be put into the following three policy enforcement modes:"
msgstr ""

#: ../../policy/intro.rst:29
msgid "default"
msgstr ""

#: ../../policy/intro.rst:17
msgid ""
"This is the default behavior for policy enforcement when Cilium is "
"launched without any specified value for the policy enforcement "
"configuration. The following rules apply:"
msgstr ""

#: ../../policy/intro.rst:21
msgid ""
"If any rule selects an :ref:`endpoint` and the rule has an ingress "
"section, the endpoint goes into default deny at ingress."
msgstr ""

#: ../../policy/intro.rst:23
msgid ""
"If any rule selects an :ref:`endpoint` and the rule has an egress "
"section, the endpoint goes into default deny at egress."
msgstr ""

#: ../../policy/intro.rst:26
msgid ""
"This means that endpoints will start without any restrictions and as soon"
" as a rule restricts their ability to receive traffic on ingress or to "
"transmit traffic on egress, then the endpoint goes into whitelisting mode"
" and all traffic must be explicitly allowed."
msgstr ""

#: ../../policy/intro.rst:37
msgid "always"
msgstr ""

#: ../../policy/intro.rst:32
msgid ""
"With always mode, policy enforcement is enabled on all endpoints even if "
"no rules select specific endpoints."
msgstr ""

#: ../../policy/intro.rst:35
msgid ""
"If you want to configure health entity to check cluster-wide connectivity"
" when you start cilium-agent with ``enable-policy=always``, you will "
"likely want to enable communications to and from the health endpoint. See"
" :ref:`health_endpoint`."
msgstr ""

#: ../../policy/intro.rst:42
msgid "never"
msgstr ""

#: ../../policy/intro.rst:40
msgid ""
"With never mode, policy enforcement is disabled on all endpoints, even if"
" rules do select specific endpoints. In other words, all traffic is "
"allowed from any source (on ingress) or destination (on egress)."
msgstr ""

#: ../../policy/intro.rst:44
msgid ""
"To configure the policy enforcement mode at runtime for all endpoints "
"managed by a Cilium agent, use:"
msgstr ""

#: ../../policy/intro.rst:50
msgid ""
"If you want to configure the policy enforcement mode at start-time for a "
"particular agent, provide the following flag when launching the Cilium "
"daemon:"
msgstr ""

#: ../../policy/intro.rst:57
msgid ""
"Similarly, you can enable the policy enforcement mode across a Kubernetes"
" cluster by including the parameter above in the Cilium DaemonSet."
msgstr ""

#: ../../policy/intro.rst:68
msgid "Rule Basics"
msgstr ""

#: ../../policy/intro.rst:70
msgid ""
"All policy rules are based upon a whitelist model, that is, each rule in "
"the policy allows traffic that matches the rule. If two rules exist, and "
"one would match a broader set of traffic, then all traffic matching the "
"broader rule will be allowed. If there is an intersection between two or "
"more rules, then traffic matching the union of those rules will be "
"allowed. Finally, if traffic does not match any of the rules, it will be "
"dropped pursuant to the `policy_enforcement_modes`."
msgstr ""

#: ../../policy/intro.rst:78
msgid ""
"Policy rules share a common base type which specifies which endpoints the"
" rule applies to and common metadata to identify the rule. Each rule is "
"split into an ingress section and an egress section. The ingress section "
"contains the rules which must be applied to traffic entering the "
"endpoint, and the egress section contains rules applied to traffic coming"
" from the endpoint matching the endpoint selector. Either ingress, "
"egress, or both can be provided. If both ingress and egress are omitted, "
"the rule has no effect."
msgstr ""

#: ../../policy/intro.rst:137
msgid "endpointSelector / nodeSelector"
msgstr ""

#: ../../policy/intro.rst:134
msgid ""
"Selects the endpoints or nodes which the policy rules apply to. The "
"policy rules will be applied to all endpoints which match the labels "
"specified in the selector. See the `LabelSelector` and "
":ref:`NodeSelector` sections for additional details."
msgstr ""

#: ../../policy/intro.rst:141
msgid "ingress"
msgstr ""

#: ../../policy/intro.rst:140
msgid ""
"List of rules which must apply at ingress of the endpoint, i.e. to all "
"network packets which are entering the endpoint."
msgstr ""

#: ../../policy/intro.rst:145
msgid "egress"
msgstr ""

#: ../../policy/intro.rst:144
msgid ""
"List of rules which must apply at egress of the endpoint, i.e. to all "
"network packets which are leaving the endpoint."
msgstr ""

#: ../../policy/intro.rst:152
msgid "labels"
msgstr ""

#: ../../policy/intro.rst:148
msgid ""
"Labels are used to identify the rule. Rules can be listed and deleted by "
"labels. Policy rules which are imported via :ref:`kubernetes<k8s_policy>`"
" automatically get the label ``io.cilium.k8s.policy.name=NAME`` assigned "
"where ``NAME`` corresponds to the name specified in the `NetworkPolicy` "
"or `CiliumNetworkPolicy` resource."
msgstr ""

#: ../../policy/intro.rst:156
msgid "description"
msgstr ""

#: ../../policy/intro.rst:155
msgid ""
"Description is a string which is not interpreted by Cilium. It can be "
"used to describe the intent and scope of the rule in a human readable "
"form."
msgstr ""

#: ../../policy/intro.rst:163
msgid "Endpoint Selector"
msgstr ""

#: ../../policy/intro.rst:165
msgid ""
"The Endpoint Selector is based on the `Kubernetes LabelSelector "
"<https://kubernetes.io/docs/concepts/overview/working-with-objects/labels"
"/#label-selectors>`_. It is called Endpoint Selector because it only "
"applies to labels associated with an `endpoints`."
msgstr ""

#: ../../policy/intro.rst:173
msgid "Node Selector"
msgstr ""

#: ../../policy/intro.rst:175
msgid ""
"The Node Selector is also based on the `LabelSelector`, although rather "
"than matching on labels associated with an `endpoints`, it instead "
"applies to labels associated with a node in the cluster."
msgstr ""

#: ../../policy/intro.rst:179
msgid ""
"Node Selectors can only be used in `CiliumClusterwideNetworkPolicy`. See "
"`HostPolicies` for details on the scope of node-level policies."
msgstr ""

#: ../../policy/kubernetes.rst:8
msgid "Using Kubernetes constructs in policy"
msgstr ""

#: ../../policy/kubernetes.rst:10
msgid "This section covers Kubernetes specific network policy aspects."
msgstr ""

#: ../../policy/kubernetes.rst:15
msgid "Namespaces"
msgstr ""

#: ../../policy/kubernetes.rst:17
msgid ""
"`Namespaces <https://kubernetes.io/docs/concepts/overview/working-with-"
"objects/namespaces/>`_ are used to create virtual clusters within a "
"Kubernetes cluster. All Kubernetes objects including NetworkPolicy and "
"CiliumNetworkPolicy belong to a particular namespace. Depending on how a "
"policy is being defined and created, Kubernetes namespaces are "
"automatically being taken into account:"
msgstr ""

#: ../../policy/kubernetes.rst:23
msgid ""
"Network policies created and imported as `CiliumNetworkPolicy` CRD and "
"`NetworkPolicy` apply within the namespace, i.e. the policy only applies "
"to pods within that namespace. It is however possible to grant access to "
"and from pods in other namespaces as described below."
msgstr ""

#: ../../policy/kubernetes.rst:28
msgid ""
"Network policies imported directly via the :ref:`api_ref` apply to all "
"namespaces unless a namespace selector is specified as described below."
msgstr ""

#: ../../policy/kubernetes.rst:31
msgid ""
"While specification of the namespace via the label "
"``k8s:io.kubernetes.pod.namespace`` in the ``fromEndpoints`` and "
"``toEndpoints`` fields is deliberately supported. Specification of the "
"namespace in the ``endpointSelector`` is prohibited as it would violate "
"the namespace isolation principle of Kubernetes. The ``endpointSelector``"
" always applies to pods of the namespace which is associated with the "
"CiliumNetworkPolicy resource itself."
msgstr ""

#: ../../policy/kubernetes.rst:40
msgid "Example: Enforce namespace boundaries"
msgstr ""

#: ../../policy/kubernetes.rst:42
msgid ""
"This example demonstrates how to enforce Kubernetes namespace-based "
"boundaries for the namespaces ``ns1`` and ``ns2`` by enabling default-"
"deny on all pods of either namespace and then allowing communication from"
" all pods within the same namespace."
msgstr ""

#: ../../policy/kubernetes.rst:47
msgid ""
"The example locks down ingress of the pods in ``ns1`` and ``ns2``. This "
"means that the pods can still communicate egress to anywhere unless the "
"destination is in either ``ns1`` or ``ns2`` in which case both source and"
" destination have to be in the same namespace. In order to enforce "
"namespace boundaries at egress, the same example can be used by "
"specifying the rules at egress in addition to ingress."
msgstr ""

#: ../../policy/kubernetes.rst:57 ../../policy/kubernetes.rst:81
#: ../../policy/kubernetes.rst:102 ../../policy/kubernetes.rst:155
#: ../../policy/kubernetes.rst:176 ../../policy/kubernetes.rst:206
#: ../../policy/kubernetes.rst:223 ../../policy/kubernetes.rst:242
#: ../../policy/language.rst:76 ../../policy/language.rst:97
#: ../../policy/language.rst:131 ../../policy/language.rst:154
#: ../../policy/language.rst:184 ../../policy/language.rst:220
#: ../../policy/language.rst:240 ../../policy/language.rst:275
#: ../../policy/language.rst:293 ../../policy/language.rst:372
#: ../../policy/language.rst:394 ../../policy/language.rst:414
#: ../../policy/language.rst:493 ../../policy/language.rst:567
#: ../../policy/language.rst:674 ../../policy/language.rst:698
#: ../../policy/language.rst:723 ../../policy/language.rst:829
#: ../../policy/language.rst:852 ../../policy/language.rst:936
#: ../../policy/language.rst:953 ../../policy/language.rst:1016
#: ../../policy/language.rst:1072 ../../policy/language.rst:1165
#: ../../policy/language.rst:1244 ../../policy/lifecycle.rst:77
#: ../../policy/lifecycle.rst:94
msgid "k8s YAML"
msgstr ""

#: ../../policy/kubernetes.rst:60 ../../policy/kubernetes.rst:84
#: ../../policy/kubernetes.rst:105 ../../policy/kubernetes.rst:158
#: ../../policy/language.rst:79 ../../policy/language.rst:100
#: ../../policy/language.rst:134 ../../policy/language.rst:157
#: ../../policy/language.rst:187 ../../policy/language.rst:223
#: ../../policy/language.rst:243 ../../policy/language.rst:278
#: ../../policy/language.rst:296 ../../policy/language.rst:375
#: ../../policy/language.rst:397 ../../policy/language.rst:417
#: ../../policy/language.rst:496 ../../policy/language.rst:570
#: ../../policy/language.rst:677 ../../policy/language.rst:701
#: ../../policy/language.rst:726 ../../policy/language.rst:832
#: ../../policy/language.rst:855 ../../policy/language.rst:939
#: ../../policy/language.rst:956 ../../policy/language.rst:1019
#: ../../policy/language.rst:1075 ../../policy/lifecycle.rst:80
#: ../../policy/lifecycle.rst:97
msgid "JSON"
msgstr ""

#: ../../policy/kubernetes.rst:69
msgid "Example: Expose pods across namespaces"
msgstr ""

#: ../../policy/kubernetes.rst:71
msgid ""
"The following example exposes all pods with the label ``name=leia`` in "
"the namespace ``ns1`` to all pods with the label ``name=luke`` in the "
"namespace ``ns2``."
msgstr ""

#: ../../policy/kubernetes.rst:75
msgid ""
"Refer to the :git-tree:`example YAML files "
"<examples/policies/kubernetes/namespace/demo-pods.yaml>` for a fully "
"functional example including pods deployed to different namespaces."
msgstr ""

#: ../../policy/kubernetes.rst:93
msgid "Example: Allow egress to kube-dns in kube-system namespace"
msgstr ""

#: ../../policy/kubernetes.rst:95
msgid ""
"The following example allows all pods in the ``public`` namespace in "
"which the policy is created to communicate with kube-dns on port 53/UDP "
"in the ``kube-system`` namespace."
msgstr ""

#: ../../policy/kubernetes.rst:115
msgid "ServiceAccounts"
msgstr ""

#: ../../policy/kubernetes.rst:117
msgid ""
"Kubernetes `Service Accounts "
"<https://kubernetes.io/docs/concepts/configuration/assign-pod-node/>`_ "
"are used to associate an identity to a pod or process managed by "
"Kubernetes and grant identities access to Kubernetes resources and "
"secrets. Cilium supports the specification of network security policies "
"based on the service account identity of a pod."
msgstr ""

#: ../../policy/kubernetes.rst:124
msgid ""
"The service account of a pod is either defined via the `service account "
"admission controller <https://kubernetes.io/docs/reference/access-authn-"
"authz/admission-controllers/#serviceaccount>`_ or can be directly "
"specified in the Pod, Deployment, ReplicationController resource like "
"this:"
msgstr ""

#: ../../policy/kubernetes.rst:141 ../../policy/language.rst:562
msgid "Example"
msgstr ""

#: ../../policy/kubernetes.rst:143
msgid ""
"The following example grants any pod running under the service account of"
" \"luke\" to issue a ``HTTP GET /public`` request on TCP port 80 to all "
"pods running associated to the service account of \"leia\"."
msgstr ""

#: ../../policy/kubernetes.rst:147
msgid ""
"Refer to the :git-tree:`example YAML files "
"<examples/policies/kubernetes/serviceaccount/demo-pods.yaml>` for a fully"
" functional example including deployment and service account resources."
msgstr ""

#: ../../policy/kubernetes.rst:167
msgid "Multi-Cluster"
msgstr ""

#: ../../policy/kubernetes.rst:169
msgid ""
"When operating multiple cluster with cluster mesh, the cluster name is "
"exposed via the label ``io.cilium.k8s.policy.cluster`` and can be used to"
" restrict policies to a particular cluster."
msgstr ""

#: ../../policy/kubernetes.rst:184
msgid ""
"Note the ``io.kubernetes.pod.namespace: default`` in the policy rule. It "
"makes sure the policy applies to ``rebel-base`` in the ``default`` "
"namespace of ``cluster2`` regardless of the namespace in ``cluster1`` "
"where ``x-wing`` is deployed in. If the namespace label of policy rules "
"is omitted it defaults to the same namespace where the policy itself is "
"applied in, which may be not what is wanted when deploying cross-cluster "
"policies."
msgstr ""

#: ../../policy/kubernetes.rst:193
msgid "Clusterwide Policies"
msgstr ""

#: ../../policy/kubernetes.rst:195
msgid ""
"`CiliumNetworkPolicy` only allows to bind a policy restricted to a "
"particular namespace. There can be situations where one wants to have a "
"cluster-scoped effect of the policy, which can be done using Cilium's "
"`CiliumClusterwideNetworkPolicy` Kubernetes custom resource. The "
"specification of the policy is same as that of `CiliumNetworkPolicy` "
"except that it is not namespaced."
msgstr ""

#: ../../policy/kubernetes.rst:200
msgid ""
"In the cluster, this policy will allow ingress traffic from pods matching"
" the label ``name=luke`` from any namespace to pods matching the labels "
"``name=leia`` in any namespace."
msgstr ""

#: ../../policy/kubernetes.rst:215
msgid "Example: Allow all ingress to kube-dns"
msgstr ""

#: ../../policy/kubernetes.rst:217
msgid ""
"The following example allows all Cilium managed endpoints in the cluster "
"to communicate with kube-dns on port 53/UDP in the ``kube-system`` "
"namespace."
msgstr ""

#: ../../policy/kubernetes.rst:234
msgid "Example: Add health endpoint"
msgstr ""

#: ../../policy/kubernetes.rst:236
msgid ""
"The following example adds the health entity to all Cilium managed "
"endpoints in order to check cluster connectivity health."
msgstr ""

#: ../../policy/language.rst:10
msgid "Layer 3 Examples"
msgstr ""

#: ../../policy/language.rst:12
msgid ""
"The layer 3 policy establishes the base connectivity rules regarding "
"which endpoints can talk to each other. Layer 3 policies can be specified"
" using the following methods:"
msgstr ""

#: ../../policy/language.rst:15
msgid ""
"`Labels based`: This is used to describe the relationship if both "
"endpoints are managed by Cilium and are thus assigned labels. The big "
"advantage of this method is that IP addresses are not encoded into the "
"policies and the policy is completely decoupled from the addressing."
msgstr ""

#: ../../policy/language.rst:20
msgid ""
"`Services based`: This is an intermediate form between Labels and CIDR "
"and makes use of the services concept in the orchestration system. A good"
" example of this is the Kubernetes concept of Service endpoints which are"
" automatically maintained to contain all backend IP addresses of a "
"service. This allows to avoid hardcoding IP addresses into the policy "
"even if the destination endpoint is not controlled by Cilium."
msgstr ""

#: ../../policy/language.rst:27
msgid ""
"`Entities based`: Entities are used to describe remote peers which can be"
" categorized without knowing their IP addresses. This includes "
"connectivity to the local host serving the endpoints or all connectivity "
"to outside of the cluster."
msgstr ""

#: ../../policy/language.rst:32
msgid ""
"`CIDR based`: This is used to describe the relationship to or from "
"external services if the remote peer is not an endpoint. This requires to"
" hardcode either IP addresses or subnets into the policies. This "
"construct should be used as a last resort as it requires stable IP or "
"subnet assignments."
msgstr ""

#: ../../policy/language.rst:37
msgid ""
"`DNS based`: Selects remote, non-cluster, peers using DNS names converted"
" to IPs via DNS lookups. It shares all limitations of the `CIDR based` "
"rules above. DNS information is acquired by routing DNS traffic via a "
"proxy, or polling for listed DNS targets. DNS TTLs are respected."
msgstr ""

#: ../../policy/language.rst:45
msgid "Labels Based"
msgstr ""

#: ../../policy/language.rst:47
msgid ""
"Label-based L3 policy is used to establish policy between endpoints "
"inside the cluster managed by Cilium. Label-based L3 policies are defined"
" by using an `EndpointSelector` inside a rule to choose what kind of "
"traffic that can be received (on ingress), or sent (on egress). An empty "
"`EndpointSelector` allows all traffic. The examples below demonstrate "
"this in further detail."
msgstr ""

#: ../../policy/language.rst:53
msgid ""
"**Kubernetes:** See section :ref:`k8s_namespaces` for details on how the "
"`EndpointSelector` applies in a Kubernetes environment with regard to "
"namespaces."
msgstr ""

#: ../../policy/language.rst:58 ../../policy/language.rst:456
msgid "Ingress"
msgstr ""

#: ../../policy/language.rst:60
msgid ""
"An endpoint is allowed to receive traffic from another endpoint if at "
"least one ingress rule exists which selects the destination endpoint with"
" the `EndpointSelector` in the ``endpointSelector`` field. To restrict "
"traffic upon ingress to the selected endpoint, the rule selects the "
"source endpoint with the `EndpointSelector` in the ``fromEndpoints`` "
"field."
msgstr ""

#: ../../policy/language.rst:67
msgid "Simple Ingress Allow"
msgstr ""

#: ../../policy/language.rst:69
msgid ""
"The following example illustrates how to use a simple ingress rule to "
"allow communication from endpoints with the label ``role=frontend`` to "
"endpoints with the label ``role=backend``."
msgstr ""

#: ../../policy/language.rst:89
msgid "Ingress Allow All Endpoints"
msgstr ""

#: ../../policy/language.rst:91
msgid ""
"An empty `EndpointSelector` will select all endpoints, thus writing a "
"rule that will allow all ingress traffic to an endpoint may be done as "
"follows:"
msgstr ""

#: ../../policy/language.rst:108
msgid ""
"Note that while the above examples allow all ingress traffic to an "
"endpoint, this does not mean that all endpoints are allowed to send "
"traffic to this endpoint per their policies. In other words, policy must "
"be configured on both sides (sender and receiver)."
msgstr ""

#: ../../policy/language.rst:113 ../../policy/language.rst:469
msgid "Egress"
msgstr ""

#: ../../policy/language.rst:115
msgid ""
"An endpoint is allowed to send traffic to another endpoint if at least "
"one egress rule exists which selects the destination endpoint with the "
"`EndpointSelector` in the ``endpointSelector`` field. To restrict traffic"
" upon egress to the selected endpoint, the rule selects the destination "
"endpoint with the `EndpointSelector` in the ``toEndpoints`` field."
msgstr ""

#: ../../policy/language.rst:122
msgid "Simple Egress Allow"
msgstr ""

#: ../../policy/language.rst:124
msgid ""
"The following example illustrates how to use a simple egress rule to "
"allow communication to endpoints with the label ``role=backend`` from "
"endpoints with the label ``role=frontend``."
msgstr ""

#: ../../policy/language.rst:144
msgid "Egress Allow All Endpoints"
msgstr ""

#: ../../policy/language.rst:146
msgid ""
"An empty `EndpointSelector` will select all egress endpoints from an "
"endpoint based on the `CiliumNetworkPolicy` namespace (``default`` by "
"default). The following rule allows all egress traffic from endpoints "
"with the label ``role=frontend`` to all other endpoints in the same "
"namespace:"
msgstr ""

#: ../../policy/language.rst:166
msgid ""
"Note that while the above examples allow all egress traffic from an "
"endpoint, the receivers of the egress traffic may have ingress rules that"
" deny the traffic. In other words, policy must be configured on both "
"sides (sender and receiver)."
msgstr ""

#: ../../policy/language.rst:171
msgid "Ingress/Egress Default Deny"
msgstr ""

#: ../../policy/language.rst:173
msgid ""
"An endpoint can be put into the default deny mode at ingress or egress if"
" a rule selects the endpoint and contains the respective rule section "
"ingress or egress."
msgstr ""

#: ../../policy/language.rst:177
msgid ""
"Any rule selecting the endpoint will have this effect, this example "
"illustrates how to put an endpoint into default deny mode without "
"whitelisting other peers at the same time."
msgstr ""

#: ../../policy/language.rst:196
msgid "Additional Label Requirements"
msgstr ""

#: ../../policy/language.rst:198
msgid ""
"It is often required to apply the principle of *separation of concern* "
"when defining policies. For this reason, an additional construct exists "
"which allows to establish base requirements for any connectivity to "
"happen."
msgstr ""

#: ../../policy/language.rst:202
msgid ""
"For this purpose, the ``fromRequires`` field can be used to establish "
"label requirements which serve as a foundation for any ``fromEndpoints`` "
"relationship.  ``fromRequires`` is a list of additional constraints which"
" must be met in order for the selected endpoints to be reachable. These "
"additional constraints do not grant access privileges by themselves, so "
"to allow traffic there must also be rules which match ``fromEndpoints``. "
"The same applies for egress policies, with ``toRequires`` and "
"``toEndpoints``."
msgstr ""

#: ../../policy/language.rst:210
msgid ""
"The purpose of this rule is to allow establishing base requirements such "
"as, any endpoint in ``env=prod`` can only be accessed if the source "
"endpoint also carries the label ``env=prod``."
msgstr ""

#: ../../policy/language.rst:214
msgid ""
"This example shows how to require every endpoint with the label "
"``env=prod`` to be only accessible if the source endpoint also has the "
"label ``env=prod``."
msgstr ""

#: ../../policy/language.rst:231
msgid ""
"This ``fromRequires`` rule doesn't allow anything on its own and needs to"
" be combined with other rules to allow traffic. For example, when "
"combined with the example policy below, the endpoint with label "
"``env=prod`` will become accessible from endpoints that have both labels "
"``env=prod`` and ``role=frontend``."
msgstr ""

#: ../../policy/language.rst:254
msgid "Services based"
msgstr ""

#: ../../policy/language.rst:256
msgid ""
"Services running in your cluster can be whitelisted in Egress rules. "
"Currently Kubernetes `Services without a Selector "
"<https://kubernetes.io/docs/concepts/services-networking/service"
"/#services-without-selectors>`_ are supported when defined by their name "
"and namespace or label selector. Future versions of Cilium will support "
"specifying non-Kubernetes services and Kubernetes services which are "
"backed by pods."
msgstr ""

#: ../../policy/language.rst:263
msgid ""
"This example shows how to allow all endpoints with the label ``id=app2`` "
"to talk to all endpoints of kubernetes service ``myservice`` in "
"kubernetes namespace ``default``."
msgstr ""

#: ../../policy/language.rst:269
msgid ""
"These rules will only take effect on Kubernetes services without a "
"selector."
msgstr ""

#: ../../policy/language.rst:286
msgid ""
"This example shows how to allow all endpoints with the label ``id=app2`` "
"to talk to all endpoints of all kubernetes headless services which have "
"``head:none`` set as the label."
msgstr ""

#: ../../policy/language.rst:308
msgid "Entities Based"
msgstr ""

#: ../../policy/language.rst:310
msgid ""
"``fromEntities`` is used to describe the entities that can access the "
"selected endpoints. ``toEntities`` is used to describe the entities that "
"can be accessed by the selected endpoints."
msgstr ""

#: ../../policy/language.rst:314
msgid "The following entities are defined:"
msgstr ""

#: ../../policy/language.rst:317
msgid "host"
msgstr ""

#: ../../policy/language.rst:317
msgid ""
"The host entity includes the local host. This also includes all "
"containers running in host networking mode on the local host."
msgstr ""

#: ../../policy/language.rst:321
msgid "remote-node"
msgstr ""

#: ../../policy/language.rst:320
msgid ""
"Any node in any of the connected clusters other than the local host. This"
" also includes all containers running in host-networking mode on remote "
"nodes. (Requires the option ``enable-remote-node-identity`` to be "
"enabled)"
msgstr ""

#: ../../policy/language.rst:325
msgid "kube-apiserver"
msgstr ""

#: ../../policy/language.rst:324
msgid ""
"The kube-apiserver entity represents the kube-apiserver in a Kubernetes "
"cluster. This entity represents both deployments of the kube-apiserver: "
"within the cluster and outside of the cluster."
msgstr ""

#: ../../policy/language.rst:330
msgid "cluster"
msgstr ""

#: ../../policy/language.rst:328
msgid ""
"Cluster is the logical group of all network endpoints inside of the local"
" cluster. This includes all Cilium-managed endpoints of the local "
"cluster, unmanaged endpoints in the local cluster, as well as the host, "
"remote-node, and init identities."
msgstr ""

#: ../../policy/language.rst:335
msgid "init"
msgstr ""

#: ../../policy/language.rst:333
msgid ""
"The init entity contains all endpoints in bootstrap phase for which the "
"security identity has not been resolved yet. This is typically only "
"observed in non-Kubernetes environments. See section "
":ref:`endpoint_lifecycle` for details."
msgstr ""

#: ../../policy/language.rst:339
msgid "health"
msgstr ""

#: ../../policy/language.rst:338
msgid ""
"The health entity represents the health endpoints, used to check cluster "
"connectivity health. Each node managed by Cilium hosts a health endpoint."
" See `cluster_connectivity_health` for details on health checks."
msgstr ""

#: ../../policy/language.rst:343
msgid "unmanaged"
msgstr ""

#: ../../policy/language.rst:342
msgid ""
"The unmanaged entity represents endpoints not managed by Cilium. "
"Unmanaged endpoints are considered part of the cluster and are included "
"in the cluster entity."
msgstr ""

#: ../../policy/language.rst:348
msgid "world"
msgstr ""

#: ../../policy/language.rst:346
msgid ""
"The world entity corresponds to all endpoints outside of the cluster. "
"Allowing to world is identical to allowing to CIDR 0.0.0.0/0. An "
"alternative to allowing from and to world is to define fine grained DNS "
"or CIDR based policies."
msgstr ""

#: ../../policy/language.rst:352
msgid "all"
msgstr ""

#: ../../policy/language.rst:351
msgid ""
"The all entity represents the combination of all known clusters as well "
"world and whitelists all communication."
msgstr ""

#: ../../policy/language.rst:354
msgid ""
"Allowing users to define custom entities is on the roadmap but has not "
"been implemented yet (see :gh-issue:`3553`)."
msgstr ""

#: ../../policy/language.rst:359
msgid "Access to/from local host"
msgstr ""

#: ../../policy/language.rst:361
msgid ""
"Allow all endpoints with the label ``env=dev`` to access the host that is"
" serving the particular endpoint."
msgstr ""

#: ../../policy/language.rst:364
msgid ""
"Kubernetes will automatically allow all communication from the local host"
" of all local endpoints. You can run the agent with the option ``--allow-"
"localhost=policy`` to disable this behavior which will give you control "
"over this via policy."
msgstr ""

#: ../../policy/language.rst:386
msgid "Access to/from all nodes in the cluster"
msgstr ""

#: ../../policy/language.rst:388
msgid ""
"Allow all endpoints with the label ``env=dev`` to receive traffic from "
"any host in the cluster that Cilium is running on."
msgstr ""

#: ../../policy/language.rst:406
msgid "Access to/from outside cluster"
msgstr ""

#: ../../policy/language.rst:408
msgid ""
"This example shows how to enable access from outside of the cluster to "
"all endpoints that have the label ``role=public``."
msgstr ""

#: ../../policy/language.rst:429
msgid "IP/CIDR based"
msgstr ""

#: ../../policy/language.rst:431
msgid ""
"CIDR policies are used to define policies to and from endpoints which are"
" not managed by Cilium and thus do not have labels associated with them. "
"These are typically external services, VMs or metal machines running in "
"particular subnets. CIDR policy can also be used to limit access to "
"external services, for example to limit external access to a particular "
"IP range. CIDR policies can be applied at ingress or egress."
msgstr ""

#: ../../policy/language.rst:438
msgid ""
"CIDR rules apply if Cilium cannot map the source or destination to an "
"identity derived from endpoint labels, ie the `reserved_labels`. For "
"example, CIDR rules will apply to traffic where one side of the "
"connection is:"
msgstr ""

#: ../../policy/language.rst:442
msgid "A network endpoint outside the cluster"
msgstr ""

#: ../../policy/language.rst:443
msgid "The host network namespace where the pod is running."
msgstr ""

#: ../../policy/language.rst:444
msgid ""
"Within the cluster prefix but the IP's networking is not provided by "
"Cilium."
msgstr ""

#: ../../policy/language.rst:446
msgid ""
"Conversely, CIDR rules do not apply to traffic where both sides of the "
"connection are either managed by Cilium or use an IP belonging to a node "
"in the cluster (including host networking pods). This traffic may be "
"allowed using labels, services or entities -based policies as described "
"above."
msgstr ""

#: ../../policy/language.rst:453
msgid ""
"When running Cilium on Linux 4.10 or earlier, there are "
":ref:`cidr_limitations`."
msgstr ""

#: ../../policy/language.rst:460
msgid "fromCIDR"
msgstr ""

#: ../../policy/language.rst:459
msgid ""
"List of source prefixes/CIDRs that are allowed to talk to all endpoints "
"selected by the ``endpointSelector``."
msgstr ""

#: ../../policy/language.rst:466
msgid "fromCIDRSet"
msgstr ""

#: ../../policy/language.rst:463
msgid ""
"List of source prefixes/CIDRs that are allowed to talk to all endpoints "
"selected by the ``endpointSelector``, along with an optional list of "
"prefixes/CIDRs per source prefix/CIDR that are subnets of the source "
"prefix/CIDR from which communication is not allowed."
msgstr ""

#: ../../policy/language.rst:475
msgid "toCIDR"
msgstr ""

#: ../../policy/language.rst:472
msgid ""
"List of destination prefixes/CIDRs that endpoints selected by "
"``endpointSelector`` are allowed to talk to. Note that endpoints which "
"are selected by a ``fromEndpoints`` are automatically allowed to reply "
"back to the respective destination endpoints."
msgstr ""

#: ../../policy/language.rst:481
msgid "toCIDRSet"
msgstr ""

#: ../../policy/language.rst:478
msgid ""
"List of destination prefixes/CIDRs that are allowed to talk to all "
"endpoints selected by the ``endpointSelector``, along with an optional "
"list of prefixes/CIDRs per source prefix/CIDR that are subnets of the "
"destination prefix/CIDR to which communication is not allowed."
msgstr ""

#: ../../policy/language.rst:484
msgid "Allow to external CIDR block"
msgstr ""

#: ../../policy/language.rst:486
msgid ""
"This example shows how to allow all endpoints with the label "
"``app=myService`` to talk to the external IP ``20.1.1.1``, as well as the"
" CIDR prefix ``10.0.0.0/8``, but not CIDR prefix ``10.96.0.0/12``"
msgstr ""

#: ../../policy/language.rst:507
msgid "DNS based"
msgstr ""

#: ../../policy/language.rst:509
msgid ""
"DNS policies are used to define Layer 3 policies to endpoints that are "
"not managed by Cilium, but have DNS queryable domain names. The IP "
"addresses provided in DNS responses are allowed by Cilium in a similar "
"manner to IPs in `CIDR based`_ policies. They are an alternative when the"
" remote IPs may change or are not know a priori, or when DNS is more "
"convenient. To enforce policy on DNS requests themselves, see `Layer 7 "
"Examples`_."
msgstr ""

#: ../../policy/language.rst:516
msgid ""
"IP information is captured from DNS responses per-Endpoint via a `DNS "
"Proxy`_. An L3 `CIDR based`_ rule is generated for every ``toFQDNs`` rule"
" and applies to the same endpoints. The IP information is selected for "
"insertion by ``matchName`` or ``matchPattern`` rules, and is collected "
"from all DNS responses seen by Cilium on the node. Multiple selectors may"
" be included in a single egress rule. See :ref:`DNS Obtaining Data` for "
"information on collecting this IP data."
msgstr ""

#: ../../policy/language.rst:524
msgid ""
"``toFQDNs`` egress rules cannot contain any other L3 rules, such as "
"``toEndpoints`` (under `Labels Based`_) and ``toCIDRs`` (under `CIDR "
"Based`_). They may contain L4/L7 rules, such as ``toPorts`` (see `Layer 4"
" Examples`_) with, optionally, ``HTTP`` and ``Kafka`` sections (see "
"`Layer 7 Examples`_)."
msgstr ""

#: ../../policy/language.rst:529
msgid ""
"DNS based rules are intended for external connections and behave "
"similarly to `CIDR based`_ rules. See `Services based`_ and `Labels "
"based`_ for cluster-internal traffic."
msgstr ""

#: ../../policy/language.rst:533
msgid "IPs to be allowed are selected via:"
msgstr ""

#: ../../policy/language.rst:538
msgid "``toFQDNs.matchName``"
msgstr ""

#: ../../policy/language.rst:536
msgid ""
"Inserts IPs of domains that match ``matchName`` exactly. Multiple "
"distinct names may be included in separate ``matchName`` entries and IPs "
"for domains that match any ``matchName`` will be inserted."
msgstr ""

#: ../../policy/language.rst:552
msgid "``toFQDNs.matchPattern``"
msgstr ""

#: ../../policy/language.rst:541
msgid ""
"Inserts IPs of domains that match the pattern in ``matchPattern``, "
"accounting for wildcards. Patterns are composed of literal characters "
"that are allowed in domain names: a-z, 0-9, ``.`` and ``-``."
msgstr ""

#: ../../policy/language.rst:545 ../../policy/language.rst:991
msgid "``*`` is allowed as a wildcard with a number of convenience behaviors:"
msgstr ""

#: ../../policy/language.rst:547 ../../policy/language.rst:993
msgid ""
"``*`` within a domain allows 0 or more valid DNS characters, except for "
"the ``.`` separator. ``*.cilium.io`` will match ``sub.cilium.io`` but not"
" ``cilium.io``. ``part*ial.com`` will match ``partial.com`` and ``part-"
"extra-ial.com``."
msgstr ""

#: ../../policy/language.rst:551
msgid ""
"``*`` alone matches all names, and inserts all cached DNS IPs into this "
"rule."
msgstr ""

#: ../../policy/language.rst:554
msgid ""
"The example below allows all DNS traffic on port 53 to the DNS service "
"and intercepts it via the `DNS Proxy`_. If using a non-standard DNS port "
"for a DNS application behind a Kubernetes service, the port must match "
"the backend port. When the application makes a request for my-remote-"
"service.com, Cilium learns the IP address and will allow traffic due to "
"the match on the name under the ``toFQDNs.matchName`` rule."
msgstr ""

#: ../../policy/language.rst:582
msgid "Managing Long-Lived Connections & Minimum DNS Cache Times"
msgstr ""

#: ../../policy/language.rst:583
msgid ""
"Often, an application may keep a connection open for longer than the DNS "
"TTL. Without further DNS queries the remote IP used in the long-lived "
"connection may expire out of the DNS cache. When this occurs, existing "
"connections established before the TTL expires will continue to be "
"allowed until they terminate. Unused IPs will no longer be allowed, "
"however, even when from the same DNS lookup as an in-use IP. This "
"tracking is per-endpoint per-IP and DNS entries in this state will be "
"have ``source: connection`` with a single IP listed within the ``cilium "
"fqdn cache list`` output."
msgstr ""

#: ../../policy/language.rst:592
msgid ""
"A minimum TTL is used to ensure a lower time bound to DNS data "
"expiration, and IPs allowed by a ``toFQDNs`` rule will be allowed at "
"least this long It can be configured with the ``--tofqdns-min-ttl`` CLI "
"option. The value is in integer seconds and must be 1 or more, the "
"default is 1 hour."
msgstr ""

#: ../../policy/language.rst:597
msgid ""
"Some care needs to be taken when setting ``--tofqdns-min-ttl`` with DNS "
"data that returns many distinct IPs over time. A long TTL will keep each "
"IP cached long after the related connections have terminated. Large "
"numbers of IPs each have corresponding Security Identities and too many "
"may slow down Cilium policy regeneration."
msgstr ""

#: ../../policy/language.rst:604
msgid "Managing Short-Lived Connections & Maximum IPs per FQDN/endpoint"
msgstr ""

#: ../../policy/language.rst:606
msgid ""
"The minimum TTL for DNS entries in the cache is deliberately long with 1 "
"hour as the default. This is done to accommodate long-lived persistent "
"connections. On the other end of the spectrum are workloads that perform "
"short-lived connections in repetition to FQDNs that are backed by a large"
" number of IP addresses (e.g. AWS S3)."
msgstr ""

#: ../../policy/language.rst:612
msgid ""
"Many short-lived connections can grow the number of IPs mapping to an "
"FQDN quickly. In order to limit the number of IP addresses that map a "
"particular FQDN, each FQDN has a per-endpoint max capacity of IPs that "
"will be retained (default: 50). Once this limit is exceeded, the oldest "
"IP entries are automatically expired from the cache. This capacity can be"
" changed using the ``--tofqdns-max-ip-per-hostname`` option."
msgstr ""

#: ../../policy/language.rst:619
msgid ""
"As with long-lived connections above, live connections are not expired "
"until they terminate. It is safe to mix long- and short-lived connections"
" from the same Pod. IPs above the limit described above will only be "
"removed if unused by a connection."
msgstr ""

#: ../../policy/language.rst:629
msgid "Layer 4 Examples"
msgstr ""

#: ../../policy/language.rst:632
msgid "Limit ingress/egress ports"
msgstr ""

#: ../../policy/language.rst:634
msgid ""
"Layer 4 policy can be specified in addition to layer 3 policies or "
"independently. It restricts the ability of an endpoint to emit and/or "
"receive packets on a particular port using a particular protocol. If no "
"layer 4 policy is specified for an endpoint, the endpoint is allowed to "
"send and receive on all layer 4 ports and protocols including ICMP. If "
"any layer 4 policy is specified, then ICMP will be blocked unless it's "
"related to a connection that is otherwise allowed by the policy. Layer 4 "
"policies apply to ports after service port mapping has been applied."
msgstr ""

#: ../../policy/language.rst:643
msgid ""
"Layer 4 policy can be specified at both ingress and egress using the "
"``toPorts`` field. The ``toPorts`` field takes a ``PortProtocol`` "
"structure which is defined as follows:"
msgstr ""

#: ../../policy/language.rst:666
msgid "Example (L4)"
msgstr ""

#: ../../policy/language.rst:668
msgid ""
"The following rule limits all endpoints with the label ``app=myService`` "
"to only be able to emit packets using TCP on port 80, to any layer 3 "
"destination:"
msgstr ""

#: ../../policy/language.rst:686
msgid "Labels-dependent Layer 4 rule"
msgstr ""

#: ../../policy/language.rst:688
msgid ""
"This example enables all endpoints with the label ``role=frontend`` to "
"communicate with all endpoints with the label ``role=backend``, but they "
"must communicate using TCP on port 80. Endpoints with other labels will "
"not be able to communicate with the endpoints with the label "
"``role=backend``, and endpoints with the label ``role=frontend`` will not"
" be able to communicate with ``role=backend`` on ports other than 80."
msgstr ""

#: ../../policy/language.rst:710
msgid "CIDR-dependent Layer 4 Rule"
msgstr ""

#: ../../policy/language.rst:712
msgid ""
"This example enables all endpoints with the label ``role=crawler`` to "
"communicate with all remote destinations inside the CIDR "
"``192.0.2.0/24``, but they must communicate using TCP on port 80. The "
"policy does not allow Endpoints without the label ``role=crawler`` to "
"communicate with destinations in the CIDR ``192.0.2.0/24``. Furthermore, "
"endpoints with the label ``role=crawler`` will not be able to communicate"
" with destinations in the CIDR ``192.0.2.0/24`` on ports other than port "
"80."
msgstr ""

#: ../../policy/language.rst:739
msgid "Layer 7 Examples"
msgstr ""

#: ../../policy/language.rst:741
msgid ""
"Layer 7 policy rules are embedded into `l4_policy` rules and can be "
"specified for ingress and egress. ``L7Rules`` structure is a base type "
"containing an enumeration of protocol specific fields."
msgstr ""

#: ../../policy/language.rst:767
msgid ""
"The structure is implemented as a union, i.e. only one member field can "
"be used per port. If multiple ``toPorts`` rules with identical "
"``PortProtocol`` select an overlapping list of endpoints, then the layer "
"7 rules are combined together if they are of the same type. If the type "
"differs, the policy is rejected."
msgstr ""

#: ../../policy/language.rst:772
msgid ""
"Each member consists of a list of application protocol rules. A layer 7 "
"request is permitted if at least one of the rules matches. If no rules "
"are specified, then all traffic is permitted."
msgstr ""

#: ../../policy/language.rst:776
msgid ""
"If a layer 4 rule is specified in the policy, and a similar layer 4 rule "
"with layer 7 rules is also specified, then the layer 7 portions of the "
"latter rule will have no effect."
msgstr ""

#: ../../policy/language.rst:780
msgid ""
"Unlike layer 3 and layer 4 policies, violation of layer 7 rules does not "
"result in packet drops. Instead, if possible, an application protocol "
"specific access denied message is crafted and returned, e.g. an *HTTP 403"
" access denied* is sent back for HTTP requests which violate the policy, "
"or a *DNS REFUSED* response for DNS requests."
msgstr ""

#: ../../policy/language.rst:786
msgid ""
"There is currently a max limit of 40 ports with layer 7 policies per "
"endpoint. This might change in the future when support for ranges is "
"added."
msgstr ""

#: ../../policy/language.rst:790
msgid ""
"Layer 7 rules are not currently supported in `HostPolicies`, i.e., "
"policies that use :ref:`NodeSelector`."
msgstr ""

#: ../../policy/language.rst:794
msgid "HTTP"
msgstr ""

#: ../../policy/language.rst:796 ../../policy/language.rst:878
msgid "The following fields can be matched on:"
msgstr ""

#: ../../policy/language.rst:802
msgid "Path"
msgstr ""

#: ../../policy/language.rst:799
msgid ""
"Path is an extended POSIX regex matched against the path of a request. "
"Currently it can contain characters disallowed from the conventional "
"\"path\" part of a URL as defined by RFC 3986. Paths must begin with a "
"``/``. If omitted or empty, all paths are all allowed."
msgstr ""

#: ../../policy/language.rst:807
msgid "Method"
msgstr ""

#: ../../policy/language.rst:805
msgid ""
"Method is an extended POSIX regex matched against the method of a "
"request, e.g. ``GET``, ``POST``, ``PUT``, ``PATCH``, ``DELETE``, ...  If "
"omitted or empty, all methods are allowed."
msgstr ""

#: ../../policy/language.rst:812
msgid "Host"
msgstr ""

#: ../../policy/language.rst:810
msgid ""
"Host is an extended POSIX regex matched against the host header of a "
"request, e.g. ``foo.com``. If omitted or empty, the value of the host "
"header is ignored."
msgstr ""

#: ../../policy/language.rst:816
msgid "Headers"
msgstr ""

#: ../../policy/language.rst:815
msgid ""
"Headers is a list of HTTP headers which must be present in the request. "
"If omitted or empty, requests are allowed regardless of headers present."
msgstr ""

#: ../../policy/language.rst:819
msgid "Allow GET /public"
msgstr ""

#: ../../policy/language.rst:821
msgid ""
"The following example allows ``GET`` requests to the URL ``/public`` to "
"be allowed to endpoints with the labels ``env:prod``, but requests to any"
" other URL, or using another method, will be rejected. Requests on ports "
"other than port 80 will be dropped."
msgstr ""

#: ../../policy/language.rst:841
msgid "All GET /path1 and PUT /path2 when header set"
msgstr ""

#: ../../policy/language.rst:843
msgid ""
"The following example limits all endpoints which carry the labels "
"``app=myService`` to only be able to receive packets on port 80 using "
"TCP. While communicating on this port, the only API endpoints allowed "
"will be ``GET /path1``, and ``PUT /path2`` with the HTTP header ``X-My-"
"Header`` set to ``true``:"
msgstr ""

#: ../../policy/language.rst:866
msgid "Kafka (beta)"
msgstr ""

#: ../../beta.rst:3
msgid ""
"This is a beta feature. Please provide feedback and file a GitHub issue "
"if you experience any problems."
msgstr ""

#: ../../policy/language.rst:870
msgid ""
"PortRuleKafka is a list of Kafka protocol constraints. All fields are "
"optional, if all fields are empty or missing, the rule will match all "
"Kafka messages. There are two ways to specify the Kafka rules. We can "
"choose to specify a high-level \"produce\" or \"consume\" role to a topic"
" or choose to specify more low-level Kafka protocol specific apiKeys. "
"Writing rules based on Kafka roles is easier and covers most common use "
"cases, however if more granularity is needed then users can alternatively"
" write rules using specific apiKeys."
msgstr ""

#: ../../policy/language.rst:893
msgid "Role"
msgstr ""

#: ../../policy/language.rst:881
msgid ""
"Role is a case-insensitive string which describes a group of API keys "
"necessary to perform certain higher-level Kafka operations such as "
"\"produce\" or \"consume\". A Role automatically expands into all APIKeys"
" required to perform the specified higher-level operation. The following "
"roles are supported:"
msgstr ""

#: ../../policy/language.rst:887
msgid "\"produce\": Allow producing to the topics specified in the rule."
msgstr ""

#: ../../policy/language.rst:888
msgid "\"consume\": Allow consuming from the topics specified in the rule."
msgstr ""

#: ../../policy/language.rst:890
msgid ""
"This field is incompatible with the APIKey field, i.e APIKey and Role "
"cannot both be specified in the same rule. If omitted or empty, and if "
"APIKey is not specified, then all keys are allowed."
msgstr ""

#: ../../policy/language.rst:899
msgid "APIKey"
msgstr ""

#: ../../policy/language.rst:896
msgid ""
"APIKey is a case-insensitive string matched against the key of a request,"
" for example \"produce\", \"fetch\", \"createtopic\", \"deletetopic\". "
"For a more extensive list, see the `Kafka protocol reference "
"<https://kafka.apache.org/protocol#protocol_api_keys>`_. This field is "
"incompatible with the Role field."
msgstr ""

#: ../../policy/language.rst:904
msgid "APIVersion"
msgstr ""

#: ../../policy/language.rst:902
msgid ""
"APIVersion is the version matched against the api version of the Kafka "
"message. If set, it must be a string representing a positive integer. If "
"omitted or empty, all versions are allowed."
msgstr ""

#: ../../policy/language.rst:917
msgid "ClientID"
msgstr ""

#: ../../policy/language.rst:907
msgid "ClientID is the client identifier as provided in the request."
msgstr ""

#: ../../policy/language.rst:909
msgid ""
"From Kafka protocol documentation: This is a user supplied identifier for"
" the client application. The user can use any identifier they like and it"
" will be used when logging errors, monitoring aggregates, etc. For "
"example, one might want to monitor not just the requests per second "
"overall, but the number coming from each client application (each of "
"which could reside on multiple servers). This id acts as a logical "
"grouping across all requests from a particular client."
msgstr ""

#: ../../policy/language.rst:917
msgid "If omitted or empty, all client identifiers are allowed."
msgstr ""

#: ../../policy/language.rst:928
msgid "Topic"
msgstr ""

#: ../../policy/language.rst:920
msgid ""
"Topic is the topic name contained in the message. If a Kafka request "
"contains multiple topics, then all topics in the message must be allowed "
"by the policy or the message will be rejected."
msgstr ""

#: ../../policy/language.rst:924
msgid ""
"This constraint is ignored if the matched request message type does not "
"contain any topic. The maximum length of the Topic is 249 characters, "
"which must be either ``a-z``, ``A-Z``, ``0-9``, ``-``, ``.`` or ``_``."
msgstr ""

#: ../../policy/language.rst:928
msgid "If omitted or empty, all topics are allowed."
msgstr ""

#: ../../policy/language.rst:931
msgid "Allow producing to topic empire-announce using Role"
msgstr ""

#: ../../policy/language.rst:948
msgid "Allow producing to topic empire-announce using apiKeys"
msgstr ""

#: ../../policy/language.rst:968
msgid "DNS Policy and IP Discovery"
msgstr ""

#: ../../policy/language.rst:970
msgid ""
"Policy may be applied to DNS traffic, allowing or disallowing specific "
"DNS query names or patterns of names (other DNS fields, such as query "
"type, are not considered). This policy is effected via a DNS proxy, which"
" is also used to collect IPs used to populate L3 `DNS based`_ ``toFQDNs``"
" rules."
msgstr ""

#: ../../policy/language.rst:975
msgid ""
"While Layer 7 DNS policy can be applied without any other Layer 3 rules, "
"the presence of a Layer 7 rule (with its Layer 3 and 4 components) will "
"block other traffic."
msgstr ""

#: ../../policy/language.rst:979
msgid "DNS policy may be applied via:"
msgstr ""

#: ../../policy/language.rst:984
msgid "``matchName``"
msgstr ""

#: ../../policy/language.rst:982
msgid ""
"Allows queries for domains that match ``matchName`` exactly. Multiple "
"distinct names may be included in separate ``matchName`` entries and "
"queries for domains that match any ``matchName`` will be allowed."
msgstr ""

#: ../../policy/language.rst:998
msgid "``matchPattern``"
msgstr ""

#: ../../policy/language.rst:987
msgid ""
"Allows queries for domains that match the pattern in ``matchPattern``, "
"accounting for wildcards. Patterns are composed of literal characters "
"that that are allowed in domain names: a-z, 0-9, ``.`` and ``-``."
msgstr ""

#: ../../policy/language.rst:997
msgid ""
"``*`` alone matches all names, and inserts all IPs in DNS responses into "
"the cilium-agent DNS cache."
msgstr ""

#: ../../policy/language.rst:1000
msgid ""
"In this example, L7 DNS policy allows queries for ``cilium.io``, any "
"subdomains of ``cilium.io``, and any subdomains of ``api.cilium.io``. No "
"other DNS queries will be allowed."
msgstr ""

#: ../../policy/language.rst:1004
msgid ""
"The separate L3 ``toFQDNs`` egress rule allows connections to any IPs "
"returned in DNS queries for ``cilium.io``, ``sub.cilium.io``, "
"``service1.api.cilium.io`` and any matches of "
"``special*service.api.cilium.io``, such as ``special-"
"region1-service.api.cilium.io`` but not "
"``region1-service.api.cilium.io``. DNS queries to "
"``anothersub.cilium.io`` are allowed but connections to the returned IPs "
"are not, as there is no L3 ``toFQDNs`` rule selecting them. L4 and L7 "
"policy may also be applied (see `DNS based`_), restricting connections to"
" TCP port 80 in this case."
msgstr ""

#: ../../policy/language.rst:1028
msgid ""
"When applying DNS policy in kubernetes, queries for "
"service.namespace.svc.cluster.local. must be explicitly allowed with "
"``matchPattern: *.*.svc.cluster.local.``."
msgstr ""

#: ../../policy/language.rst:1032
msgid ""
"Similarly, queries that rely on the DNS search list to complete the FQDN "
"must be allowed in their entirety. e.g. A query for ``servicename`` that "
"succeeds with ``servicename.namespace.svc.cluster.local.`` must have the "
"latter allowed with ``matchName`` or ``matchPattern``. See `Alpine/musl "
"deployments and DNS Refused`_."
msgstr ""

#: ../../policy/language.rst:1041
msgid "Obtaining DNS Data for use by ``toFQDNs``"
msgstr ""

#: ../../policy/language.rst:1042
msgid ""
"IPs are obtained via intercepting DNS requests with a proxy or DNS "
"polling, and matching names are inserted irrespective of how the data is "
"obtained. These IPs can be selected with ``toFQDN`` rules. DNS responses "
"are cached within Cilium agent respecting TTL."
msgstr ""

#: ../../policy/language.rst:1050
msgid "DNS Proxy"
msgstr ""

#: ../../policy/language.rst:1051
msgid ""
"A DNS Proxy intercepts egress DNS traffic and records IPs seen in the "
"responses. This interception is, itself, a separate policy rule governing"
" the DNS requests, and must be specified separately. For details on how "
"to enforce policy on DNS requests and configuring the DNS proxy, see "
"`Layer 7 Examples`_."
msgstr ""

#: ../../policy/language.rst:1057
msgid ""
"Only IPs in intercepted DNS responses to an application will be allowed "
"in the Cilium policy rules. For a given domain name, IPs from responses "
"to all pods managed by a Cilium instance are allowed by policy "
"(respecting TTLs). This ensures that allowed IPs are consistent with "
"those returned to applications. The DNS Proxy is the only method to allow"
" IPs from responses allowed by wildcard L7 DNS ``matchPattern`` rules for"
" use in ``toFQDNs`` rules."
msgstr ""

#: ../../policy/language.rst:1065
msgid ""
"The following example obtains DNS data by interception without blocking "
"any DNS requests. It allows L3 connections to ``cilium.io``, "
"``sub.cilium.io`` and any subdomains of ``sub.cilium.io``."
msgstr ""

#: ../../policy/language.rst:1084
msgid "Alpine/musl deployments and DNS Refused"
msgstr ""

#: ../../policy/language.rst:1086
msgid ""
"Some common container images treat the DNS ``Refused`` response when the "
"`DNS Proxy`_ rejects a query as a more general failure. This stops "
"traversal of the search list defined in ``/etc/resolv.conf``. It is "
"common for pods to search by appending ``.svc.cluster.local.`` to DNS "
"queries. When this occurs, a lookup for ``cilium.io`` may first be "
"attempted as ``cilium.io.namespace.svc.cluster.local.`` and rejected by "
"the proxy. Instead of continuing and eventually attempting ``cilium.io.``"
" alone, the Pod treats the DNS lookup is treated as failed."
msgstr ""

#: ../../policy/language.rst:1095
msgid ""
"This can be mitigated with the ``--tofqdns-dns-reject-response-code`` "
"option. The default is ``refused`` but ``nameError`` can be selected, "
"causing the proxy to return a NXDomain response to refused queries."
msgstr ""

#: ../../policy/language.rst:1099
msgid ""
"A more pod-specific solution is to configure ``ndots`` appropriately for "
"each Pod, via ``dnsConfig``, so that the search list is not used for DNS "
"lookups that do not need it. See the `Kubernetes documentation "
"<https://kubernetes.io/docs/concepts/services-networking/dns-pod-"
"service/#pod-s-dns-config>`_ for instructions."
msgstr ""

#: ../../policy/language.rst:1108
msgid "Deny Policies"
msgstr ""

#: ../../policy/language.rst:1112
msgid ""
"Deny policies, available and enabled by default since Cilium 1.9, allows "
"to explicitly restrict certain traffic to and from a Pod."
msgstr ""

#: ../../policy/language.rst:1115
msgid ""
"Deny policies take precedence over allow policies, regardless of whether "
"they are a Cilium Network Policy, a Clusterwide Cilium Network Policy or "
"even a Kubernetes Network Policy."
msgstr ""

#: ../../policy/language.rst:1119
msgid ""
"Similarly to \"allow\" policies, Pods will enter default-deny mode as "
"soon a single policy selects it."
msgstr ""

#: ../../policy/language.rst:1122
msgid ""
"If multiple allow and deny policies are applied to the same pod, the "
"following table represents the expected enforcement for that Pod:"
msgstr ""

#: ../../policy/language.rst:1126
msgid "**Set of Ingress Policies Deployed to Server Pod**"
msgstr ""

#: ../../policy/language.rst:1131
msgid "**Allow Policies**"
msgstr ""

#: ../../policy/language.rst:1128
msgid "Layer 7 (HTTP)"
msgstr ""

#: ../../policy/language.rst:1128 ../../policy/language.rst:1130
#: ../../policy/language.rst:1132 ../../policy/language.rst:1134
#: ../../policy/language.rst:1136 ../../policy/language.rst:1138
msgid "✓"
msgstr ""

#: ../../policy/language.rst:1130 ../../policy/language.rst:1136
msgid "Layer 4 (80/TCP)"
msgstr ""

#: ../../policy/language.rst:1132
msgid "Layer 4 (81/TCP)"
msgstr ""

#: ../../policy/language.rst:1134 ../../policy/language.rst:1138
msgid "Layer 3 (Pod: Client)"
msgstr ""

#: ../../policy/language.rst:1137
msgid "**Deny Policies**"
msgstr ""

#: ../../policy/language.rst:1140
msgid "**Result for Traffic Connections (Allowed / Denied)**"
msgstr ""

#: ../../policy/language.rst:1144
msgid "**Client → Server**"
msgstr ""

#: ../../policy/language.rst:1142
msgid "curl server:81"
msgstr ""

#: ../../policy/language.rst:1142 ../../policy/language.rst:1144
#: ../../policy/language.rst:1146
msgid "Allowed"
msgstr ""

#: ../../policy/language.rst:1142 ../../policy/language.rst:1144
#: ../../policy/language.rst:1146
msgid "Denied"
msgstr ""

#: ../../policy/language.rst:1144
msgid "curl server:80"
msgstr ""

#: ../../policy/language.rst:1146
msgid "ping server"
msgstr ""

#: ../../policy/language.rst:1149
msgid ""
"If we pick the second column in the above table, the bottom section shows"
" the forwarding behaviour for a policy that selects curl or ping traffic "
"between the client and server:"
msgstr ""

#: ../../policy/language.rst:1153
msgid ""
"Curl to port 81 is allowed because there is an allow policy on port 81, "
"and no deny policy on that port;"
msgstr ""

#: ../../policy/language.rst:1155
msgid "Curl to port 80 is denied because there is a deny policy on that port;"
msgstr ""

#: ../../policy/language.rst:1156
msgid ""
"Ping to the server is allowed because there is a Layer 3 allow policy and"
" no deny."
msgstr ""

#: ../../policy/language.rst:1158
msgid ""
"The following policy will deny ingress from \"world\" on all namespaces "
"on all Pods managed by Cilium. Existing inter-cluster policies will still"
" be allowed as this policy is allowing traffic from everywhere except "
"from \"world\"."
msgstr ""

#: ../../policy/language.rst:1173
msgid ""
"Deny policies do not support: policy enforcement at L7, i.e., "
"specifically denying an URL and ``toFQDNs``, i.e., specifically denying "
"traffic to a specific domain name."
msgstr ""

#: ../../policy/language.rst:1178
msgid "Limitations and known issues"
msgstr ""

#: ../../policy/language.rst:1180
msgid ""
"The current known limitation is a deny policy with ``toEntities`` "
"\"world\" for which a ``toFQDNs`` can cause traffic to be allowed if such"
" traffic is considered external to the cluster."
msgstr ""

#: ../../policy/language.rst:1215
msgid "Host Policies"
msgstr ""

#: ../../policy/language.rst:1217
msgid ""
"Host policies take the form of a `CiliumClusterwideNetworkPolicy` with a "
":ref:`NodeSelector` instead of an `EndpointSelector`. Host policies can "
"have layer 3 and layer 4 rules on both ingress and egress. They cannot "
"have layer 7 rules."
msgstr ""

#: ../../policy/language.rst:1222
msgid ""
"Host policies apply to all the nodes selected by their "
":ref:`NodeSelector`. In each selected node, they apply only to the host "
"namespace, including host-networking pods. They therefore don't apply to "
"communications between non-host-networking pods and locations outside of "
"the cluster."
msgstr ""

#: ../../policy/language.rst:1227
msgid ""
"Installation of Host Policies requires the addition of the following "
"``helm`` flags when installing Cilium:"
msgstr ""

#: ../../policy/language.rst:1230
msgid ""
"``--set devices='{interface}'`` where ``interface`` refers to the network"
" device Cilium is configured on such as ``eth0``. Omitting this option "
"leads Cilium to auto-detect what interface the host firewall applies to."
msgstr ""

#: ../../policy/language.rst:1233
msgid "``--set hostFirewall.enabled=true``"
msgstr ""

#: ../../policy/language.rst:1235
msgid ""
"The following policy will allow ingress traffic for any node with the "
"label ``type=ingress-worker`` on TCP ports 22, 6443 (kube-apiserver), "
"2379 (etcd) and 4240 (health checks), as well as UDP port 8472 (VXLAN)."
msgstr ""

#: ../../policy/language.rst:1239
msgid "Replace the ``port:`` value with ports used in your environment."
msgstr ""

#: ../../policy/language.rst:1253
msgid "Troubleshooting Host Policies"
msgstr ""

#: ../../policy/language.rst:1255
msgid ""
"If you're having troubles with Host Policies please ensure the ``helm`` "
"options listed above were applied during installation. To verify that "
"your policy has been applied, you can run ``kubectl get "
"CiliumClusterwideNetworkPolicy -o yaml`` to validate the policy was "
"accepted."
msgstr ""

#: ../../policy/language.rst:1260
msgid ""
"If policies don't seem to be applied to your nodes, verify the "
"``nodeSelector`` is labeled correctly in your environment. In the example"
" configuration, you can run ``kubectl get nodes -o wide|grep type"
"=ingress-worker`` to verify labels match the policy."
msgstr ""

#: ../../policy/language.rst:1265
msgid ""
"You can verify the policy was applied by running ``kubectl exec -n "
"$CILIUM_NAMESPACE cilium-xxxx -- cilium policy get`` for the Cilium agent"
" pod. Verify that the host is selected by the policy using ``cilium "
"endpoint list`` and look for the endpoint with ``reserved:host`` as the "
"label and ensure that policy is enabled in the selected direction. Ensure"
" the traffic is arriving on the device visible on the ``NodePort`` field "
"of the ``cilium status list`` output. Use ``cilium monitor`` with "
"``--related-to`` and the endpoint ID of the ``reserved:host`` endpoint to"
" view traffic."
msgstr ""

#: ../../policy/lifecycle.rst:11
msgid "Endpoint Lifecycle"
msgstr ""

#: ../../policy/lifecycle.rst:13
msgid "This section specifies the lifecycle of Cilium endpoints."
msgstr ""

#: ../../policy/lifecycle.rst:15
msgid "Every endpoint in Cilium is in one of the following states:"
msgstr ""

#: ../../policy/lifecycle.rst:17
msgid ""
"``restoring``: The endpoint was started before Cilium started, and Cilium"
" is restoring its networking configuration."
msgstr ""

#: ../../policy/lifecycle.rst:19
msgid ""
"``waiting-for-identity``: Cilium is allocating a unique identity for the "
"endpoint."
msgstr ""

#: ../../policy/lifecycle.rst:21
msgid ""
"``waiting-to-regenerate``: The endpoint received an identity and is "
"waiting for its networking configuration to be (re)generated."
msgstr ""

#: ../../policy/lifecycle.rst:23
msgid ""
"``regenerating``: The endpoint's networking configuration is being "
"(re)generated. This includes programming eBPF for that endpoint."
msgstr ""

#: ../../policy/lifecycle.rst:25
msgid ""
"``ready``: The endpoint's networking configuration has been successfully "
"(re)generated."
msgstr ""

#: ../../policy/lifecycle.rst:27
msgid "``disconnecting``: The endpoint is being deleted."
msgstr ""

#: ../../policy/lifecycle.rst:28
msgid "``disconnected``: The endpoint has been deleted."
msgstr ""

#: ../../policy/lifecycle.rst:34
msgid ""
"The state of an endpoint can be queried using the ``cilium endpoint "
"list`` and ``cilium endpoint get`` CLI commands."
msgstr ""

#: ../../policy/lifecycle.rst:37
msgid ""
"While an endpoint is running, it transitions between the ``waiting-for-"
"identity``, ``waiting-to-regenerate``, ``regenerating``, and ``ready`` "
"states.  A transition into the ``waiting-for-identity`` state indicates "
"that the endpoint changed its identity.  A transition into the ``waiting-"
"to-regenerate`` or ``regenerating`` state indicates that the policy to be"
" enforced on the endpoint has changed because of a change in identity, "
"policy, or configuration."
msgstr ""

#: ../../policy/lifecycle.rst:45
msgid ""
"An endpoint transitions into the ``disconnecting`` state when it is being"
" deleted, regardless of its current state."
msgstr ""

#: ../../policy/lifecycle.rst:51
msgid "Init Identity"
msgstr ""

#: ../../policy/lifecycle.rst:53
msgid ""
"In some situations, Cilium can't determine the labels of an endpoint "
"immediately when the endpoint is created, and therefore can't allocate an"
" identity for the endpoint at that point.  Until the endpoint's labels "
"are known, Cilium temporarily associates a special single label "
"``reserved:init`` to the endpoint. When the endpoint's labels become "
"known, Cilium then replaces that special label with the endpoint's labels"
" and allocates a proper identity to the endpoint."
msgstr ""

#: ../../policy/lifecycle.rst:61
msgid ""
"This may occur during endpoint creation in the following cases: * Running"
" Cilium with docker via libnetwork * With Kubernetes when the Kubernetes "
"API server is not available * In etcd mode when the corresponding kvstore"
" is not available"
msgstr ""

#: ../../policy/lifecycle.rst:66
msgid ""
"To allow traffic to/from endpoints while they are initializing, you can "
"create policy rules that select the ``reserved:init`` label, and/or rules"
" that allow traffic to/from the special ``init`` entity."
msgstr ""

#: ../../policy/lifecycle.rst:70
msgid ""
"For instance, writing a rule that allows all initializing endpoints to "
"receive connections from the host and to perform DNS queries may be done "
"as follows:"
msgstr ""

#: ../../policy/lifecycle.rst:88
msgid ""
"Likewise, writing a rule that allows an endpoint to receive DNS queries "
"from initializing endpoints may be done as follows:"
msgstr ""

#: ../../policy/lifecycle.rst:105
msgid ""
"If any ingress (resp. egress) policy rules selects the ``reserved:init`` "
"label, all ingress (resp. egress) traffic to (resp. from) initializing "
"endpoints that is not explicitly allowed by those rules will be dropped."
"  Otherwise, if the policy enforcement mode is ``never`` or ``default``, "
"all ingress (resp. egress) traffic is allowed to (resp. from) "
"initializing endpoints.  Otherwise, all ingress (resp. egress) traffic is"
" dropped."
msgstr ""

#: ../../policy/troubleshooting.rst:11 ../../policy/visibility.rst:66
msgid "Troubleshooting"
msgstr ""

#: ../../policy/troubleshooting.rst:14
msgid "Policy Rule to Endpoint Mapping"
msgstr ""

#: ../../policy/troubleshooting.rst:16
msgid ""
"To determine which policy rules are currently in effect for an endpoint "
"the data from ``cilium endpoint list`` and ``cilium endpoint get`` can be"
" paired with the data from ``cilium policy get``. ``cilium endpoint get``"
" will list the labels of each rule that applies to an endpoint. The list "
"of labels can be passed to ``cilium policy get`` to show that exact "
"source policy.  Note that rules that have no labels cannot be fetched "
"alone (a no label ``cilium policy get`` returns the complete policy on "
"the node). Rules with the same labels will be returned together."
msgstr ""

#: ../../policy/troubleshooting.rst:25
msgid ""
"In the above example, for one of the ``deathstar`` pods the endpoint id "
"is 568. We can print all policies applied to it with:"
msgstr ""

#: ../../policy/troubleshooting.rst:100
msgid "Troubleshooting ``toFQDNs`` rules"
msgstr ""

#: ../../policy/troubleshooting.rst:102
msgid ""
"The effect of ``toFQDNs`` may change long after a policy is applied, as "
"DNS data changes. This can make it difficult to debug unexpectedly "
"blocked connections, or transient failures. Cilium provides CLI tools to "
"introspect the state of applying FQDN policy in multiple layers of the "
"daemon:"
msgstr ""

#: ../../policy/troubleshooting.rst:107
msgid "``cilium policy get`` should show the FQDN policy that was imported:"
msgstr ""

#: ../../policy/troubleshooting.rst:180
msgid ""
"After making a DNS request, the FQDN to IP mapping should be available "
"via ``cilium fqdn cache list``:"
msgstr ""

#: ../../policy/troubleshooting.rst:190
msgid ""
"If the traffic is allowed, then these IPs should have corresponding local"
" identities via ``cilium identity list | grep <IP>``:"
msgstr ""

#: ../../policy/visibility.rst:11
msgid "Layer 7 Protocol Visibility"
msgstr ""

#: ../../policy/visibility.rst:13
msgid ""
"While :ref:`monitor` provides introspection into datapath state, by "
"default it will only provide visibility into L3/L4 packet events. If "
":ref:`l7_policy` are configured, one can get visibility into L7 "
"protocols, but this requires the full policy for each selected endpoint "
"to be written. To get more visibility into the application without "
"configuring a full policy, Cilium provides a means of prescribing "
"visibility via `annotations <https://kubernetes.io/docs/concepts/overview"
"/working-with-objects/annotations/>`_ when running in tandem with "
"Kubernetes."
msgstr ""

#: ../../policy/visibility.rst:21
msgid ""
"Visibility information is represented by a comma-separated list of tuples"
" in the annotation:"
msgstr ""

#: ../../policy/visibility.rst:24
msgid "``<{Traffic Direction}/{L4 Port}/{L4 Protocol}/{L7 Protocol}>``"
msgstr ""

#: ../../policy/visibility.rst:26
msgid "For example:"
msgstr ""

#: ../../policy/visibility.rst:33
msgid ""
"To do this, you can provide the annotation in your Kubernetes YAMLs, or "
"via the command line, e.g.:"
msgstr ""

#: ../../policy/visibility.rst:40
msgid ""
"Cilium will pick up that pods have received these annotations, and will "
"transparently redirect traffic to the proxy such that the output of "
"``cilium monitor`` shows traffic being redirected to the proxy, e.g.:"
msgstr ""

#: ../../policy/visibility.rst:49
msgid ""
"You can check the status of the visibility policy by checking the Cilium "
"endpoint of that pod, for example:"
msgstr ""

#: ../../policy/visibility.rst:68
msgid ""
"If L7 visibility is not appearing in ``cilium monitor`` or Hubble "
"components, it is worth double-checking that:"
msgstr ""

#: ../../policy/visibility.rst:71
msgid ""
"No enforcement policy is applied in the direction specified in the "
"annotation"
msgstr ""

#: ../../policy/visibility.rst:73
msgid ""
"The \"Visibility Policy\" column in the CiliumEndpoint shows ``OK``. If "
"it is blank, then no annotation is configured; if it shows an error then "
"there is a problem with the visibility annotation."
msgstr ""

#: ../../policy/visibility.rst:77
msgid ""
"The following example deliberately misconfigures the annotation to "
"demonstrate that the CiliumEndpoint for the pod presents an error when "
"the visibility annotation cannot be implemented:"
msgstr ""

#: ../../policy/visibility.rst:91
msgid "Limitations"
msgstr ""

#: ../../policy/visibility.rst:93
msgid ""
"Visibility annotations do not apply if rules are imported which select "
"the pod which is annotated."
msgstr ""

#: ../../policy/visibility.rst:95
msgid "DNS visibility is available on egress only."
msgstr ""

#: ../../policy/visibility.rst:96
msgid ""
"Proxylib parsers are not supported, including Kafka. To gain visibility "
"on these protocols, you must create a network policy that allows all of "
"the traffic at L7, either by following :ref:`l7_policy` (:ref:`Kafka "
"<kafka_policy>`) or the :ref:`envoy` proxylib extensions guide. This "
"limitation is tracked by :gh-issue:`14072`."
msgstr ""

