# SOME DESCRIPTIVE TITLE.
# Copyright (C) Cilium Authors
# This file is distributed under the same license as the Cilium package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: Cilium\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-05-25 23:56+0800\n"
"PO-Revision-Date: 2022-06-10 23:16+0800\n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"
"X-Generator: Poedit 3.0.1\n"

#: ../../bpf.rst:3 56f5e8c29c934d4faec6e64be5e09553
msgid ""
"WARNING: You are looking at unreleased Cilium documentation. Please use the official rendered version released "
"here: https://docs.cilium.io"
msgstr "注意：你正在查看未经正式发布的 Cilium 文档。请阅读官方提供的正式版本：https://docs.cilium.io"

#: ../../bpf.rst:11 2342866ca3e64afda42c62118ca572ba
msgid "BPF and XDP Reference Guide"
msgstr "BPF 和 XDP 参考指南"

#: ../../bpf.rst:13 0338273ea9d34a749716aa9cef0ab63b
msgid ""
"This documentation section is targeted at developers and users who want to understand BPF and XDP in great "
"technical depth. While reading this reference guide may help broaden your understanding of Cilium, it is not a "
"requirement to use Cilium. Please refer to the :ref:`gs_guide` and :ref:`ebpf_datapath` for a higher level "
"introduction."
msgstr ""
"本文档部分面向希望深入了解 BPF 和 XDP 的开发人员和用户。 虽然阅读本参考指南可能有助于拓宽您对 Cilium 的理解，但使"
"用 Cilium并不需要阅读。 请参考 :ref:`gs_guide` 和 :ref:`ebpf_datapath` 以获得更深入的介绍。"

#: ../../bpf.rst:20 80582fcc6f6140d0a233c1583da7e20b
msgid ""
"BPF is a highly flexible and efficient virtual machine-like construct in the Linux kernel allowing to execute "
"bytecode at various hook points in a safe manner. It is used in a number of Linux kernel subsystems, most "
"prominently networking, tracing and security (e.g. sandboxing)."
msgstr ""
"BPF 是 Linux 内核中一种高度灵活和高效的类虚拟机结构，允许以安全的方式在各个挂钩点执行字节码。 它被用于许多 Linux "
"内核子系统，其中最突出的是与网络、跟踪和安全性（例如沙盒）相关的子系统。"

#: ../../bpf.rst:25 a2b7d422517d40bf8f489a00887f6fbc
msgid ""
"Although BPF exists since 1992, this document covers the extended Berkeley Packet Filter (eBPF) version which "
"has first appeared in Kernel 3.18 and renders the original version which is being referred to as \"classic\" BPF "
"(cBPF) these days mostly obsolete. cBPF is known to many as being the packet filter language used by tcpdump. "
"Nowadays, the Linux kernel runs eBPF only and loaded cBPF bytecode is transparently translated into an eBPF "
"representation in the kernel before program execution. This documentation will generally refer to the term BPF "
"unless explicit differences between eBPF and cBPF are being pointed out."
msgstr ""
"BPF 1992 年就出现了，但本文介绍的是扩展的 BPF（extended Berkeley Packet Filter，eBPF）。eBPF 最早出现在 3.18 内核"
"中，此后原来的 BPF 就被称为 “经典” BPF（classic BPF, cBPF），cBPF 现在基本已经废弃了。很多人知道 cBPF 是因为它是 "
"tcpdump 的包过滤语言。现在，Linux 内核只运行 eBPF，内核会将加载的 cBPF 字节码 透明地转换成 eBPF 再执行。如无特殊"
"说明，本文中所说的 BPF 都是泛指 BPF 技术。"

#: ../../bpf.rst:35 fde66f7755e64ce0ae5c44f6732d4237
msgid ""
"Even though the name Berkeley Packet Filter hints at a packet filtering specific purpose, the instruction set is "
"generic and flexible enough these days that there are many use cases for BPF apart from networking. See :ref:"
"`bpf_users` for a list of projects which use BPF."
msgstr ""
"虽然 Berkeley Packet Filter 的名称暗示了数据包过滤的特定目的，但指令集是通用且足够灵活的，因此除了关于过滤网络流"
"量之外，还有许多 BPF 用例。 有关使用 BPF 的项目列表，请参阅 bpf_users 。"

#: ../../bpf.rst:40 099129656d594caa9b6f34b5172af8b0
msgid ""
"Cilium uses BPF heavily in its data path, see :ref:`ebpf_datapath` for further information. The goal of this "
"chapter is to provide a BPF reference guide in order to gain understanding of BPF, its networking specific use "
"including loading BPF programs with tc (traffic control) and XDP (eXpress Data Path), and to aid with developing "
"Cilium's BPF templates."
msgstr ""
"Cilium 在其数据路径中大量使用 BPF，请参阅:ref:`ebpf_datapath` 了解更多信息。 本章的目的是提供一个 BPF 参考指南，"
"以便了解 BPF，它的网络特定用途包括使用 tc（流量控制）和 XDP（eXpress 数据路径）加载 BPF 程序，并帮助开发 Cilium "
"的 BPF 模板 ."

#: ../../bpf.rst:47 ed8f34b6acbc4e068e9fcf907239ca5f
msgid "BPF Architecture"
msgstr "BPF架构"

#: ../../bpf.rst:49 0cb5ca5a3a974c758adbc10d11cc970e
msgid ""
"BPF does not define itself by only providing its instruction set, but also by offering further infrastructure "
"around it such as maps which act as efficient key / value stores, helper functions to interact with and leverage "
"kernel functionality, tail calls for calling into other BPF programs, security hardening primitives, a pseudo "
"file system for pinning objects (maps, programs), and infrastructure for allowing BPF to be offloaded, for "
"example, to a network card."
msgstr ""
"BPF 不仅通过提供其指令集来定义自己，它还提供了围绕自身的一些基础设施如充当高效键/值存储的映射、与内核功能交互和利"
"用内核功能的辅助函数、用于调用其他 BPF 程序的尾调用 、安全加固原语、用于固定对象（地图、程序）的伪文件系统，它还"
"支持 BPF offload（例如 offload 到网卡）的基础设施。"

#: ../../bpf.rst:57 0dc128f1ea5149079218b7f16b64d933
msgid ""
"LLVM provides a BPF back end, so that tools like clang can be used to compile C into a BPF object file, which "
"can then be loaded into the kernel. BPF is deeply tied to the Linux kernel and allows for full programmability "
"without sacrificing native kernel performance."
msgstr ""
"LLVM 提供了一个 BPF 后端（back end），因此使用 clang 这样的工具就可以将 C 代 码编译成 BPF 对象文件（object "
"file），然后再加载到内核。BPF 深度绑定 Linux 内核，可以在 不牺牲原生内核性能的前提下实现（对内核的）完全可编程"
"（full programmability）。"

#: ../../bpf.rst:62 394288edce43442db5005445648e2b1a
msgid ""
"Last but not least, also the kernel subsystems making use of BPF are part of BPF's infrastructure. The two main "
"subsystems discussed throughout this document are tc and XDP where BPF programs can be attached to. XDP BPF "
"programs are attached at the earliest networking driver stage and trigger a run of the BPF program upon packet "
"reception. By definition, this achieves the best possible packet processing performance since packets cannot get "
"processed at an even earlier point in software. However, since this processing occurs so early in the networking "
"stack, the stack has not yet extracted metadata out of the packet. On the other hand, tc BPF programs are "
"executed later in the kernel stack, so they have access to more metadata and core kernel functionality. Apart "
"from tc and XDP programs, there are various other kernel subsystems as well which use BPF such as tracing "
"(kprobes, uprobes, tracepoints, etc)."
msgstr ""
"最后，使用 BPF 的内核子系统也是 BPF 设施的一部分。 本文档中讨论的两个主要子系统是 tc 和 XDP，BPF 程序可以附加"
"（attach）到这些子系统上。 XDP BPF 程序在最早的网络驱动阶段被加载，并在数据包接收时触发 BPF 程序的运行。 这实现了"
"可能的最佳数据包处理性能，因为数据包无法在软件中更早的时间点得到处理。 但是由于此处理在网络堆栈中发生得如此早，因"
"此协议栈尚未从数据包中提取元数据。 另一方面，tc BPF 程序在内核堆栈中稍后执行，因此它们可以访问更多元数据和核心内"
"核功能。 除了 tc 和 XDP 程序之外，还有其他各种使用 BPF 的内核子系统，例如跟踪（kprobes、uprobes、tracepoints "
"等）。"

#: ../../bpf.rst:75 6bba66a219b24d2cb4e9a5da7a5b27d7
msgid "The following subsections provide further details on individual aspects of the BPF architecture."
msgstr "以下小节提供了有关 BPF 架构等各个方面的更多详细介绍。"

#: ../../bpf.rst:79 c6204a35fddd446da0d4e3d39a52805a
msgid "Instruction Set"
msgstr "指令系统"

#: ../../bpf.rst:81 52e5394f19f74f9c80feeb0466021c33
msgid ""
"BPF is a general purpose RISC instruction set and was originally designed for the purpose of writing programs in "
"a subset of C which can be compiled into BPF instructions through a compiler back end (e.g. LLVM), so that the "
"kernel can later on map them through an in-kernel JIT compiler into native opcodes for optimal execution "
"performance inside the kernel."
msgstr ""
"BPF 是一个通用的 RISC 指令集，最初的设计目的是用 C 的子集编写程序，而这些程序可以通过编译器（例如 LLVM）编译成 "
"BPF 指令，以便内核稍后可以在内核中的 JIT 编译器将BPF指令映射到本机操作码中，以实现内核内的最佳执行性能。"

#: ../../bpf.rst:87 bfa19f6c3e7f4e2ca7d7cf604b925aaa
msgid "The advantages for pushing these instructions into the kernel include:"
msgstr "将这些指令推送到内核的优点包括："

#: ../../bpf.rst:89 6b74023ff286474494b31dae63a21c7b
msgid ""
"Making the kernel programmable without having to cross kernel / user space boundaries. For example, BPF programs "
"related to networking, as in the case of Cilium, can implement flexible container policies, load balancing and "
"other means without having to move packets to user space and back into the kernel. State between BPF programs "
"and kernel / user space can still be shared through maps whenever needed."
msgstr ""
"使内核可编程，而无需跨越内核/用户空间边界。 例如，如 Cilium 这样的与网络相关的 BPF 程序，可以实现灵活的容器策略、"
"负载平衡和其他手段，而无需将数据包移动到用户空间处理后在还给内核。 BPF 程序和内核/用户太之间的状态仍然可以在需要"
"时通过映射共享指令。"

#: ../../bpf.rst:96 54118c63b69f4a728ea14774419f6c0b
msgid ""
"Given the flexibility of a programmable data path, programs can be heavily optimized for performance also by "
"compiling out features that are not required for the use cases the program solves. For example, if a container "
"does not require IPv4, then the BPF program can be built to only deal with IPv6 in order to save resources in "
"the fast-path."
msgstr ""
"鉴于可编程datapath的灵活性，还可以通过编译程序将不需要的功能在编译阶段禁用来对程序进行性能优化。 例如，如果容器不"
"需要 IPv4，则可以构建 BPF 程序从而仅处理 IPv6，以节省快速datapath中的资源消耗。"

#: ../../bpf.rst:101 292b451f5651450591eaabbb255923ad
msgid ""
"In case of networking (e.g. tc and XDP), BPF programs can be updated atomically without having to restart the "
"kernel, system services or containers, and without traffic interruptions. Furthermore, any program state can "
"also be maintained throughout updates via BPF maps."
msgstr ""
"在网络处理的应用场景中（例如 tc 和 XDP），BPF 程序可以自动更新，而无需重新启动内核、系统服务或容器，也不会中断流"
"量。 此外，还可以通过 BPF 映射在整个更新过程中维护任何程序状态。"

#: ../../bpf.rst:106 1cafa95aab8d4a049543118c446b2b0a
msgid ""
"BPF provides a stable ABI towards user space, and does not require any third party kernel modules. BPF is a core "
"part of the Linux kernel that is shipped everywhere, and guarantees that existing BPF programs keep running with "
"newer kernel versions. This guarantee is the same guarantee that the kernel provides for system calls with "
"regard to user space applications. Moreover, BPF programs are portable across different architectures."
msgstr ""
"BPF 为用户空间提供了稳定的 ABI，并且不需要任何第三方内核模块。 BPF 是随处可见的 Linux 内核的核心部分，它保证现有"
"的 BPF 程序在更新的内核版本上继续运行。 这种保证与内核提供给用户态应用的接口的系统调用是同一级别的。 此外，BPF 程"
"序可以跨不同的架构移植。"

#: ../../bpf.rst:113 d23b9fe27e094e5f9b97478a2f4868ed
msgid ""
"BPF programs work in concert with the kernel, they make use of existing kernel infrastructure (e.g. drivers, "
"netdevices, tunnels, protocol stack, sockets) and tooling (e.g. iproute2) as well as the safety guarantees which "
"the kernel provides. Unlike kernel modules, BPF programs are verified through an in-kernel verifier in order to "
"ensure that they cannot crash the kernel, always terminate, etc. XDP programs, for example, reuse the existing "
"in-kernel drivers and operate on the provided DMA buffers containing the packet frames without exposing them or "
"an entire driver to user space as in other models. Moreover, XDP programs reuse the existing stack instead of "
"bypassing it. BPF can be considered a generic \"glue code\" to kernel facilities for crafting programs to solve "
"specific use cases."
msgstr ""
"BPF 程序与内核协同工作，并且它们能有效利用现有的内核基础设施（例如驱动程序、网络设备、隧道、协议栈、套接字）和工"
"具（例如 iproute2）以及内核提供的安全保证。 与内核模块不同，BPF 程序通过内核验证器进行验证，以确保它们不会使内核"
"崩溃、始终终止等。例如XDP 程序可以重用现有的内核驱动程序并在提供的 DMA 缓冲区上运行数据包帧，而不像在其他模型中那"
"样将它们或整个驱动程序暴露给用户空间。 此外XDP 程序重用现有堆栈而不是绕过它，因此 BPF 可以被认为是内核设施的通"
"用“胶水代码”，用于制作程序以解决特定用例。"

#: ../../bpf.rst:124 239ce40633594604a0a7bf5a36159311
msgid "The execution of a BPF program inside the kernel is always event-driven! Examples:"
msgstr "内核中 BPF 程序的执行始终是事件驱动的！ 例如："

#: ../../bpf.rst:126 9eb7a2f8e9c142cfb93670486fb8acb8
msgid ""
"A networking device which has a BPF program attached on its ingress path will trigger the execution of the "
"program once a packet is received."
msgstr "网络设备一旦接收到数据包，就会触发在其入口（ingress）路径上attach的 BPF 程序的执行。"

#: ../../bpf.rst:129 88e1b9add1f44769b229fab771a42a92
msgid ""
"A kernel address which has a kprobe with a BPF program attached will trap once the code at that address gets "
"executed, which will then invoke the kprobe's callback function for instrumentation, subsequently triggering the "
"execution of the attached BPF program."
msgstr ""
"在某个有 kprobe 探测点的内核地址 attach 一段 BPF 程序后，当内核执行到这个地址时会发生陷入（trap），进而唤醒 "
"kprobe 的回调函数，后者又会触发 attach 的 BPF 程序的执行。"

#: ../../bpf.rst:134 eee5900928a146cba29e9af53e92e965
msgid ""
"BPF consists of eleven 64 bit registers with 32 bit subregisters, a program counter and a 512 byte large BPF "
"stack space. Registers are named ``r0`` - ``r10``. The operating mode is 64 bit by default, the 32 bit "
"subregisters can only be accessed through special ALU (arithmetic logic unit) operations. The 32 bit lower "
"subregisters zero-extend into 64 bit when they are being written to."
msgstr ""
"BPF 由 11 个 64 位寄存器（这些寄存器包含 32 位子寄存器）、一个程序计数器和一个 512 字节的 BPF 堆栈空间组成。 寄存"
"器被命名为“r0”-“r10”。 操作模式默认为 64 位，32 位子寄存器只能通过特殊的 ALU（算术逻辑单元）操作访问。 低 32 位子"
"寄存器在被写入时零填充到 64 位。"

#: ../../bpf.rst:140 587f33e284084b99bd03a9ac81a7ddd1
msgid ""
"Register ``r10`` is the only register which is read-only and contains the frame pointer address in order to "
"access the BPF stack space. The remaining ``r0`` - ``r9`` registers are general purpose and of read/write nature."
msgstr ""
"寄存器``r10``是唯一一个只读寄存器，它包含帧指针地址，以便访问 BPF 堆栈空间。 其余的 ``r0`` - ``r9`` 寄存器是通用"
"的，具有读/写性质。"

#: ../../bpf.rst:144 de188d9511a3401babcd9c556e914d4d
msgid ""
"A BPF program can call into a predefined helper function, which is defined by the core kernel (never by "
"modules). The BPF calling convention is defined as follows:"
msgstr "BPF 程序可以调用预定义的辅助函数，该函数由核心内核定义（而不由模块定义）。 BPF 调用约定定义如下："

#: ../../bpf.rst:148 5f741fb374c74257b489eee9c536c00a
msgid "``r0`` contains the return value of a helper function call."
msgstr "``r0`` 包含辅助函数调用的返回值。"

#: ../../bpf.rst:149 9fddbc7b16af4431800f752f3e9e1afe
msgid "``r1`` - ``r5`` hold arguments from the BPF program to the kernel helper function."
msgstr "``r1`` - ``r5`` 保存从 BPF 程序到内核辅助函数的参数。"

#: ../../bpf.rst:150 9df2f18c17c848498741513337fde0c5
msgid "``r6`` - ``r9`` are callee saved registers that will be preserved on helper function call."
msgstr "``r6`` - ``r9`` 是被调用者保存的寄存器，将在辅助函数调用时保留。"

#: ../../bpf.rst:152 16e49a10f185415381ea3689656f1c59
msgid ""
"The BPF calling convention is generic enough to map directly to ``x86_64``, ``arm64`` and other ABIs, thus all "
"BPF registers map one to one to HW CPU registers, so that a JIT only needs to issue a call instruction, but no "
"additional extra moves for placing function arguments. This calling convention was modeled to cover common call "
"situations without having a performance penalty. Calls with 6 or more arguments are currently not supported. The "
"helper functions in the kernel which are dedicated to BPF (``BPF_CALL_0()`` to ``BPF_CALL_5()`` functions) are "
"specifically designed with this convention in mind."
msgstr ""
"BPF 调用约定足够通用，可以直接映射到 ``x86_64``、``arm64`` 和其他 ABIs，因此所有 BPF 寄存器都一对一映射到 HW CPU "
"寄存器，JIT 只需要发出调用指令 ，而无需额外的调用动作去处理函数参数。 这种调用约定可以涵盖常见的调用情况而不会降"
"低性能。 当前不支持具有 6 个或以上参数的调用。 内核中专用于 BPF 的辅助函数（``BPF_CALL_0()`` 到 ``BPF_CALL_5()`` "
"函数）是专门根据这种约定设计的。"

#: ../../bpf.rst:161 ae578bc9a68f42e6bf3dcc8a2e15f857
msgid ""
"Register ``r0`` is also the register containing the exit value for the BPF program. The semantics of the exit "
"value are defined by the type of program. Furthermore, when handing execution back to the kernel, the exit value "
"is passed as a 32 bit value."
msgstr ""
"寄存器``r0``也是包含 BPF 程序退出值的寄存器， 退出值的语义由程序类型定义。 此外，当将执行交还给内核时，退出值是"
"以 32 位值传递。"

#: ../../bpf.rst:165 7071fd32996d4efe84de2dd50b65e1c2
msgid ""
"Registers ``r1`` - ``r5`` are scratch registers, meaning the BPF program needs to either spill them to the BPF "
"stack or move them to callee saved registers if these arguments are to be reused across multiple helper function "
"calls. Spilling means that the variable in the register is moved to the BPF stack. The reverse operation of "
"moving the variable from the BPF stack to the register is called filling. The reason for spilling/filling is due "
"to the limited number of registers."
msgstr ""
"寄存器 ``r1`` - ``r5`` 是临时寄存器，这意味着如果要在多个辅助函数调用中重用这些参数，BPF 程序需要将它们转储"
"（spill）到 BPF 栈或将它们移动到被调用者保存的寄存器中。 转储意味着寄存器中的变量被移动到 BPF 堆栈中。 将变量从 "
"BPF 堆栈移动到寄存器的反向操作称为填充（filling）。 转储/填充的原因是由于寄存器数量有限。"

#: ../../bpf.rst:172 990661ea72bc44f1a8f8fd55b39a7ebd
msgid ""
"Upon entering execution of a BPF program, register ``r1`` initially contains the context for the program. The "
"context is the input argument for the program (similar to ``argc/argv`` pair for a typical C program). BPF is "
"restricted to work on a single context. The context is defined by the program type, for example, a networking "
"program can have a kernel representation of the network packet (``skb``) as the input argument."
msgstr ""
"在进入 BPF 程序的执行时，寄存器 r1 最初包含程序的上下文。 上下文是程序的输入参数（类似于典型 C 程序的``argc/"
"argv``对）。 BPF 仅限于在单个上下文中工作。 上下文由程序类型定义，例如网络程序可以将网络数据包的内核表示"
"（``skb``）作为输入参数。"

#: ../../bpf.rst:179 12e04df72475482d879d48a8d427ab32
msgid ""
"The general operation of BPF is 64 bit to follow the natural model of 64 bit architectures in order to perform "
"pointer arithmetics, pass pointers but also pass 64 bit values into helper functions, and to allow for 64 bit "
"atomic operations."
msgstr ""
"BPF 的一般操作是 64 位，以遵循 64 位架构的原有模型，从而便于执行指针算术、传递指针以及将 64 位值传递给辅助函数，"
"并允许 64 位的原子操作。"

#: ../../bpf.rst:183 76573c10a2d34759af7151ba96c331d7
msgid ""
"The maximum instruction limit per program is restricted to 4096 BPF instructions, which, by design, means that "
"any program will terminate quickly. For kernel newer than 5.1 this limit was lifted to 1 million BPF "
"instructions. Although the instruction set contains forward as well as backward jumps, the in-kernel BPF "
"verifier will forbid loops so that termination is always guaranteed. Since BPF programs run inside the kernel, "
"the verifier's job is to make sure that these are safe to run, not affecting the system's stability. This means "
"that from an instruction set point of view, loops can be implemented, but the verifier will restrict that. "
"However, there is also a concept of tail calls that allows for one BPF program to jump into another one. This, "
"too, comes with an upper nesting limit of 33 calls, and is usually used to decouple parts of the program logic, "
"for example, into stages."
msgstr ""
"根据设计，每个程序的最大指令限制为 4096 条 BPF 指令，这意味着任何程序都将快速终止。 对于 5.1 之后的内核，这个限制"
"被提升到 100 万条 BPF 指令。 尽管指令集包含前向和后向跳转，但内核 BPF 验证器禁止存在循环，以便始终保证终止。 由"
"于 BPF 程序在内核中运行，验证器的工作是确保这些程序可以安全运行，而不影响系统的稳定性。 这意味着从指令集的角度来"
"看，尽管代码本身可以实现循环，但验证器会限制它。 但是还有一个尾调用的概念，它允许一个 BPF 程序跳转到另一个 BPF 程"
"序。 这也具有 33 个调用的嵌套上限，通常用于将程序逻辑的部分解耦，例如，分解为不同处理阶段。"

#: ../../bpf.rst:195 aa5fce862d5942d0b214fe45609c4db7
msgid ""
"The instruction format is modeled as two operand instructions, which helps mapping BPF instructions to native "
"instructions during JIT phase. The instruction set is of fixed size, meaning every instruction has 64 bit "
"encoding. Currently, 87 instructions have been implemented and the encoding also allows to extend the set with "
"further instructions when needed. The instruction encoding of a single 64 bit instruction on a big-endian "
"machine is defined as a bit sequence from most significant bit (MSB) to least significant bit (LSB) of ``op:8``, "
"``dst_reg:4``, ``src_reg:4``, ``off:16``, ``imm:32``. ``off`` and ``imm`` is of signed type. The encodings are "
"part of the kernel headers and defined in ``linux/bpf.h`` header, which also includes ``linux/bpf_common.h``."
msgstr ""
"指令格式被建模为两个操作数指令，这有助于在 JIT 阶段将 BPF 指令映射到本机指令。 指令集是固定大小的，这意味着每条指"
"令都有 64 位编码。 目前已经实现了 87 条指令，并且编码还允许在需要时使用更多指令来进一步扩展。 大端机器上单个 64 "
"位指令的指令编码按最高有效位 (MSB) 到最低有效位 (LSB) 的排序为``op:8``，``dst_reg:4``，``src_reg:4``、"
"``off:16``、``imm:32``，其中 ``off`` 和 ``imm`` 是有符号类型。 编码是内核头文件的一部分，并在 ``linux/bpf.h`` 头"
"文件中定义，该头文件还包括 ``linux/bpf_common.h`` 。"

#: ../../bpf.rst:205 e11e3807f19d4b26a10a32fce484cd16
msgid ""
"``op`` defines the actual operation to be performed. Most of the encoding for ``op`` has been reused from cBPF. "
"The operation can be based on register or immediate operands. The encoding of ``op`` itself provides information "
"on which mode to use (``BPF_X`` for denoting register-based operations, and ``BPF_K`` for immediate-based "
"operations respectively). In the latter case, the destination operand is always a register. Both ``dst_reg`` and "
"``src_reg`` provide additional information about the register operands to be used (e.g. ``r0`` - ``r9``) for the "
"operation. ``off`` is used in some instructions to provide a relative offset, for example, for addressing the "
"stack or other buffers available to BPF (e.g. map values, packet data, etc), or jump targets in jump "
"instructions. ``imm`` contains a constant / immediate value."
msgstr ""
"``op`` 定义要执行的实际操作。 ``op`` 的大部分编码已经从 cBPF 中重用了。 该操作可以基于寄存器或立即操作数。 "
"``op`` 的编码本身提供了有关使用哪种模式的信息（``BPF_X`` 表示基于寄存器的操作，``BPF_K`` 分别表示基于立即数的操"
"作）。 在后一种情况下，目标操作数始终是寄存器。 ``dst_reg`` 和 ``src_reg`` 都提供了关于要用于操作的寄存器操作数的"
"附加信息（例如 ``r0`` - ``r9``）。 ``off`` 在某些指令中用于提供相对偏移量，例如，用于寻址 BPF 可用的堆栈或其他缓"
"冲区（例如映射值、数据包数据等），或跳转指令中的跳转目标。 ``imm`` 包含一个常量/立即值。"

#: ../../bpf.rst:216 03a633d261b7450ead74fd838e5d1451
msgid ""
"The available ``op`` instructions can be categorized into various instruction classes. These classes are also "
"encoded inside the ``op`` field. The ``op`` field is divided into (from MSB to LSB) ``code:4``, ``source:1`` and "
"``class:3``. ``class`` is the more generic instruction class, ``code`` denotes a specific operational code "
"inside that class, and ``source`` tells whether the source operand is a register or an immediate value. Possible "
"instruction classes include:"
msgstr ""
"可用的``op``指令可以分为各种指令类。 这些类也被编码在 ``op`` 字段中。 ``op``字段分为（从 MSB 到 LSB）``code:4``、"
"``source:1``和``class:3``。 ``class`` 是更通用的指令类，``code`` 表示该类中的特定操作代码，而``source`` 告诉源操"
"作数是寄存器还是立即值。 可能的教学课程包括："

#: ../../bpf.rst:223 16403cea36604b80b2b7737a6bb3db3b
msgid ""
"``BPF_LD``, ``BPF_LDX``: Both classes are for load operations. ``BPF_LD`` is used for loading a double word as a "
"special instruction spanning two instructions due to the ``imm:32`` split, and for byte / half-word / word loads "
"of packet data. The latter was carried over from cBPF mainly in order to keep cBPF to BPF translations "
"efficient, since they have optimized JIT code. For native BPF these packet load instructions are less relevant "
"nowadays. ``BPF_LDX`` class holds instructions for byte / half-word / word / double-word loads out of memory. "
"Memory in this context is generic and could be stack memory, map value data, packet data, etc."
msgstr ""
"``BPF_LD``, ``BPF_LDX``: 这两个类都用于加载操作。 由于 ``imm:32`` 拆分，``BPF_LD`` 用于加载双字作为跨越两条指令的"
"特殊指令，以及用于数据包数据的字节/半字/字加载。 后者是从 cBPF 继承而来的，主要是为了保持 cBPF 到 BPF 的转换效"
"率，因为它们都是优化过后的 JIT 代码。 对于本地 BPF，这些数据包加载指令如今已不太相关。 ``BPF_LDX`` 类用于从内存中"
"加载字节/半字/字/双字的指令。 这里的内存可以包括栈内存，映射值数据，数据包数据等。"

#: ../../bpf.rst:233 b5918037cd1742adac2b71fd1ed65aa5
msgid ""
"``BPF_ST``, ``BPF_STX``: Both classes are for store operations. Similar to ``BPF_LDX`` the ``BPF_STX`` is the "
"store counterpart and is used to store the data from a register into memory, which, again, can be stack memory, "
"map value, packet data, etc. ``BPF_STX`` also holds special instructions for performing word and double-word "
"based atomic add operations, which can be used for counters, for example. The ``BPF_ST`` class is similar to "
"``BPF_STX`` by providing instructions for storing data into memory only that the source operand is an immediate "
"value."
msgstr ""
"``BPF_ST``, ``BPF_STX``：这两个类都用于存储操作，用于将数据从寄存器存储到内存中。 与 ``BPF_LDX`` 类似，"
"``BPF_STX`` 所指的存储对应物，同样可以是堆栈内存、映射值、数据包数据等。``BPF_STX `` 还包含用于执行基于字和双字的"
"原子加法操作的特殊指令，例如可用于计数器。 ``BPF_ST`` 类与``BPF_STX`` 类似，它提供了将数据存储到内存中的指令，不"
"过源操作数必须是立即值。"

#: ../../bpf.rst:241 ae8878e89ae94beba3fa39204bbe0466
msgid ""
"``BPF_ALU``, ``BPF_ALU64``: Both classes contain ALU operations. Generally, ``BPF_ALU`` operations are in 32 bit "
"mode and ``BPF_ALU64`` in 64 bit mode. Both ALU classes have basic operations with source operand which is "
"register-based and an immediate-based counterpart. Supported by both are add (``+``), sub (``-``), and (``&``), "
"or (``|``), left shift (``<<``), right shift (``>>``), xor (``^``), mul (``*``), div (``/``), mod (``%``), neg "
"(``~``) operations. Also mov (``<X> := <Y>``) was added as a special ALU operation for both classes in both "
"operand modes. ``BPF_ALU64`` also contains a signed right shift. ``BPF_ALU`` additionally contains endianness "
"conversion instructions for half-word / word / double-word on a given source register."
msgstr ""
"``BPF_ALU``, ``BPF_ALU64``：这两个类都包含 ALU 操作。 通常``BPF_ALU`` 操作在 32 位模式下，而``BPF_ALU64`` 在 64 "
"位模式下。 两个 ALU 类都具有基于寄存器和基于立即数的对应源操作数的基本操作。 两者都支持添加（``+``），sub（``-"
"``）和（``&``），或（``|``），左移（``<<``） , 右移 (``>>``), xor (``^``), mul (``*``), div (``/``), mod (``"
"%``), neg ( ``~``）操作。 此外 mov (``<X> := <Y>``) 被添加为两个操作数模式下两个类的特殊 ALU 操作。 "
"``BPF_ALU64`` 也包含一个有符号的右移。 ``BPF_ALU`` 还包含给定源寄存器上半字/字/双字的字节顺序转换指令。"

#: ../../bpf.rst:252 002411a6f23d478093b168079c617ecb
msgid ""
"``BPF_JMP``: This class is dedicated to jump operations. Jumps can be unconditional and conditional. "
"Unconditional jumps simply move the program counter forward, so that the next instruction to be executed "
"relative to the current instruction is ``off + 1``, where ``off`` is the constant offset encoded in the "
"instruction. Since ``off`` is signed, the jump can also be performed backwards as long as it does not create a "
"loop and is within program bounds. Conditional jumps operate on both, register-based and immediate-based source "
"operands. If the condition in the jump operations results in ``true``, then a relative jump to ``off + 1`` is "
"performed, otherwise the next instruction (``0 + 1``) is performed. This fall-through jump logic differs "
"compared to cBPF and allows for better branch prediction as it fits the CPU branch predictor logic more "
"naturally. Available conditions are jeq (``==``), jne (``!=``), jgt (``>``), jge (``>=``), jsgt (signed ``>``), "
"jsge (signed ``>=``), jlt (``<``), jle (``<=``), jslt (signed ``<``), jsle (signed ``<=``) and jset (jump if "
"``DST & SRC``). Apart from that, there are three special jump operations within this class: the exit instruction "
"which will leave the BPF program and return the current value in ``r0`` as a return code, the call instruction, "
"which will issue a function call into one of the available BPF helper functions, and a hidden tail call "
"instruction, which will jump into a different BPF program."
msgstr ""
"``BPF_JMP``：这个类专门用于跳转操作。跳转可以是无条件的和有条件的。无条件跳转只是将程序计数器向前移动，因此相对于"
"当前指令要执行的下一条指令是``off + 1``，其中``off``是指令中编码的常量偏移量。由于``off``是有符号的，只要不创建循"
"环并且在程序范围内，当然也可以进行向后执行跳转。条件跳转既可以基于寄存器也可以基于立即数的源操作数执行。如果跳转"
"操作中的条件为``true``，则执行相对跳转到``off + 1``，否则执行下一条指令（``0 + 1``）。与 cBPF 相比，这种直通跳转"
"逻辑有所不同，由于它更适合 CPU 分支预测器逻辑因此有更好的分支预测能力。可用条件有 jeq (``==``), jne (``!=``), "
"jgt (``>``), jge (``>=``), jsgt (signed ``>`` ），jsge（签名``>=``），jlt（``<``），jle（``<=``），jslt（签名"
"``<``），jsle（签名``<=` `) 和 jset（如果是 ``DST & SRC`` 则跳转）。除此之外，该类中还有三个特殊的跳转操作：exit "
"指令将离开 BPF 程序并将 r0 中的当前值作为返回码返回，call 指令将发出函数调用一个可用的 BPF 辅助函数和一个隐藏的尾"
"调用指令，它将跳转到不同的 BPF 程序。"

#: ../../bpf.rst:272 58a0bdd61978485b889740d5ebdfbdf3
msgid ""
"The Linux kernel is shipped with a BPF interpreter which executes programs assembled in BPF instructions. Even "
"cBPF programs are translated into eBPF programs transparently in the kernel, except for architectures that still "
"ship with a cBPF JIT and have not yet migrated to an eBPF JIT."
msgstr ""
"Linux 内核附带一个 BPF 解释器，它执行以 BPF 指令汇编的程序。 甚至 cBPF 程序在内核中也被透明地转换为 eBPF 程序，除"
"非该架构仍然内置了 cBPF JIT，还没有迁移到 eBPF JIT。"

#: ../../bpf.rst:277 7911275dd29f4911b86439bf9a62d0cd
msgid ""
"Currently ``x86_64``, ``arm64``, ``ppc64``, ``s390x``, ``mips64``, ``sparc64`` and ``arm`` architectures come "
"with an in-kernel eBPF JIT compiler."
msgstr ""
"目前，``x86_64``，``arm64``，``ppc64``，``s390x``，``mips64``，``sparc64``和``arm``架构带有内核内eBPF JIT 编译"
"器。"

#: ../../bpf.rst:280 c42d4580b5804876b3e1da91f8ac82b8
msgid ""
"All BPF handling such as loading of programs into the kernel or creation of BPF maps is managed through a "
"central ``bpf()`` system call. It is also used for managing map entries (lookup / update / delete), and making "
"programs as well as maps persistent in the BPF file system through pinning."
msgstr ""
"所有 BPF 处理，例如将程序加载到内核或创建 BPF 映射，都是通过一个核心 ``bpf()`` 系统调用来管理的。 它还用于管理映"
"射条目（查找/更新/删除），并通过固定使程序和映射在 BPF 文件系统中持久化。"

#: ../../bpf.rst:286 289e670df5c94959804365b0026aa065
msgid "Helper Functions"
msgstr "辅助函数"

#: ../../bpf.rst:288 2a76a0fb8da04194afd0af184475b4d5
msgid ""
"Helper functions are a concept which enables BPF programs to consult a core kernel defined set of function calls "
"in order to retrieve / push data from / to the kernel. Available helper functions may differ for each BPF "
"program type, for example, BPF programs attached to sockets are only allowed to call into a subset of helpers "
"compared to BPF programs attached to the tc layer. Encapsulation and decapsulation helpers for lightweight "
"tunneling constitute an example of functions which are only available to lower tc layers, whereas event output "
"helpers for pushing notifications to user space are available to tc and XDP programs."
msgstr ""
"辅助函数（Helper functions）是一个概念，是指 BPF 能够通过一组内核定义的函数调用（function call）来从内核中查询数"
"据，或者将数据推送到内核。 每个 BPF 程序类型的可用辅助函数可能不同，例如与附加（attach）到 tc 层的 BPF 程序相比，"
"附加到套接字的 BPF 程序只允许调用辅助函数的子集。又例如用于轻量级隧道的封装和解封装的辅助函数构成了仅可被更加底层"
"的 tc 调用，而用于将通知推送到用户空间的事件输出的辅助函数即可用于 tc 也可被 XDP 程序使用。"

#: ../../bpf.rst:298 fd48f1bd4ab04e5aa7bd9772c85c8187
msgid ""
"Each helper function is implemented with a commonly shared function signature similar to system calls. The "
"signature is defined as:"
msgstr "每个辅助函数都使用类似于系统调用的通用共享函数签名来实现。 这类签名定义为："

#: ../../bpf.rst:305 542d45a115b84a71ab46abbbc4b4281d
msgid "The calling convention as described in the previous section applies to all BPF helper functions."
msgstr "上一节中描述的调用约定适用于所有 BPF 辅助函数。"

#: ../../bpf.rst:308 c90a7bf66c3c4961ba5aa244d44bf7be
msgid ""
"The kernel abstracts helper functions into macros ``BPF_CALL_0()`` to ``BPF_CALL_5()`` which are similar to "
"those of system calls. The following example is an extract from a helper function which updates map elements by "
"calling into the corresponding map implementation callbacks:"
msgstr ""
"内核将辅助函数抽象为类似于系统调用的宏``BPF_CALL_0()``到``BPF_CALL_5()``。 以下示例是从帮助函数中提取的，该函数通"
"过调用相应的地图实现回调来更新地图元素："

#: ../../bpf.rst:332 a04dca285baa44f1bdc12c333d9867c8
msgid ""
"There are various advantages of this approach: while cBPF overloaded its load instructions in order to fetch "
"data at an impossible packet offset to invoke auxiliary helper functions, each cBPF JIT needed to implement "
"support for such a cBPF extension. In case of eBPF, each newly added helper function will be JIT compiled in a "
"transparent and efficient way, meaning that the JIT compiler only needs to emit a call instruction since the "
"register mapping is made in such a way that BPF register assignments already match the underlying architecture's "
"calling convention. This allows for easily extending the core kernel with new helper functionality. All BPF "
"helper functions are part of the core kernel and cannot be extended or added through kernel modules."
msgstr ""
"这种方法有很多优点：虽然 cBPF 允许其加载指令（load instructions）对超出范围的地址进行访问（overload），以便在不可"
"能的数据包偏移量获取数据以调用辅助函数，但每个 cBPF JIT 都需要实现对这种 cBPF 扩展的支持。 在 eBPF 的情况下，每个"
"新添加的辅助函数都将以透明和高效的方式进行 JIT 编译，这意味着 JIT 编译器只需要发出调用指令，因为寄存器映射的方式"
"使得 BPF 排列参数的方式（assignments）已经和底层架构的调用约定相匹配了。 这允许新的辅助功能轻松扩展核心内核。 所"
"有 BPF 辅助函数都是核心内核的一部分，不能通过内核模块扩展或添加。"

#: ../../bpf.rst:343 9de6971fd7a046e28c54842c714b631f
msgid ""
"The aforementioned function signature also allows the verifier to perform type checks. The above ``struct "
"bpf_func_proto`` is used to hand all the necessary information which need to be known about the helper to the "
"verifier, so that the verifier can make sure that the expected types from the helper match the current contents "
"of the BPF program's analyzed registers."
msgstr ""
"上述函数签名还允许验证者执行类型检查。 上面的 ``struct bpf_func_proto`` 用于将所有需要知道的关于 helper 的必要信"
"息交给验证者，以便验证者可以通过分析寄存器来确保来自 helper 的预期类型与 BPF 程序的当前内容相匹配。"

#: ../../bpf.rst:349 86c1d3203fa34b6db0c6f73859b9f1bd
msgid ""
"Argument types can range from passing in any kind of value up to restricted contents such as a pointer / size "
"pair for the BPF stack buffer, which the helper should read from or write to. In the latter case, the verifier "
"can also perform additional checks, for example, whether the buffer was previously initialized."
msgstr ""
"参数类型范围很广，从任意类型的值到特定类型的任意值。例如辅助函数可以从中读取或写入 BPF 堆栈缓冲区的指针/大小对。 "
"同时校验器还可以执行额外的检查，例如缓冲区之前是否已初始化。"

#: ../../bpf.rst:355 f03cbb5753f04a109bc7678d13a9b8b9
msgid ""
"The list of available BPF helper functions is rather long and constantly growing, for example, at the time of "
"this writing, tc BPF programs can choose from 38 different BPF helpers. The kernel's ``struct bpf_verifier_ops`` "
"contains a ``get_func_proto`` callback function that provides the mapping of a specific ``enum bpf_func_id`` to "
"one of the available helpers for a given BPF program type."
msgstr ""
"可用的 BPF 助手函数列表相当长并且不断增长，例如在撰写本文时，tc BPF 程序可以从 38 个不同的 BPF 辅助函数中进行选"
"择。 内核的``struct bpf_verifier_ops`` 包含一个``get_func_proto`` 回调函数，它提供特定``enum bpf_func_id`` 到给定"
"BPF 程序类型的一个可用辅助函数的映射。"

#: ../../bpf.rst:363 59fdc7dba2494ecb93141971e168186f
msgid "Maps"
msgstr "映射（Maps）"

#: ../../bpf.rst:368 ed2f9d97f41a4538ab7b4407b61aa6f1
msgid ""
"Maps are efficient key / value stores that reside in kernel space. They can be accessed from a BPF program in "
"order to keep state among multiple BPF program invocations. They can also be accessed through file descriptors "
"from user space and can be arbitrarily shared with other BPF programs or user space applications."
msgstr ""
"映射（map）是驻留在内核空间中的高效键/值存储结构。 可以从 BPF 程序访问它们，以便在多个 BPF 程序调用之间保持状态同"
"步。 它们也可以通过文件描述符从用户空间访问，并且可以与其他 BPF 程序或用户空间应用程序任意共享。"

#: ../../bpf.rst:373 6cdad62da07d4c8eb1bffbe6b360cb7b
msgid ""
"BPF programs which share maps with each other are not required to be of the same program type, for example, "
"tracing programs can share maps with networking programs. A single BPF program can currently access up to 64 "
"different maps directly."
msgstr ""
"相互共享映射的 BPF 程序不需要是相同的程序类型，例如跟踪程序可以与网络程序共享映射。 单个 BPF 程序目前可以直接访问"
"多达 64 个不同的映射。"

#: ../../bpf.rst:377 64923d84ed3e44fd80de44ccb2df1723
msgid ""
"Map implementations are provided by the core kernel. There are generic maps with per-CPU and non-per-CPU flavor "
"that can read / write arbitrary data, but there are also a few non-generic maps that are used along with helper "
"functions."
msgstr ""
"映射是通过核心内核的能力实现的。 有具有 per-CPU 和 non-per-CPU 风格的通用映射可以读取/写入任意数据，也有可以与一"
"些与辅助函数一起使用的非通用映射。"

#: ../../bpf.rst:381 3596916ced0d4d5fab1647a99922ede1
msgid ""
"Generic maps currently available are ``BPF_MAP_TYPE_HASH``, ``BPF_MAP_TYPE_ARRAY``, "
"``BPF_MAP_TYPE_PERCPU_HASH``, ``BPF_MAP_TYPE_PERCPU_ARRAY``, ``BPF_MAP_TYPE_LRU_HASH``, "
"``BPF_MAP_TYPE_LRU_PERCPU_HASH`` and ``BPF_MAP_TYPE_LPM_TRIE``. They all use the same common set of BPF helper "
"functions in order to perform lookup, update or delete operations while implementing a different backend with "
"differing semantics and performance characteristics."
msgstr ""
"当前可用的通用映射是``BPF_MAP_TYPE_HASH``，``BPF_MAP_TYPE_ARRAY``，``BPF_MAP_TYPE_PERCPU_HASH``，"
"``BPF_MAP_TYPE_PERCPU_ARRAY``，``BPF_MAP_TYPE_LRU_HASH``，``BPF_MAP_TYPE_LRU_PERCPU_HASH``和"
"``BPF_MAP_TYPE_LPM_TRIE``。 它们都使用相同的通用 BPF 辅助函数集来执行查找、更新或删除操作，同时实现具有不同语义和"
"性能特征的不同后端。"

#: ../../bpf.rst:388 42b5e2739ea247449b77965ceea3a0b6
msgid ""
"Non-generic maps that are currently in the kernel are ``BPF_MAP_TYPE_PROG_ARRAY``, "
"``BPF_MAP_TYPE_PERF_EVENT_ARRAY``, ``BPF_MAP_TYPE_CGROUP_ARRAY``, ``BPF_MAP_TYPE_STACK_TRACE``, "
"``BPF_MAP_TYPE_ARRAY_OF_MAPS``, ``BPF_MAP_TYPE_HASH_OF_MAPS``. For example, ``BPF_MAP_TYPE_PROG_ARRAY`` is an "
"array map which holds other BPF programs, ``BPF_MAP_TYPE_ARRAY_OF_MAPS`` and ``BPF_MAP_TYPE_HASH_OF_MAPS`` both "
"hold pointers to other maps such that entire BPF maps can be atomically replaced at runtime. These types of maps "
"tackle a specific issue which was unsuitable to be implemented solely through a BPF helper function since "
"additional (non-data) state is required to be held across BPF program invocations."
msgstr ""
"当前在内核中的非通用映射是``BPF_MAP_TYPE_PROG_ARRAY``，``BPF_MAP_TYPE_PERF_EVENT_ARRAY``，"
"``BPF_MAP_TYPE_CGROUP_ARRAY``，``BPF_MAP_TYPE_STACK_TRACE``，``BPF_MAP_TYPE_ARRAY_OF_MAPS``，"
"``BPF_MAP_TYPE_HASH_OF_MAPS``。 例如，``BPF_MAP_TYPE_PROG_ARRAY`` 是一个包含其他 BPF 程序的数组映射，"
"``BPF_MAP_TYPE_ARRAY_OF_MAPS`` 和 ``BPF_MAP_TYPE_HASH_OF_MAPS`` 都持有指向其他映射的指针，这样整个 BPF 映射可以在"
"运行时被原子替换。 这些类型的映射解决了一个不适合仅通过 BPF 辅助函数实现的特定问题，因为需要在 BPF 程序调用中保持"
"额外的（非数据）状态。"

#: ../../bpf.rst:400 323459d4d9804ae09ee554f1ee9705e5
msgid "Object Pinning"
msgstr "对象固定（Object Pinning）"

#: ../../bpf.rst:405 acc18f269f214730b84f68f8bb5b44ef
msgid ""
"BPF maps and programs act as a kernel resource and can only be accessed through file descriptors, backed by "
"anonymous inodes in the kernel. Advantages, but also a number of disadvantages come along with them:"
msgstr ""
"BPF 映射和程序作为内核资源，只能通过文件描述符访问，并由内核中的匿名 inode 支持。这种做法既有优点也有一些缺点："

#: ../../bpf.rst:409 8ed1c970e6894f2f998debdf6da2da03
msgid ""
"User space applications can make use of most file descriptor related APIs, file descriptor passing for Unix "
"domain sockets work transparently, etc, but at the same time, file descriptors are limited to a processes' "
"lifetime, which makes options like map sharing rather cumbersome to carry out."
msgstr ""
"用户空间应用程序可以使用大多数与文件描述符相关的 API，透明的为 Unix 域套接字传递的文件描述符等等，但同时文件描述"
"符仅限于进程的生命周期，这使得映射共享等选项相当麻烦。"

#: ../../bpf.rst:414 3f6f266015a84c5490b53a66c1884a27
msgid ""
"Thus, it brings a number of complications for certain use cases such as iproute2, where tc or XDP sets up and "
"loads the program into the kernel and terminates itself eventually. With that, also access to maps is "
"unavailable from user space side, where it could otherwise be useful, for example, when maps are shared between "
"ingress and egress locations of the data path. Also, third party applications may wish to monitor or update map "
"contents during BPF program runtime."
msgstr ""
"因此，它为某些用例带来了许多复杂性，例如 iproute2，其中 tc 或 XDP 设置将程序加载到内核中后会最终自行终止。 这样从"
"用户空间端也无法访问到映射，即使它可能很有用。例如当映射被在data path的入口和出口位置之间共享时。 此外，第三方应"
"用程序可能希望在 BPF 程序运行期间监视或更新映射内容。"

#: ../../bpf.rst:422 8d3861dcb5a141be9391b7fbfcdb6812
msgid ""
"To overcome this limitation, a minimal kernel space BPF file system has been implemented, where BPF map and "
"programs can be pinned to, a process called object pinning. The BPF system call has therefore been extended with "
"two new commands which can pin (``BPF_OBJ_PIN``) or retrieve (``BPF_OBJ_GET``) a previously pinned object."
msgstr ""
"为了克服这个限制，内核实现了一个最小内核空间的 BPF 文件系统，其中 BPF 映射和程序可以被固定其中，这个过程称为对象"
"固定。 为此BPF 系统调用扩展了两个新命令，它们可以固定（``BPF_OBJ_PIN``）或检索（``BPF_OBJ_GET``）以前固定的对象。"

#: ../../bpf.rst:428 844e2b92d90544e3b631ff91e1820b32
msgid ""
"For instance, tools such as tc make use of this infrastructure for sharing maps on ingress and egress. The BPF "
"related file system is not a singleton, it does support multiple mount instances, hard and soft links, etc."
msgstr ""
"例如，像 tc 这样的工具利用这个基础设施来共享入口和出口的映射。 BPF 相关的文件系统不是单例模式运行的，它支持多个挂"
"载实例、硬链接和软链接等。"

#: ../../bpf.rst:433 ef8743bb9d1b4e5780666b3ab499656b
msgid "Tail Calls"
msgstr "尾调用（Tail Calls）"

#: ../../bpf.rst:438 8497c35d0846463ca73b7156a775300e
msgid ""
"Another concept that can be used with BPF is called tail calls. Tail calls can be seen as a mechanism that "
"allows one BPF program to call another, without returning back to the old program. Such a call has minimal "
"overhead as unlike function calls, it is implemented as a long jump, reusing the same stack frame."
msgstr ""
"可以与 BPF 一起使用的另一个概念称为尾调用。 尾调用可以看作是一种机制，它允许一个 BPF 程序调用另一个程序，而不返回"
"到旧程序。 这样的调用具有最小的开销，因为与函数调用不同，它是利用长跳转，重用相同的堆栈帧实现的。"

#: ../../bpf.rst:443 8ef429bf5cc245d389c7389c4384731b
msgid ""
"Such programs are verified independently of each other, thus for transferring state, either per-CPU maps as "
"scratch buffers or in case of tc programs, ``skb`` fields such as the ``cb[]`` area must be used."
msgstr ""
"BPF 程序都是独立验证的，因此要传递状态，要么使用 per-CPU map 作为 scratch 缓冲区 ，要么如果是 tc 程序的话，还可以"
"使用 skb 的某些字段（例如 cb[]）。"

#: ../../bpf.rst:447 5ba3a6a213db4d89a5ded136c85d1a07
msgid ""
"Only programs of the same type can be tail called, and they also need to match in terms of JIT compilation, thus "
"either JIT compiled or only interpreted programs can be invoked, but not mixed together."
msgstr ""
"只有同类型的程序才能被尾调用，而且它们在JIT编译方面也需要匹配，也就是它可以是调用JIT编译的程序，也可以调用只有解"
"释程序的程序，但不能混在一起调用。"

#: ../../bpf.rst:451 17b5b9562a1f4aaea7295a10e7bcd2c0
msgid ""
"There are two components involved for carrying out tail calls: the first part needs to setup a specialized map "
"called program array (``BPF_MAP_TYPE_PROG_ARRAY``) that can be populated by user space with key / values, where "
"values are the file descriptors of the tail called BPF programs, the second part is a ``bpf_tail_call()`` helper "
"where the context, a reference to the program array and the lookup key is passed to. Then the kernel inlines "
"this helper call directly into a specialized BPF instruction. Such a program array is currently write-only from "
"user space side."
msgstr ""
"执行尾调用涉及两个组件：第一部分需要设置一个称为程序数组（``BPF_MAP_TYPE_PROG_ARRAY``）的专用映射，可以由用户空间"
"使用键/值填充，其中值是尾调用的BPF 程序，第二部分是 ``bpf_tail_call()`` 辅助函数，对其传递的参数分别是对程序数组"
"的引用以及查询映射所用的 key。 然后内核将这个辅助函数的调用直接内联到专门的 BPF 指令中， 这种程序数组目前在用户空"
"间端是只写的。"

#: ../../bpf.rst:460 b060a834caa74458b71deec4e845dc73
msgid ""
"The kernel looks up the related BPF program from the passed file descriptor and atomically replaces program "
"pointers at the given map slot. When no map entry has been found at the provided key, the kernel will just "
"\"fall through\" and continue execution of the old program with the instructions following after the "
"``bpf_tail_call()``. Tail calls are a powerful utility, for example, parsing network headers could be structured "
"through tail calls. During runtime, functionality can be added or replaced atomically, and thus altering the BPF "
"program's execution behavior."
msgstr ""
"内核从传递的文件描述符中查找相关的 BPF 程序，并原子地替换给定映射槽处的程序指针。 当在提供的键上没有找到映射条目"
"时，内核将“失败”并继续执行旧程序，并使用 bpf_tail_call() 之后的指令。 尾调用是一个强大的实用程序，例如可以通过尾"
"调用来构造解析网络标头。 在运行时可以自动添加或替换功能，从而改变 BPF 程序的执行行为。"

#: ../../bpf.rst:472 cc21ee12312048078fda3b4825f3a0af
msgid "BPF to BPF Calls"
msgstr "BPF 到 BPF 调用"

#: ../../bpf.rst:477 8920536116e94e47998866cc35f5d44f
msgid ""
"Aside from BPF helper calls and BPF tail calls, a more recent feature that has been added to the BPF core "
"infrastructure is BPF to BPF calls. Before this feature was introduced into the kernel, a typical BPF C program "
"had to declare any reusable code that, for example, resides in headers as ``always_inline`` such that when LLVM "
"compiles and generates the BPF object file all these functions were inlined and therefore duplicated many times "
"in the resulting object file, artificially inflating its code size:"
msgstr ""
"除了 BPF 辅助函数调用和 BPF 尾调用之外，最近添加到 BPF 核心基础架构的特性是 BPF 到 BPF 调用。 在这个特性被引入内"
"核之前，一个典型的 BPF C 程序必须声明任何可重用的代码，例如，在头文件中声明``always_inline``，这样当 LLVM 编译和"
"生成 BPF 目标文件时，所有这些函数都被内联，因此在生成的目标文件中重复了很多次，人为地扩大了它的代码大小："

#: ../../bpf.rst:512 891f9dbf04ec451f8575afeb2df4f985
msgid ""
"The main reason why this was necessary was due to lack of function call support in the BPF program loader as "
"well as verifier, interpreter and JITs. Starting with Linux kernel 4.16 and LLVM 6.0 this restriction got lifted "
"and BPF programs no longer need to use ``always_inline`` everywhere. Thus, the prior shown BPF example code can "
"then be rewritten more naturally as:"
msgstr ""
"这样做的主要原因是由于 BPF 程序加载器以及验证器、解释器和 JIT 中缺乏函数调用支持。 从 Linux 内核 4.16 和 LLVM "
"6.0 开始，这个限制被解除，BPF 程序不再需要到处使用``always_inline``。 因此之前显示的 BPF 示例代码可以更自然地重写"
"为："

#: ../../bpf.rst:540 597901b0e1374d80b6e27953e385b8c1
msgid ""
"Mainstream BPF JIT compilers like ``x86_64`` and ``arm64`` support BPF to BPF calls today with others following "
"in near future. BPF to BPF call is an important performance optimization since it heavily reduces the generated "
"BPF code size and therefore becomes friendlier to a CPU's instruction cache."
msgstr ""
"像 x86_64 和 arm64 这样的主流 BPF JIT 编译器现在支持 BPF 到 BPF 的调用，不久的将来还会有其他编译器支持。 BPF 到 "
"BPF 调用是一项重要的性能优化，因为它大大减少了生成的 BPF 代码大小，因此对 CPU 的指令缓存更友好。"

#: ../../bpf.rst:545 b140ebd3bc0345cca44e8561e7a6d4f1
msgid ""
"The calling convention known from BPF helper function applies to BPF to BPF calls just as well, meaning ``r1`` "
"up to ``r5`` are for passing arguments to the callee and the result is returned in ``r0``. ``r1`` to ``r5`` are "
"scratch registers whereas ``r6`` to ``r9`` preserved across calls the usual way. The maximum number of nesting "
"calls respectively allowed call frames is ``8``. A caller can pass pointers (e.g. to the caller's stack frame) "
"down to the callee, but never vice versa."
msgstr ""
"从 BPF 辅助函数已知的调用方式同样适用于 BPF 到 BPF 调用，这意味着 ``r1`` 到 ``r5`` 用于将参数传递给被调用者，结果"
"在 ``r0`` 中返回。 ``r1`` 到 ``r5`` 是临时寄存器，而 ``r6`` 到 ``r9`` 以通常的方式跨调用保留。 嵌套调用的最大数量"
"分别允许调用帧是 ``8``。 调用者可以将指针（例如，指向调用者的堆栈帧）向下传递给被调用者，但反之亦然。"

#: ../../bpf.rst:553 96557438c3f24be79eedfa24a358928b
msgid ""
"BPF JIT compilers emit separate images for each function body and later fix up the function call addresses in "
"the image in a final JIT pass. This has proven to require minimal changes to the JITs in that they can treat BPF "
"to BPF calls as conventional BPF helper calls."
msgstr ""
"BPF JIT 编译器为每个函数体生成单独的图像，然后在最终的 JIT 传递中固定图像中的函数调用地址。 事实证明这需要对 JIT "
"进行最小的更改，因为它们可以将 BPF 到 BPF 调用视为传统的 BPF 辅助函数调用。"

#: ../../bpf.rst:558 89106e89c4514688a8742070378222ef
msgid ""
"Up to kernel 5.9, BPF tail calls and BPF subprograms excluded each other. BPF programs that utilized tail calls "
"couldn't take the benefit of reducing program image size and faster load times. Linux kernel 5.10 finally allows "
"users to bring the best of two worlds and adds the ability to combine the BPF subprograms with tail calls."
msgstr ""
"直到内核 5.9，BPF 尾调用和 BPF 子程序相互排斥。 使用尾调用的 BPF 程序无法从减小程序映像大小和加快加载时间中获"
"益。 Linux 内核 5.10 最终允许用户带来两全其美的效果，并增加了将 BPF 子程序与尾调用相结合的能力。"

#: ../../bpf.rst:564 d961ee92b1a542dbb072fca503480b3f
msgid ""
"This improvement comes with some restrictions, though. Mixing these two features can cause a kernel stack "
"overflow. To get an idea of what might happen, see the picture below that illustrates the mix of bpf2bpf calls "
"and tail calls:"
msgstr ""
"不过这种改进有一些限制。 同时使用这两个特性会导致内核堆栈溢出。 要了解可能发生的情况，请参见下图对 bpf2bpf 调用和"
"尾调用的混合方式的说明："

#: ../../bpf.rst:571 5ab33584e0f34a5bb79e8db09948fe29
msgid ""
"Tail calls, before the actual jump to the target program, will unwind only its current stack frame. As we can "
"see in the example above, if a tail call occurs from within the sub-function, the function's (func1) stack frame "
"will be present on the stack when a program execution is at func2. Once the final function (func3) function "
"terminates, all the previous stack frames will be unwinded and control will get back to the caller of BPF "
"program caller."
msgstr ""
"在实际跳转到目标程序之前，尾调用将仅展开它当前的工作堆栈帧。 正如我们在上面的示例中看到的，如果从子函数内部发生尾"
"调用，则当程序执行到 func2 时，函数的 (func1) 堆栈帧将出现在堆栈上。 一旦最终函数（func3）函数终止，所有先前的堆"
"栈帧都将被展开，控制权将返回给 BPF 程序调用者的调用者。"

#: ../../bpf.rst:578 a1019e0514154f1f888280bcf2482650
msgid ""
"The kernel introduced additional logic for detecting this feature combination. There is a limit on the stack "
"size throughout the whole call chain down to 256 bytes per subprogram (note that if the verifier detects the "
"bpf2bpf call, then the main function is treated as a sub-function as well). In total, with this restriction, the "
"BPF program's call chain can consume at most 8KB of stack space. This limit comes from the 256 bytes per stack "
"frame multiplied by the tail call count limit (33). Without this, the BPF programs will operate on 512-byte "
"stack size, yielding the 16KB size in total for the maximum count of tail calls that would overflow the stack on "
"some architectures."
msgstr ""
"内核引入了额外的逻辑来检测这种特征组合。 整个调用链中的堆栈大小有一个限制，每个子程序最多为 256 个字节（请注意，"
"如果验证程序检测到 bpf2bpf 调用，则主函数也被视为子函数）。 总之有了这个限制，BPF 程序的调用链最多可以消耗 8KB 的"
"堆栈空间。 此限制来自每个堆栈帧的 256 字节乘以尾调用计数限制 (33)。 如果没有这个限制，BPF 程序将在 512 字节的堆栈"
"大小上运行，总共产生 16KB 的大小，用于在某些架构上溢出堆栈的尾调用的最大计数。"

#: ../../bpf.rst:588 bb4d5a7c41a44215b6cfdd210b0cfc43
msgid ""
"One more thing to mention is that this feature combination is currently supported only on the x86-64 "
"architecture."
msgstr "值得一提的是，目前只有 x86-64 架构才支持这种功能组合。"

#: ../../bpf.rst:592 2ddf368266eb4a40942318e3fb738b92
msgid "JIT"
msgstr "JIT"

#: ../../bpf.rst:597 afdc0d95e01d4c45bfb067499df4f3e8
msgid ""
"The 64 bit ``x86_64``, ``arm64``, ``ppc64``, ``s390x``, ``mips64``, ``sparc64`` and 32 bit ``arm``, ``x86_32`` "
"architectures are all shipped with an in-kernel eBPF JIT compiler, also all of them are feature equivalent and "
"can be enabled through:"
msgstr ""
"64 位``x86_64``、``arm64``、``ppc64``、``s390x``、``mips64``、``sparc64`` 和 32 位``arm``、``x86_32 `` 架构都带有"
"内核内 eBPF JIT 编译器，而且它们都具有等效的功能，可以通过以下方式启用："

#: ../../bpf.rst:606 d25d75593c234905a447563b3a051823
msgid ""
"The 32 bit ``mips``, ``ppc`` and ``sparc`` architectures currently have a cBPF JIT compiler. The mentioned "
"architectures still having a cBPF JIT as well as all remaining architectures supported by the Linux kernel which "
"do not have a BPF JIT compiler at all need to run eBPF programs through the in-kernel interpreter."
msgstr ""
"32 位 ``mips``、``ppc`` 和 ``sparc`` 架构目前有一个 cBPF JIT 编译器。 上面提到的仍然有 cBPF JIT 的架构以及 Linux "
"内核支持的所有剩余架构，根本没有 BPF JIT 编译器，需要通过内核解释器运行 eBPF 程序。"

#: ../../bpf.rst:611 92c4ab8255db4a859fd5305585b6e20e
msgid ""
"In the kernel's source tree, eBPF JIT support can be easily determined through issuing a grep for "
"``HAVE_EBPF_JIT``:"
msgstr "在内核的源代码树中，可以通过为“HAVE_EBPF_JIT”发出 grep 轻松确定 eBPF JIT 支持："

#: ../../bpf.rst:625 014d1ff508004f7eadca4993f7b266a2
msgid ""
"JIT compilers speed up execution of the BPF program significantly since they reduce the per instruction cost "
"compared to the interpreter. Often instructions can be mapped 1:1 with native instructions of the underlying "
"architecture. This also reduces the resulting executable image size and is therefore more instruction cache "
"friendly to the CPU. In particular in case of CISC instruction sets such as ``x86``, the JITs are optimized for "
"emitting the shortest possible opcodes for a given instruction to shrink the total necessary size for the "
"program translation."
msgstr ""
"JIT 编译器明显加快了 BPF 程序的执行速度，因为与解释器相比，它们降低了每条指令的成本。 通常指令可以与底层架构的本"
"机指令 1:1 映射。 这也减少了生成的可执行映像大小，因此对 CPU 更友好的指令缓存。 特别是对于诸如“x86”之类的 CISC 指"
"令集，JIT 经过优化，可以为给定指令发出最短的操作码，以缩小程序翻译所需的总大小。"

#: ../../bpf.rst:635 26ba691acc8c45028c95b54af2b0762a
msgid "Hardening"
msgstr "加固（Hardening）"

#: ../../bpf.rst:637 07e87a3a825c48669953ce2722ccc944
msgid ""
"BPF locks the entire BPF interpreter image (``struct bpf_prog``) as well as the JIT compiled image (``struct "
"bpf_binary_header``) in the kernel as read-only during the program's lifetime in order to prevent the code from "
"potential corruptions. Any corruption happening at that point, for example, due to some kernel bugs will result "
"in a general protection fault and thus crash the kernel instead of allowing the corruption to happen silently."
msgstr ""
"BPF 在程序的生命周期内将整个 BPF 解释器镜像（``struct bpf_prog``）以及 JIT 编译镜像（``struct "
"bpf_binary_header``）锁定为只读，以防止代码潜在的损坏。例如由于某些内核bug会触发通用的保护机制，因此会造成内核崩"
"溃（crash）而不 是允许损坏静默地发生。"

#: ../../bpf.rst:644 0a58ac6f96064de89952008f1e388b55
msgid "Architectures that support setting the image memory as read-only can be determined through:"
msgstr "可以通过以下方式确定支持将图像内存设置为只读的架构："

#: ../../bpf.rst:655 5acb835a413a48619e357d2a2ba8b469
msgid ""
"The option ``CONFIG_ARCH_HAS_SET_MEMORY`` is not configurable, thanks to which this protection is always built-"
"in. Other architectures might follow in the future."
msgstr "选项 ``CONFIG_ARCH_HAS_SET_MEMORY`` 是不可配置的，因此这种保护总是内置的。 未来可能会采用其他架构。"

#: ../../bpf.rst:659 c12c611c9349490dabca218cc047ab60
msgid ""
"In case of the ``x86_64`` JIT compiler, the JITing of the indirect jump from the use of tail calls is realized "
"through a retpoline in case ``CONFIG_RETPOLINE`` has been set which is the default at the time of writing in "
"most modern Linux distributions."
msgstr "在``x86_64`` JIT 编译器的情况下，现代 Linux 发行版使用尾调用的间接跳转的 JITing 是通过 retpoline 实现的。"

#: ../../bpf.rst:664 f6de251d7ee54f09b6c41a2f3e4d2c41
msgid ""
"In case of ``/proc/sys/net/core/bpf_jit_harden`` set to ``1`` additional hardening steps for the JIT compilation "
"take effect for unprivileged users. This effectively trades off their performance slightly by decreasing a "
"(potential) attack surface in case of untrusted users operating on the system. The decrease in program execution "
"still results in better performance compared to switching to interpreter entirely."
msgstr ""
"如果 ``/proc/sys/net/core/bpf_jit_harden`` 设置为 ``1``，JIT 编译的额外强化步骤对非特权用户生效。 在不受信任的用"
"户在系统上操作的情况下，通过减少（潜在的）攻击面，这有效地权衡了它们的性能。 与完全切换到解释器相比，程序执行的减"
"少仍然会带来更好的性能。"

#: ../../bpf.rst:671 046f34269ae24fccb1fd131a3db6a620
msgid ""
"Currently, enabling hardening will blind all user provided 32 bit and 64 bit constants from the BPF program when "
"it gets JIT compiled in order to prevent JIT spraying attacks which inject native opcodes as immediate values. "
"This is problematic as these immediate values reside in executable kernel memory, therefore a jump that could be "
"triggered from some kernel bug would jump to the start of the immediate value and then execute these as native "
"instructions."
msgstr ""
"当前，启用加固会在 JIT 编译时盲化（blind）BPF 程序中用户提供的所有 32 位和 64 位常量，以防御 JIT spraying（喷射）"
"攻击，这些攻击会将原生操作码（native opcodes）作为立即数（immediate values）注入到内核。这种攻击有效是因为：立即"
"数驻留在可执行内核内存（executable kernel memory）中，因此某些内核 bug 可能会触发一个跳转动作，如果跳转到立即数的"
"开始位置，就会把它们当做原生指令开始执行。"

#: ../../bpf.rst:678 955ea5b608da4fcd967a754f471f5729
msgid ""
"JIT constant blinding prevents this due to randomizing the actual instruction, which means the operation is "
"transformed from an immediate based source operand to a register based one through rewriting the instruction by "
"splitting the actual load of the value into two steps: 1) load of a blinded immediate value ``rnd ^ imm`` into a "
"register, 2) xoring that register with ``rnd`` such that the original ``imm`` immediate then resides in the "
"register and can be used for the actual operation. The example was provided for a load operation, but really all "
"generic operations are blinded."
msgstr ""
"JIT 常量致盲通过随机化实际指令来防止这种情况发生，这意味着通过将值的实际加载分为两个步骤来重写指令，将操作从基于"
"立即数的源操作数转换为基于寄存器的操作数：1) 加载 将立即数``rnd ^ imm``隐藏到寄存器中，2）用``rnd``对该寄存器进行"
"异或运算，这样原始的``imm``立即数就驻留在寄存器中并可以用于实际操作。 该示例是为加载操作提供的，但实际上所有通用"
"操作都是盲目的。"

#: ../../bpf.rst:687 c0988097202540edb26d45deb7b06566
msgid "Example of JITing a program with hardening disabled:"
msgstr "JITing 禁用加固的程序的示例："

#: ../../bpf.rst:705 0d02ed6807284bfab78534c2c9297013
msgid ""
"The same program gets constant blinded when loaded through BPF as an unprivileged user in the case hardening is "
"enabled:"
msgstr "在启用了加固的情况下，当以非特权用户身份通过 BPF 加载时，相同的程序会一直保持盲态："

#: ../../bpf.rst:734 6ad6de099b5e4ee3a66d2efd9dcdc424
msgid ""
"Both programs are semantically the same, only that none of the original immediate values are visible anymore in "
"the disassembly of the second program."
msgstr "这两个程序在语义上是相同的，只是在第二个程序的反汇编中，原始立即值不再可见。"

#: ../../bpf.rst:738 b668990eab8a4d6e997128b6217f3db3
msgid ""
"At the same time, hardening also disables any JIT kallsyms exposure for privileged users, preventing that JIT "
"image addresses are not exposed to ``/proc/kallsyms`` anymore."
msgstr "同时，加固还会禁止任何 JIT 内核符合（kallsyms）暴露给特权用户，JIT 镜像地址不再 出现在 /proc/kallsyms 中。"

#: ../../bpf.rst:742 38801550903e4e6db2be3d9f034eebf2
msgid ""
"Moreover, the Linux kernel provides the option ``CONFIG_BPF_JIT_ALWAYS_ON`` which removes the entire BPF "
"interpreter from the kernel and permanently enables the JIT compiler. This has been developed as part of a "
"mitigation in the context of Spectre v2 such that when used in a VM-based setting, the guest kernel is not going "
"to reuse the host kernel's BPF interpreter when mounting an attack anymore. For container-based environments, "
"the ``CONFIG_BPF_JIT_ALWAYS_ON`` configuration option is optional, but in case JITs are enabled there anyway, "
"the interpreter may as well be compiled out to reduce the kernel's complexity. Thus, it is also generally "
"recommended for widely used JITs in case of main stream architectures such as ``x86_64`` and ``arm64``."
msgstr ""
"此外，Linux 内核提供了选项``CONFIG_BPF_JIT_ALWAYS_ON``，它从内核中删除了整个 BPF 解释器并永久启用 JIT 编译器。 这"
"是作为 Spectre v2 环境中缓解措施的一部分而开发的，这样当在基于 VM 的设置中使用时，虚化内核在挂载时将不再重用主机"
"内核的 BPF 解释器从而避免被攻击。 对于基于容器的环境，``CONFIG_BPF_JIT_ALWAYS_ON`` 配置选项是可选的，但如果在那里"
"启用了 JIT，也可以编译出解释器以降低内核的复杂性。 因此在主流架构（如 x86_64 和 arm64 ）的情况下，通常也建议广泛"
"使用 JIT。"

#: ../../bpf.rst:754 5f2cae6eac3c44219b4547b9e5ca551d
msgid ""
"Last but not least, the kernel offers an option to disable the use of the ``bpf(2)`` system call for "
"unprivileged users through the ``/proc/sys/kernel/unprivileged_bpf_disabled`` sysctl knob. This is on purpose a "
"one-time kill switch, meaning once set to ``1``, there is no option to reset it back to ``0`` until a new kernel "
"reboot. When set only ``CAP_SYS_ADMIN`` privileged processes out of the initial namespace are allowed to use the "
"``bpf(2)`` system call from that point onwards. Upon start, Cilium sets this knob to ``1`` as well."
msgstr ""
"最后但并非最不重要的一点是，内核提供了一个选项，可以通过 ``/proc/sys/kernel/unprivileged_bpf_disabled`` sysctl 旋"
"钮为非特权用户禁用``bpf(2)`` 系统调用。 这是故意的一次性终止开关，这意味着一旦设置为“1”，在新的内核重新启动之前，"
"没有选项可以将其重置回“0”。 设置时，仅允许初始命名空间之外的“CAP_SYS_ADMIN”特权进程从该点开始使用“bpf(2)”系统调"
"用。 启动时，Cilium 也将此旋钮设置为“1”。"

#: ../../bpf.rst:768 4161736489ea4830bd6d957ef0e157a4
msgid "Offloads"
msgstr "超频（Offloads）"

#: ../../bpf.rst:773 442ad07dc7bf40a8acf25319f4f07242
msgid ""
"Networking programs in BPF, in particular for tc and XDP do have an offload-interface to hardware in the kernel "
"in order to execute BPF code directly on the NIC."
msgstr ""
"BPF 网络程序，尤其是 tc 和 XDP BPF 程序在内核中都有一个 offload 到硬件的接口，这样就可以直接在网卡上执行 BPF 程"
"序。"

#: ../../bpf.rst:777 b74b43800bd043b681d71c41db90d3fb
msgid ""
"Currently, the ``nfp`` driver from Netronome has support for offloading BPF through a JIT compiler which "
"translates BPF instructions to an instruction set implemented against the NIC. This includes offloading of BPF "
"maps to the NIC as well, thus the offloaded BPF program can perform map lookups, updates and deletions."
msgstr ""
"目前，来自 Netronome 的 nfp 驱动程序支持通过 JIT 编译器对 BPF 进行超频，该编译器将 BPF 指令转换为针对 NIC 实现的"
"指令集。 另外，它还支持将 BPF 映射 offload 到网卡，因此 offloaded BPF 程序可以执行映射查找、更新和删除操作。"

#: ../../bpf.rst:784 1f5dd3cfc6654715ac205a23ad6e1f85
msgid "Toolchain"
msgstr "工具链"

#: ../../bpf.rst:786 88e449d76ff64aa89f58309f74878230
msgid ""
"Current user space tooling, introspection facilities and kernel control knobs around BPF are discussed in this "
"section. Note, the tooling and infrastructure around BPF is still rapidly evolving and thus may not provide a "
"complete picture of all available tools."
msgstr ""
"本节将讨论当前围绕 BPF 的用户空间工具、自省工具和内核控制旋钮。 请注意，围绕 BPF 的工具和基础设施仍在快速发展，因"
"此可能无法提供所有可用工具的完整图景。"

#: ../../bpf.rst:792 f87c7228d67e4fb59182d3980963d462
msgid "Development Environment"
msgstr "开发环境"

#: ../../bpf.rst:794 c2e5c29c34af415d8a490cb9fc791015
msgid ""
"A step by step guide for setting up a development environment for BPF can be found below for both Fedora and "
"Ubuntu. This will guide you through building, installing and testing a development kernel as well as building "
"and installing iproute2."
msgstr ""
"下面为 Fedora 和 Ubuntu 提供了为 BPF 设置开发环境的分步指南。 这将指导您构建、安装和测试开发内核以及构建和安装 "
"iproute2。"

#: ../../bpf.rst:798 f530fd6154bc44b9b712327b8cf0ac39
msgid ""
"The step of manually building iproute2 and Linux kernel is usually not necessary given that major distributions "
"already ship recent enough kernels by default, but would be needed for testing bleeding edge versions or "
"contributing BPF patches to iproute2 and to the Linux kernel, respectively. Similarly, for debugging and "
"introspection purposes building bpftool is optional, but recommended."
msgstr ""
"手动构建 iproute2 和 Linux 内核的步骤通常是不必要的，因为主要发行版已经默认提供了足够新的内核，但需要分别测试前沿"
"版本或为 iproute2 和 Linux 内核提供 BPF 补丁。 同样，出于调试和自省的目的，构建 bpftool 是可选的，但建议使用。"

#: ../../bpf.rst:805 0d98422883394622a579ce7de01e5428
msgid "Fedora"
msgstr "Fedora"

#: ../../bpf.rst:807 205afa8ca52249d1a04d3f59861d2274
msgid "The following applies to Fedora 25 or later:"
msgstr "以下适用于 Fedora 25 或更高版本："

#: ../../bpf.rst:814 3dfa88f071c74e53b5bedd29d803f797
msgid "If you are running some other Fedora derivative and ``dnf`` is missing, try using ``yum`` instead."
msgstr "如果您正在运行其他一些 Fedora 衍生产品并且缺少 dnf，请尝试使用 yum 代替。"

#: ../../bpf.rst:818 c0d88969d6534b198822b5d45c863feb
msgid "Ubuntu"
msgstr "Ubuntu"

#: ../../bpf.rst:820 614ed658c0f0469e8135459fa46f1c78
msgid "The following applies to Ubuntu 17.04 or later:"
msgstr "以下适用于 Ubuntu 17.04 或更高版本："

#: ../../bpf.rst:829 051069b428ad4ee996b188be664e5bdf
msgid "openSUSE Tumbleweed"
msgstr "openSUSE Tumbleweed"

#: ../../bpf.rst:831 4f40939be9bf4a5fa08634061ed879b4
msgid "The following applies to openSUSE Tumbleweed and openSUSE Leap 15.0 or later:"
msgstr "以下适用于 openSUSE Tumbleweed 和 openSUSE Leap 15.0 或更高版本："

#: ../../bpf.rst:839 4852709e3b3845d793235df34d143113
msgid "Compiling the Kernel"
msgstr "编译内核"

#: ../../bpf.rst:841 b819578ce0f24f1f9387ca58c6ff4144
msgid ""
"Development of new BPF features for the Linux kernel happens inside the ``net-next`` git tree, latest BPF fixes "
"in the ``net`` tree. The following command will obtain the kernel source for the ``net-next`` tree through git:"
msgstr ""
"为 Linux 内核开发新的 BPF 功能发生在 ``net-next`` git 树中，最新的 BPF 修复在 ``net`` 树中。 以下命令将通过 git "
"获取“net-next”树的内核源代码："

#: ../../bpf.rst:849 8f48980a463f49d2bd1530e3f652d8b9
msgid ""
"If the git commit history is not of interest, then ``--depth 1`` will clone the tree much faster by truncating "
"the git history only to the most recent commit."
msgstr "如果对 git 提交历史不感兴趣，那么 —depth 1 将通过仅将 git 历史截断为最近的提交来更快地克隆树。"

#: ../../bpf.rst:852 3a138181495d4fc5bef071f8c3f3d817
msgid "In case the ``net`` tree is of interest, it can be cloned from this url:"
msgstr "如果对``net``感兴趣，可以从这个 url 克隆它："

#: ../../bpf.rst:858 d95ac8e74f514a678bdc6df165ae9918
msgid ""
"There are dozens of tutorials in the Internet on how to build Linux kernels, one good resource is the Kernel "
"Newbies website (https://kernelnewbies.org/KernelBuild) that can be followed with one of the two git trees "
"mentioned above."
msgstr ""
"互联网上有很多关于如何构建 Linux 内核的教程，其中一个很好的资源是 Kernel Newbies 网站 (https://kernelnewbies.org/"
"KernelBuild)，可以参考上面提到的两个 git 树之一。"

#: ../../bpf.rst:862 c6befbc902914c3d9e42f3cbd86e626d
msgid ""
"Make sure that the generated ``.config`` file contains the following ``CONFIG_*`` entries for running BPF. These "
"entries are also needed for Cilium."
msgstr "确保生成的``.config`` 文件包含以下用于运行 BPF 的 ``CONFIG_*`` 条目， Cilium 也需要这些条目。"

#: ../../bpf.rst:879 a449ddb2c6064c21bcf8c36f29a15e4c
msgid ""
"Some of the entries cannot be adjusted through ``make menuconfig``. For example, ``CONFIG_HAVE_EBPF_JIT`` is "
"selected automatically if a given architecture does come with an eBPF JIT. In this specific case, "
"``CONFIG_HAVE_EBPF_JIT`` is optional but highly recommended. An architecture not having an eBPF JIT compiler "
"will need to fall back to the in-kernel interpreter with the cost of being less efficient executing BPF "
"instructions."
msgstr ""
"某些条目无法通过“make menuconfig”进行调整。 例如，如果给定的架构确实带有 eBPF JIT，则会自动选"
"择“CONFIG_HAVE_EBPF_JIT”。 在这种特定情况下，``CONFIG_HAVE_EBPF_JIT`` 是可选的，但强烈推荐选择该选项。 没有 eBPF "
"JIT 编译器的架构将需要回退到内核解释器，代价是执行 BPF 指令的效率较低。"

#: ../../bpf.rst:887 1d1251fddfec4871a9f901cffd4869f3
msgid "Verifying the Setup"
msgstr "验证设置"

#: ../../bpf.rst:889 3d58603a1c27457d864a9423c041143a
msgid ""
"After you have booted into the newly compiled kernel, navigate to the BPF selftest suite in order to test BPF "
"functionality (current working directory points to the root of the cloned git tree):"
msgstr "启动到新编译的内核后，导航到 BPF 自测套件以测试 BPF 功能（当前工作目录指向克隆的 git 树的根目录）："

#: ../../bpf.rst:899 2ee90714561c4d9fbcb58bb2b26cef0a
msgid ""
"The verifier tests print out all the current checks being performed. The summary at the end of running all tests "
"will dump information of test successes and failures:"
msgstr "验证者测试打印出所有当前正在执行的检查，运行所有测试结束时的摘要将转储测试成功和失败的信息："

#: ../../bpf.rst:907 a4f411f6724a4f3b9e8c1d199df24a98
msgid ""
"For kernel releases 4.16+ the BPF selftest has a dependency on LLVM 6.0+ caused by the BPF function calls which "
"do not need to be inlined anymore. See section :ref:`bpf_to_bpf_calls` or the cover letter mail from the kernel "
"patch (https://lwn.net/Articles/741773/) for more information. Not every BPF program has a dependency on LLVM "
"6.0+ if it does not use this new feature. If your distribution does not provide LLVM 6.0+ you may compile it by "
"following the instruction in the :ref:`tooling_llvm` section."
msgstr ""
"对于内核版本 4.16+，BPF 自检依赖于 LLVM 6.0+，这是由 BPF 函数调用引起的，不再需要内联。 有关详细信息，请参阅 :"
"ref:`bpf_to_bpf_calls` 部分或内核补丁 (https://lwn.net/Articles/741773/) 中的求职信邮件。 如果不使用这个新特性，"
"并不是每个 BPF 程序都依赖于 LLVM 6.0+。 如果您的发行版不提供 LLVM 6.0+，您可以按照 :ref:`tooling_llvm` 部分中的说"
"明进行编译。"

#: ../../bpf.rst:916 da5373c8dc9944f48ea2fa354572aa45
msgid "In order to run through all BPF selftests, the following command is needed:"
msgstr "为了运行所有 BPF 自测，需要以下命令："

#: ../../bpf.rst:922 08a6878e564b471aacff93b5ffb56ff0
msgid "If you see any failures, please contact us on Slack with the full test output."
msgstr "如果您发现任何故障，请在 Slack 上与我们联系并提供完整的测试输出。"

#: ../../bpf.rst:925 5f21617d25b948819f13292c6c80dfd0
msgid "Compiling iproute2"
msgstr "编译iproute2"

#: ../../bpf.rst:927 6898ec56361d40f083a52df880c26ffd
msgid ""
"Similar to the ``net`` (fixes only) and ``net-next`` (new features) kernel trees, the iproute2 git tree has two "
"branches, namely ``master`` and ``net-next``. The ``master`` branch is based on the ``net`` tree and the ``net-"
"next`` branch is based against the ``net-next`` kernel tree. This is necessary, so that changes in header files "
"can be synchronized in the iproute2 tree."
msgstr ""
"类似于``net``（仅修复）和``net-next``（新功能）内核树，iproute2 git 树有两个分支，即``master``和``net-next``。 "
"``master``分支基于``net``树，``net-next``分支基于``net-next``内核树。 这是必要的，以便可以在 iproute2 树中同步头"
"文件的更改。"

#: ../../bpf.rst:933 5e8dcaa599594068a68001750c811e9b
msgid "In order to clone the iproute2 ``master`` branch, the following command can be used:"
msgstr "为了克隆 iproute2 ``master`` 分支，可以使用以下命令："

#: ../../bpf.rst:940 44358e4d01494487a2ccf192d31e87e9
msgid "Similarly, to clone into mentioned ``net-next`` branch of iproute2, run the following:"
msgstr "同样，要克隆到提到的 iproute2 的“net-next”分支，请运行以下命令："

#: ../../bpf.rst:947 5b33499dc13b4d95ad250942a9f76446
msgid "After that, proceed with the build and installation:"
msgstr "之后，继续构建和安装："

#: ../../bpf.rst:970 69b31524a42b4e28b3083c19858fc5a3
msgid ""
"Ensure that the ``configure`` script shows ``ELF support: yes``, so that iproute2 can process ELF files from "
"LLVM's BPF back end. libelf was listed in the instructions for installing the dependencies in case of Fedora and "
"Ubuntu earlier."
msgstr ""
"确保 ``configure`` 脚本显示 ``ELF support: yes``，以便 iproute2 可以处理来自 LLVM 的 BPF 后端的 ELF 文件。 "
"libelf 在之前的 Fedora 和 Ubuntu 安装依赖项的说明中列出。"

#: ../../bpf.rst:975 a855f4ed97a748d49d7d23fd3e937501
msgid "Compiling bpftool"
msgstr "编译 bpftool"

#: ../../bpf.rst:977 53064efed84741678b0e5822cb4a87d4
msgid ""
"bpftool is an essential tool around debugging and introspection of BPF programs and maps. It is part of the "
"kernel tree and available under ``tools/bpf/bpftool/``."
msgstr ""
"bpftool 是围绕 BPF 程序和映射的调试和自省的重要工具。 它是内核树的一部分，可在 ``tools/bpf/bpftool/`` 下找到。"

#: ../../bpf.rst:980 037fbeb1e7b44e9e97c14917730f68bb
msgid ""
"Make sure to have cloned either the ``net`` or ``net-next`` kernel tree as described earlier. In order to build "
"and install bpftool, the following steps are required:"
msgstr "确保已经克隆了 ``net`` 或 ``net-next`` 内核树，如前所述。 为了构建和安装 bpftool，需要执行以下步骤："

#: ../../bpf.rst:1019 0d761dbd5001414bbe6d72d12ff85fd0
msgid "LLVM"
msgstr "LLVM"

#: ../../bpf.rst:1021 8d5c293c28244ebd8f84400961c2dc89
msgid "LLVM is currently the only compiler suite providing a BPF back end. gcc does not support BPF at this point."
msgstr "LLVM 是目前唯一提供 BPF 后端的编译器套件。 gcc 目前不支持 BPF。"

#: ../../bpf.rst:1024 5740c881b1a949f097acc9bf948aa655
msgid ""
"The BPF back end was merged into LLVM's 3.7 release. Major distributions enable the BPF back end by default when "
"they package LLVM, therefore installing clang and llvm is sufficient on most recent distributions to start "
"compiling C into BPF object files."
msgstr ""
"BPF 后端被合并到 LLVM 的 3.7 版本中。 主要发行版在打包 LLVM 时默认启用 BPF 后端，因此在最近的发行版上安装 clang "
"和 llvm 足以开始将 C 编译为 BPF 目标文件。"

#: ../../bpf.rst:1029 116af6c0b0be4ab6a10df49087344bbb
msgid ""
"The typical workflow is that BPF programs are written in C, compiled by LLVM into object / ELF files, which are "
"parsed by user space BPF ELF loaders (such as iproute2 or others), and pushed into the kernel through the BPF "
"system call. The kernel verifies the BPF instructions and JITs them, returning a new file descriptor for the "
"program, which then can be attached to a subsystem (e.g. networking). If supported, the subsystem could then "
"further offload the BPF program to hardware (e.g. NIC)."
msgstr ""
"典型的工作流程是 BPF 程序用 C 语言编写，通过 LLVM 编译成对象/ELF 文件，由用户空间 BPF ELF 加载器（如 iproute2 或"
"其他）解析，并通过 BPF 系统调用推送到内核中。 内核验证 BPF 指令并对它们进行 JIT，为程序返回一个新的文件描述符，然"
"后可以将其附加到子系统（例如网络）。 如果支持，子系统可以进一步将 BPF 程序卸载到硬件（例如 NIC）。"

#: ../../bpf.rst:1037 9ca74c29ce874fd7a6a194eebf9eb512
msgid "For LLVM, BPF target support can be checked, for example, through the following:"
msgstr "对于 LLVM，可以检查 BPF 目标支持，例如，通过以下方式："

#: ../../bpf.rst:1055 e64e7423495c42a391cee8eba62eb566
msgid ""
"By default, the ``bpf`` target uses the endianness of the CPU it compiles on, meaning that if the CPU's "
"endianness is little endian, the program is represented in little endian format as well, and if the CPU's "
"endianness is big endian, the program is represented in big endian. This also matches the runtime behavior of "
"BPF, which is generic and uses the CPU's endianness it runs on in order to not disadvantage architectures in any "
"of the format."
msgstr ""
"默认情况下，``bpf`` 会使用它编译的 CPU 的字节序，这意味着如果 CPU 的字节序是小字节序，程序也以小字节序格式表示，"
"如果 CPU 的字节序是大字节序， 该程序以大端表示。 这也与 BPF 的运行时行为相匹配，它是通用的并使用它运行的 CPU 的字"
"节顺序，以便不损害任何格式的架构。"

#: ../../bpf.rst:1062 04e3fe43ff1d4fbb917c0fcf348b8973
msgid ""
"For cross-compilation, the two targets ``bpfeb`` and ``bpfel`` were introduced, thanks to that BPF programs can "
"be compiled on a node running in one endianness (e.g. little endian on x86) and run on a node in another "
"endianness format (e.g. big endian on arm). Note that the front end (clang) needs to run in the target "
"endianness as well."
msgstr ""
"对于交叉编译，引入了 ``bpfeb`` 和 ``bpfel`` 这两个targets，这要归功于 BPF 程序可以在以一种字节序运行的节点上编译"
"（例如 x86 上的 little endian）并运行在另一种字节序格式上（例如arm上的大字节序）。 请注意，前端（clang）也需要以"
"目标字节序运行。"

#: ../../bpf.rst:1068 23b7b4e4923f499fa053e967c6c5b3a6
msgid ""
"Using ``bpf`` as a target is the preferred way in situations where no mixture of endianness applies. For "
"example, compilation on ``x86_64`` results in the same output for the targets ``bpf`` and ``bpfel`` due to being "
"little endian, therefore scripts triggering a compilation also do not have to be endian aware."
msgstr ""
"在没有混合字节序的情况下，使用 ``bpf`` 作为目标是首选方式。 例如，在 ``x86_64`` 上编译会导致目标``bpf`` 和 "
"``bpfel`` 的输出相同，因为它是小端序，因此触发编译的脚本也不必是字节序感知的。"

#: ../../bpf.rst:1073 bead022dc6aa42ed869f26e7615acae6
msgid "A minimal, stand-alone XDP drop program might look like the following example (``xdp-example.c``):"
msgstr "一个最小的、独立的 XDP 丢包程序可能类似于以下示例（``xdp-example.c``）："

#: ../../bpf.rst:1093 426c68abe7f4467982df01cd9695bb5f
msgid "It can then be compiled and loaded into the kernel as follows:"
msgstr "然后可以按如下方式编译并加载到内核中："

#: ../../bpf.rst:1100 eab7f7ab86084e979669b4da2e83ec05
msgid ""
"Attaching an XDP BPF program to a network device as above requires Linux 4.11 with a device that supports XDP, "
"or Linux 4.12 or later."
msgstr "将 XDP BPF 程序附加到上述网络设备需要 Linux 4.11 和支持 XDP 的设备，或者 Linux 4.12 或更高版本。"

#: ../../bpf.rst:1103 745adcefe3264beaa09344b4cb6e2e4d
msgid ""
"For the generated object file LLVM (>= 3.9) uses the official BPF machine value, that is, ``EM_BPF`` (decimal: "
"``247`` / hex: ``0xf7``). In this example, the program has been compiled with ``bpf`` target under ``x86_64``, "
"therefore ``LSB`` (as opposed to ``MSB``) is shown regarding endianness:"
msgstr ""
"对于生成的目标文件 LLVM (>= 3.9) 使用官方 BPF 机器值，即 ``EM_BPF``（十进制：``247`` / 十六进制：``0xf7``）。 在"
"此示例中，程序已使用 ``x86_64`` 下的 ``bpf`` 目标编译，因此显示了有关字节序的 ``LSB``（相对于 ``MSB``）："

#: ../../bpf.rst:1113 be187459e7954cd188073ec0108f4952
msgid ""
"``readelf -a xdp-example.o`` will dump further information about the ELF file, which can sometimes be useful for "
"introspecting generated section headers, relocation entries and the symbol table."
msgstr ""
"readelf -a xdp-example.o 能够打印 ELF 文件的更详细信息，有时在检查生成的 section header、relocation entries 和符"
"号表时会比较有用。"

#: ../../bpf.rst:1117 7e474676245b4cde88173a76dc9b7fb9
msgid ""
"In the unlikely case where clang and LLVM need to be compiled from scratch, the following commands can be used:"
msgstr "在不太可能需要从头开始编译 clang 和 LLVM 的情况下，可以使用以下命令："

#: ../../bpf.rst:1144 7f4c7eca24e343e99858c2cfe80672e1
msgid ""
"Make sure that ``--version`` mentions ``Optimized build.``, otherwise the compilation time for programs when "
"having LLVM in debugging mode will significantly increase (e.g. by 10x or more)."
msgstr ""
"确保 ``—version`` 提到 ``Optimized build.``，否则当 LLVM 处于调试模式时程序的编译时间将显着增加（例如 10 倍或更"
"多）。"

#: ../../bpf.rst:1148 55ba25863fbc4a84b69278928f87385d
msgid "For debugging, clang can generate the assembler output as follows:"
msgstr "对于调试，clang 可以生成汇编器输出如下："

#: ../../bpf.rst:1168 32d8a411d15d4ae3af20252052f21824
msgid ""
"Starting from LLVM's release 6.0, there is also assembler parser support. You can program using BPF assembler "
"directly, then use llvm-mc to assemble it into an object file. For example, you can assemble the xdp-example.S "
"listed above back into object file using:"
msgstr ""
"从 LLVM 的 6.0 版开始，还有汇编器解析器支持。 您可以直接使用 BPF 汇编器进行编程，然后使用 llvm-mc 将其组装成目标"
"文件。 例如，您可以使用以下命令将上面列出的 xdp-example.S 组装回目标文件："

#: ../../bpf.rst:1177 0564d2e728f24003a93e54f9c1ce08bb
msgid ""
"Furthermore, more recent LLVM versions (>= 4.0) can also store debugging information in dwarf format into the "
"object file. This can be done through the usual workflow by adding ``-g`` for compilation."
msgstr ""
"此外，更新的 LLVM 版本 (>= 4.0) 还可以将调试信息以 dwarf 格式存储到目标文件中。 这可以通过通常的工作流程通过添加"
"``-g``进行编译来完成。"

#: ../../bpf.rst:1195 343e4334b1a547e090b0927eaa63e3a9
msgid ""
"The ``llvm-objdump`` tool can then annotate the assembler output with the original C code used in the "
"compilation. The trivial example in this case does not contain much C code, however, the line numbers shown as "
"``0:`` and ``1:`` correspond directly to the kernel's verifier log."
msgstr ""
"``llvm-objdump`` 工具然后可以用编译中使用的原始 C 代码注释汇编器输出。 本例中的简单示例不包含太多 C 代码，但是显"
"示为 ``0:`` 和 ``1:`` 的行号直接对应于内核的验证程序日志。"

#: ../../bpf.rst:1200 8bb85276ed364627b0e580217c711ad0
msgid ""
"This means that in case BPF programs get rejected by the verifier, ``llvm-objdump`` can help to correlate the "
"instructions back to the original C code, which is highly useful for analysis."
msgstr "这意味着如果 BPF 程序被验证器拒绝，llvm-objdump 可以帮助将指令与原始 C 代码相关联，这对于分析非常有用。"

#: ../../bpf.rst:1219 81e2424c2fba4281a063562a518268cb
msgid ""
"As it can be seen in the verifier analysis, the ``llvm-objdump`` output dumps the same BPF assembler code as the "
"kernel."
msgstr "从验证器分析中可以看出，``llvm-objdump`` 输出与内核相同的 BPF 汇编代码相同。"

#: ../../bpf.rst:1222 a0d3a330aa294c8fa7c7df569bed9c71
msgid ""
"Leaving out the ``--no-show-raw-insn`` option will also dump the raw ``struct bpf_insn`` as hex in front of the "
"assembly:"
msgstr "省略 —no-show-raw-insn 选项也会将原始 struct bpf_insn 转储为程序集前面的十六进制："

#: ../../bpf.rst:1238 b9e713a17ba6407fa0077652f98ae507
msgid ""
"For LLVM IR debugging, the compilation process for BPF can be split into two steps, generating a binary LLVM IR "
"intermediate file ``xdp-example.bc``, which can later on be passed to llc:"
msgstr ""
"对于 LLVM IR 调试，BPF 的编译过程可以分为两个步骤，生成二进制 LLVM IR 中间文件“xdp-example.bc”，稍后可以将其传递"
"给 llc："

#: ../../bpf.rst:1247 31e7df23d89d450b8ba137fc70800ad3
msgid "The generated LLVM IR can also be dumped in human readable format through:"
msgstr "生成的 LLVM IR 也可以通过以下方式以人类可读的格式转储："

#: ../../bpf.rst:1253 415fbaec13f64f71a4f0b19a373e04ad
msgid ""
"LLVM is able to attach debug information such as the description of used data types in the program to the "
"generated BPF object file. By default this is in DWARF format."
msgstr ""
"LLVM 能够将调试信息（例如程序中使用的数据类型的描述）附加到生成的 BPF 目标文件中。 默认情况下，这是 DWARF 格式。"

#: ../../bpf.rst:1257 65485873bf0d4caabc7b0045e6919738
msgid ""
"A heavily simplified version used by BPF is called BTF (BPF Type Format). The resulting DWARF can be converted "
"into BTF and is later on loaded into the kernel through BPF object loaders. The kernel will then verify the BTF "
"data for correctness and keeps track of the data types the BTF data is containing."
msgstr ""
"BPF 使用的一个高度简化的版本称为 BTF（BPF 类型格式）。 生成的 DWARF 可以转换为 BTF，然后通过 BPF 对象加载器加载到"
"内核中。 然后内核将验证 BTF 数据的正确性并跟踪 BTF 数据包含的数据类型。"

#: ../../bpf.rst:1262 b33cfccc98d34f5cbfc5365095c30728
msgid ""
"BPF maps can then be annotated with key and value types out of the BTF data such that a later dump of the map "
"exports the map data along with the related type information. This allows for better introspection, debugging "
"and value pretty printing. Note that BTF data is a generic debugging data format and as such any DWARF to BTF "
"converted data can be loaded (e.g. kernel's vmlinux DWARF data could be converted to BTF and loaded). Latter is "
"in particular useful for BPF tracing in the future."
msgstr ""
"然后可以使用 BTF 数据中的键和值类型对 BPF 映射进行注释，以便稍后的映射转储导出映射数据以及相关的类型信息。 这允许"
"更好的自省、调试和价值漂亮的打印。 请注意，BTF 数据是一种通用调试数据格式，因此可以加载任何 DWARF 到 BTF 转换的数"
"据（例如，内核的 vmlinux DWARF 数据可以转换为 BTF 并加载）。 后者对于将来的 BPF 跟踪特别有用。"

#: ../../bpf.rst:1270 b82106a0f84c45cd87e136bb85d782e1
msgid ""
"In order to generate BTF from DWARF debugging information, elfutils (>= 0.173) is needed. If that is not "
"available, then adding the ``-mattr=dwarfris`` option to the ``llc`` command is required during compilation:"
msgstr ""
"为了从 DWARF 调试信息生成 BTF，需要 elfutils (>= 0.173)。 如果这不可用，则需要在编译期间将 ``-mattr=dwarfris`` 选"
"项添加到 ``llc`` 命令中："

#: ../../bpf.rst:1280 68ddf39fc996466284a612a95d1b9e0a
msgid ""
"The reason using ``-mattr=dwarfris`` is because the flag ``dwarfris`` (``dwarf relocation in section``) disables "
"DWARF cross-section relocations between DWARF and the ELF's symbol table since libdw does not have proper BPF "
"relocation support, and therefore tools like ``pahole`` would otherwise not be able to properly dump structures "
"from the object."
msgstr ""
"使用``-mattr=dwarfris`` 的原因是因为 ``dwarfris`` 标志（``dwarf relocation in section``）禁用了 DWARF 和 ELF 的符"
"号表之间的 DWARF cross-section 重定位，因为 libdw 不支持 BPF 重定位。不打开这个选项的话，``pahole`` 这类工具将无"
"法正确地从对象中 dump 结构。"

#: ../../bpf.rst:1286 ee9be223085a4c2abeb5ddafa6b32d86
msgid ""
"elfutils (>= 0.173) implements proper BPF relocation support and therefore the same can be achieved without the "
"``-mattr=dwarfris`` option. Dumping the structures from the object file could be done from either DWARF or BTF "
"information. ``pahole`` uses the LLVM emitted DWARF information at this point, however, future ``pahole`` "
"versions could rely on BTF if available."
msgstr ""
"elfutils (>= 0.173) 实现了正确的 BPF 重定位支持，因此在没有 -mattr=dwarfris 选项的情况下也可以实现相同的功能。 从"
"目标文件中转储结构可以通过 DWARF 或 BTF 信息来完成。 ``pahole`` 此时使用 LLVM 发出的 DWARF 信息，但是未来的"
"``pahole`` 版本可能会依赖 BTF。"

#: ../../bpf.rst:1292 74fa55fd50bc4682bf9c330dc2ee7797
msgid ""
"For converting DWARF into BTF, a recent pahole version (>= 1.12) is required. A recent pahole version can also "
"be obtained from its official git repository if not available from one of the distribution packages:"
msgstr ""
"要将 DWARF 转换为 BTF，需要最新的 pahole 版本 (>= 1.12)。 如果无法从其中一个分发包中获得最新的 pahole 版本，也可"
"以从其官方 git 存储库获得："

#: ../../bpf.rst:1300 ddd062cc808b475997aa6ab885e8bf4d
msgid ""
"``pahole`` comes with the option ``-J`` to convert DWARF into BTF from an object file. ``pahole`` can be probed "
"for BTF support as follows (note that the ``llvm-objcopy`` tool is required for ``pahole`` as well, so check its "
"presence, too):"
msgstr ""
"``pahole`` 带有选项``-J`` 以将 DWARF 从目标文件转换为 BTF。 ``pahole`` 可以按如下方式探测 BTF 支持（请注意，"
"``pahole`` 也需要``llvm-objcopy`` 工具，因此也要检查它的存在）："

#: ../../bpf.rst:1310 b21952048c1e4362bb2d40fba63e3df5
msgid ""
"Generating debugging information also requires the front end to generate source level debug information by "
"passing ``-g`` to the ``clang`` command line. Note that ``-g`` is needed independently of whether ``llc``'s "
"``dwarfris`` option is used. Full example for generating the object file:"
msgstr ""
"生成调试信息还需要前端通过将“-g”传递给“clang”命令行来生成源级调试信息。 请注意，无论是否使用了 llc 的 dwarfris 选"
"项，都需要 -g。 生成目标文件的完整示例："

#: ../../bpf.rst:1320 439ad6a2fd4f4a3082932ab66ea78cc6
msgid ""
"Alternatively, by using clang only to build a BPF program with debugging information (again, the dwarfris flag "
"can be omitted when having proper elfutils version):"
msgstr ""
"或者通过仅使用 clang 构建带有调试信息的 BPF 程序（同样，当具有正确的 elfutils 版本时，可以省略 dwarfris 标志）："

#: ../../bpf.rst:1328 b133e44d8e9d45dabeee7e0a7e8580f2
msgid ""
"After successful compilation ``pahole`` can be used to properly dump structures of the BPF program based on the "
"DWARF information:"
msgstr "编译成功后，``pahole`` 可用于根据 DWARF 信息正确转储 BPF 程序的结构："

#: ../../bpf.rst:1343 3c8256412dae457b8df89b5ccb55053f
msgid ""
"Through the option ``-J`` ``pahole`` can eventually generate the BTF from DWARF. In the object file DWARF data "
"will still be retained alongside the newly added BTF data. Full ``clang`` and ``pahole`` example combined:"
msgstr ""
"通过选项 ``-J`` ``pahole`` 最终可以从 DWARF 生成 BTF。 在对象文件中，DWARF 数据仍将与新添加的 BTF 数据一起保留。 "
"完整的``clang``和``pahole``示例组合："

#: ../../bpf.rst:1352 5fa41688ee6a469cba72883fd6cb926a
msgid "The presence of a ``.BTF`` section can be seen through ``readelf`` tool:"
msgstr "可以通过``readelf``工具看到``.BTF``部分的存在："

#: ../../bpf.rst:1361 19b0178b727e42fbac198a10dcaac2ce
msgid ""
"BPF loaders such as iproute2 will detect and load the BTF section, so that BPF maps can be annotated with type "
"information."
msgstr "因为 iproute2 等 BPF 加载器将检测并加载 BTF 部分，以便 BPF 映射可以使用类型信息进行注释。"

#: ../../bpf.rst:1364 60af1fb086eb4d5280507db0af2d500b
msgid ""
"LLVM by default uses the BPF base instruction set for generating code in order to make sure that the generated "
"object file can also be loaded with older kernels such as long-term stable kernels (e.g. 4.9+)."
msgstr ""
"LLVM 默认使用 BPF 基本指令集来生成代码，以确保生成的目标文件也可以加载旧内核，例如长期稳定的内核（例如 4.9+）。"

#: ../../bpf.rst:1368 c5e9f847d19f4415965f0e45a61f5d66
msgid ""
"However, LLVM has a ``-mcpu`` selector for the BPF back end in order to select different versions of the BPF "
"instruction set, namely instruction set extensions on top of the BPF base instruction set in order to generate "
"more efficient and smaller code."
msgstr ""
"但是，LLVM 有一个用于 BPF 后端的``-mcpu``选择器，以便选择不同版本的 BPF 指令集，即在 BPF 基本指令集之上的指令集扩"
"展，以便生成更高效和更小的代码 ."

#: ../../bpf.rst:1373 87842a7cc07e4d2395213ebe4dd2ccb3
msgid "Available ``-mcpu`` options can be queried through:"
msgstr "可以通过以下方式查询可用的``-mcpu``选项："

#: ../../bpf.rst:1386 e9199cdadeee4f31a632ab0e4e4ad64f
msgid ""
"The ``generic`` processor is the default processor, which is also the base instruction set ``v1`` of BPF. "
"Options ``v1`` and ``v2`` are typically useful in an environment where the BPF program is being cross compiled "
"and the target host where the program is loaded differs from the one where it is compiled (and thus available "
"BPF kernel features might differ as well)."
msgstr ""
"``generic`` 处理器是默认处理器，也是 BPF 的基本指令集``v1``。 选项 ``v1`` 和 ``v2`` 通常在 BPF 程序被交叉编译并且"
"加载程序的目标主机与编译的目标主机不同的环境中很有用(（因此可用的 BPF 内核特性也可能不同）。"

#: ../../bpf.rst:1393 ae286ac68614464bbca830b78565ee30
msgid ""
"The recommended ``-mcpu`` option which is also used by Cilium internally is ``-mcpu=probe``! Here, the LLVM BPF "
"back end queries the kernel for availability of BPF instruction set extensions and when found available, LLVM "
"will use them for compiling the BPF program whenever appropriate."
msgstr ""
"Cilium 内部也使用推荐的 ``-mcpu`` 选项是 ``-mcpu=probe``! 在这里，LLVM BPF 后端向内核查询 BPF 指令集扩展的可用"
"性，当发现可用时，LLVM 将在适当的时候使用它们来编译 BPF 程序。"

#: ../../bpf.rst:1398 52371d57369641469d249eb319611066
msgid "A full command line example with llc's ``-mcpu=probe``:"
msgstr "带有 llc 的 ``-mcpu=probe`` 的完整命令行示例："

#: ../../bpf.rst:1405 0bb366af6b7d498596424c1f75dc825a
msgid ""
"Generally, LLVM IR generation is architecture independent. There are however a few differences when using "
"``clang -target bpf`` versus leaving ``-target bpf`` out and thus using clang's default target which, depending "
"on the underlying architecture, might be ``x86_64``, ``arm64`` or others."
msgstr ""
"通常，LLVM IR 生成与架构无关。 然而当使用``clang -target bpf`` 与不使用``-target bpf`` 并因此使用 clang 的默认目"
"标时存在一些差异，这取决于底层架构，可能是 ``x86_64``、`` arm64`` 或其他。"

#: ../../bpf.rst:1411 eb9589f3f37241ab9304ac87079d82f0
msgid "Quoting from the kernel's ``Documentation/bpf/bpf_devel_QA.txt``:"
msgstr "引用内核的``Documentation/bpf/bpf_devel_QA.txt``："

#: ../../bpf.rst:1413 ec065dc696f94ab296ee257570fccec2
msgid ""
"BPF programs may recursively include header file(s) with file scope inline assembly codes. The default target "
"can handle this well, while bpf target may fail if bpf backend assembler does not understand these assembly "
"codes, which is true in most cases."
msgstr ""
"BPF 程序可以递归地包含带有文件范围内联汇编代码的头文件。 默认目标可以很好地处理这个问题，而如果 bpf 后端汇编器不"
"理解这些汇编代码，则 bpf 目标可能会失败，这在大多数情况下是正确的。"

#: ../../bpf.rst:1418 d513e947af74445da70a72fca2067171
msgid ""
"When compiled without -g, additional elf sections, e.g., ``.eh_frame`` and ``.rela.eh_frame``, may be present in "
"the object file with default target, but not with bpf target."
msgstr ""
"当不使用 -g 编译时，附加的 elf 部分，例如 ``.eh_frame`` 和 ``.rela.eh_frame``，可能会出现在具有默认目标的目标文件"
"中，但不会出现在 bpf 目标中。"

#: ../../bpf.rst:1422 6f9747a7f69847f984c2e7fb99c8be9f
msgid ""
"The default target may turn a C switch statement into a switch table lookup and jump operation. Since the switch "
"table is placed in the global read-only section, the bpf program will fail to load. The bpf target does not "
"support switch table optimization. The clang option ``-fno-jump-tables`` can be used to disable switch table "
"generation."
msgstr ""
"默认目标可能会将 C switch 语句转换为 switch 表查找和跳转操作。 由于切换表放在全局只读部分，bpf程序将无法加载。 "
"bpf 目标不支持切换表优化。 clang 选项 ``-fno-jump-tables`` 可用于禁用切换表生成。"

#: ../../bpf.rst:1429 eac5d9270c17463a9cb68c2e062b20f2
msgid ""
"For clang ``-target bpf``, it is guaranteed that pointer or long / unsigned long types will always have a width "
"of 64 bit, no matter whether underlying clang binary or default target (or kernel) is 32 bit. However, when "
"native clang target is used, then it will compile these types based on the underlying architecture's "
"conventions, meaning in case of 32 bit architecture, pointer or long / unsigned long types e.g. in BPF context "
"structure will have width of 32 bit while the BPF LLVM back end still operates in 64 bit."
msgstr ""
"对于 clang ``-target bpf``，保证指针或 long / unsigned long 类型将始终具有 64 位的宽度，无论底层 clang 二进制或默"
"认目标（或内核）是 32 位。 但是当使用原生 clang 目标时，它将根据底层架构的约定编译这些类型，这意味着在 32 位架构"
"的情况下，指针或 long / unsigned long 类型的情况在 BPF 上下文结构中，宽度为 32 位，而 BPF LLVM 后端仍以 64 位运"
"行。"

#: ../../bpf.rst:1438 89477bf4f3294796859404f20741d83d
msgid ""
"The native target is mostly needed in tracing for the case of walking the kernel's ``struct pt_regs`` that maps "
"CPU registers, or other kernel structures where CPU's register width matters. In all other cases such as "
"networking, the use of ``clang -target bpf`` is the preferred choice."
msgstr ""
"本机目标主要用于跟踪遍历内核的``struct pt_regs``（映射 CPU 寄存器）或其他 CPU 寄存器宽度很重要的内核结构的情况。 "
"在所有其他情况下，例如网络，使用 ``clang -target bpf`` 是首选。"

#: ../../bpf.rst:1443 c900309cd3f24da59b1260fc3cf91262
msgid ""
"Also, LLVM started to support 32-bit subregisters and BPF ALU32 instructions since LLVM's release 7.0. A new "
"code generation attribute ``alu32`` is added. When it is enabled, LLVM will try to use 32-bit subregisters "
"whenever possible, typically when there are operations on 32-bit types. The associated ALU instructions with 32-"
"bit subregisters will become ALU32 instructions. For example, for the following sample code:"
msgstr ""
"此外，自 LLVM 7.0 版以来，LLVM 开始支持 32 位子寄存器和 BPF ALU32 指令并添加了一个新的代码生成属性``alu32``。 启"
"用后，LLVM 将尽可能尝试使用 32 位子寄存器，通常是在对 32 位类型进行操作时，与 32 位子寄存器相关的 ALU 指令将成为 "
"ALU32 指令。 例如，对于以下示例代码："

#: ../../bpf.rst:1459 b879dddf5877472da461bddf7ab576ad
msgid "At default code generation, the assembler will looks like:"
msgstr "在默认代码生成时，汇编器将如下所示："

#: ../../bpf.rst:1473 792a1ee7f8784b279bd9146c376bbe5c
msgid ""
"64-bit registers are used, hence the addition means 64-bit addition. Now, if you enable the new 32-bit "
"subregisters support by specifying ``-mattr=+alu32``, then the assembler will looks like:"
msgstr ""
"使用 64 位寄存器，因此加法意味着所有的加法都是 64 位加法。 现在如果您通过指定 ``-mattr=+alu32`` 启用新的 32 位子"
"寄存器支持，那么汇编器将如下所示："

#: ../../bpf.rst:1488 a0b01e0a4a634b039b1b800fcbbb2c64
msgid "``w`` register, meaning 32-bit subregister, will be used instead of 64-bit ``r`` register."
msgstr "``w`` 寄存器，意思是 32 位子寄存器，将被用来代替 64 位 ``r`` 寄存器。"

#: ../../bpf.rst:1491 5722f8bcd4b243cfae739270c51c6231
msgid ""
"Enable 32-bit subregisters might help reducing type extension instruction sequences. It could also help kernel "
"eBPF JIT compiler for 32-bit architectures for which registers pairs are used to model the 64-bit eBPF registers "
"and extra instructions are needed for manipulating the high 32-bit. Given read from 32-bit subregister is "
"guaranteed to read from low 32-bit only even though write still needs to clear the high 32-bit, if the JIT "
"compiler has known the definition of one register only has subregister reads, then instructions for setting the "
"high 32-bit of the destination could be eliminated."
msgstr ""
"启用 32 位子寄存器可能有助于减少类型扩展指令序列。 它还可以帮助内核 eBPF JIT 编译器用于 32 位架构，其中寄存器对用"
"于对 64 位 eBPF 寄存器进行建模，并且需要额外的指令来操作高 32 位。使写 32 位子寄存器的操作仍然需要对高 32 位清"
"零，但只要确保从 32 位 子寄存器的读操作只会读取低 32 位，那只要 JIT 编译器已经知道某个寄存器的定义只有 子寄存器读"
"操作，那对高 32 位的操作指令就可以避免。"

#: ../../bpf.rst:1500 60510bb3b4104fbf9c183d94bffe7ca5
msgid ""
"When writing C programs for BPF, there are a couple of pitfalls to be aware of, compared to usual application "
"development with C. The following items describe some of the differences for the BPF model:"
msgstr ""
"在为 BPF 编写 C 程序时，与使用 C 进行通常的应用程序开发相比，有几个陷阱需要注意。以下项目描述了 BPF 模型的一些差"
"异："

#: ../../bpf.rst:1504 afb1289c249f437b8cbd3b2b337f2354
msgid ""
"**Everything needs to be inlined, there are no function calls (on older LLVM versions) or shared library calls "
"available.**"
msgstr "**所有内容都需要内联，没有函数调用（在旧 LLVM 版本上）或共享库调用可用。**"

#: ../../bpf.rst:1507 377c04e5fa514742bef7d07490ef564d
msgid ""
"Shared libraries, etc cannot be used with BPF. However, common library code used in BPF programs can be placed "
"into header files and included in the main programs. For example, Cilium makes heavy use of it (see ``bpf/lib/"
"``). However, this still allows for including header files, for example, from the kernel or other libraries and "
"reuse their static inline functions or macros / definitions."
msgstr ""
"共享库等不能与 BPF 一起使用。 但是BPF 程序中使用的通用库代码可以放在头文件中并包含在主程序中。 例如，Cilium 大量"
"使用了这类共享库（参见 ``bpf/lib/``）。 但是这仍然允许包含例如来自内核或其他库的头文件，并重用它们的静态内联函数"
"或宏/定义。"

#: ../../bpf.rst:1514 0b7315f49b8e45be9eb97452f1c26163
msgid ""
"Unless a recent kernel (4.16+) and LLVM (6.0+) is used where BPF to BPF function calls are supported, then LLVM "
"needs to compile and inline the entire code into a flat sequence of BPF instructions for a given program "
"section. In such case, best practice is to use an annotation like ``__inline`` for every library function as "
"shown below. The use of ``always_inline`` is recommended, since the compiler could still decide to uninline "
"large functions that are only annotated as ``inline``."
msgstr ""
"除非在支持 BPF 到 BPF 函数调用的情况下使用最新的内核（4.16+）和 LLVM（6.0+），否则 LLVM 需要将整个代码编译并内联"
"到给定程序部分的 BPF 指令的平面序列中。 在这种情况下，最佳实践是为每个库函数使用类似 ``__inline`` 的注释，如下所"
"示。 建议使用``always_inline``，因为编译器仍然可以决定取消内联仅注释为``内联``的长函数。"

#: ../../bpf.rst:1522 f025b482eeff4ddab6790bff8267197c
msgid ""
"In case the latter happens, LLVM will generate a relocation entry into the ELF file, which BPF ELF loaders such "
"as iproute2 cannot resolve and will thus produce an error since only BPF maps are valid relocation entries which "
"loaders can process."
msgstr ""
"如果发生后者，LLVM 将在 ELF 文件中生成一个重定位条目，而 BPF ELF 加载器（如 iproute2）无法解析，因此会产生错误，"
"因为只有 BPF 映射是加载器可以处理的有效重定位条目。"

#: ../../bpf.rst:1554 96d57f39f57042c8b0691c9163b288fb
msgid "**Multiple programs can reside inside a single C file in different sections.**"
msgstr "**多个程序可以放在不同部分的单个 C 文件中。**"

#: ../../bpf.rst:1556 2ea83ddae4b74f559e82e3730e1f3a05
msgid ""
"C programs for BPF make heavy use of section annotations. A C file is typically structured into 3 or more "
"sections. BPF ELF loaders use these names to extract and prepare the relevant information in order to load the "
"programs and maps through the bpf system call. For example, iproute2 uses ``maps`` and ``license`` as default "
"section name to find metadata needed for map creation and the license for the BPF program, respectively. On "
"program creation time the latter is pushed into the kernel as well, and enables some of the helper functions "
"which are exposed as GPL only in case the program also holds a GPL compatible license, for example "
"``bpf_ktime_get_ns()``, ``bpf_probe_read()`` and others."
msgstr ""
"BPF 的 C 程序大量使用节注释。 一个 C 文件通常分为 3 个或更多部分。 BPF ELF 加载器使用这些名称来提取和准备相关信"
"息，以便通过 bpf 系统调用加载程序和映射。 例如 iproute2 使用``maps``和``license``作为默认部分名称来分别查找创建映"
"射所需的元数据和 BPF 程序的许可证。 在程序创建时，后者也被推送到内核中，并启用一些仅在程序还持有 GPL 兼容许可证的"
"情况下作为 GPL 的辅助函数，例如 ``bpf_ktime_get_ns()``、`` bpf_probe_read()`` 等。"

#: ../../bpf.rst:1567 b627d55eed44448a90a211771f25dd99
msgid ""
"The remaining section names are specific for BPF program code, for example, the below code has been modified to "
"contain two program sections, ``ingress`` and ``egress``. The toy example code demonstrates that both can share "
"a map and common static inline helpers such as the ``account_data()`` function."
msgstr ""
"其余部分名称是特定于 BPF 程序代码的，例如，下面的代码已被修改为包含两个程序部分，``ingress``和``egress``。 示例代"
"码演示了两者都可以共享映射和常见的静态内联帮助器，例如 ``account_data()`` 函数。"

#: ../../bpf.rst:1572 7a306039f4064423a00f42a77d462ae7
msgid ""
"The ``xdp-example.c`` example has been modified to a ``tc-example.c`` example that can be loaded with tc and "
"attached to a netdevice's ingress and egress hook.  It accounts the transferred bytes into a map called "
"``acc_map``, which has two map slots, one for traffic accounted on the ingress hook, one on the egress hook."
msgstr ""
"``xdp-example.c`` 示例已修改为 ``tc-example.c`` 示例，可以使用 tc 加载并附加到网络设备的入口和出口hook。 它将传输"
"的字节记入一个名为``acc_map``的映射中，该映射有两个映射槽，一个用于入口hook上的流量统计，一个用于出口hook上的。"

#: ../../bpf.rst:1640 d8ed5bc955104ca0a64581f46f050de2
msgid ""
"The example also demonstrates a couple of other things which are useful to be aware of when developing programs. "
"The code includes kernel headers, standard C headers and an iproute2 specific header containing the definition "
"of ``struct bpf_elf_map``. iproute2 has a common BPF ELF loader and as such the definition of ``struct "
"bpf_elf_map`` is the very same for XDP and tc typed programs."
msgstr ""
"该示例还演示了在开发程序时需要注意的其他一些有用的事情。 该代码包括内核头文件、标准 C 头文件和一个 iproute2 特定"
"头文件，其中包含``struct bpf_elf_map``的定义。 iproute2 有一个通用的 BPF ELF 加载器，因此 ``struct bpf_elf_map`` "
"的定义对于 XDP 和 tc 类型的程序是相同的。"

#: ../../bpf.rst:1647 151f95d6eec4401f89905db0bd8eb713
msgid ""
"A ``struct bpf_elf_map`` entry defines a map in the program and contains all relevant information (such as key / "
"value size, etc) needed to generate a map which is used from the two BPF programs. The structure must be placed "
"into the ``maps`` section, so that the loader can find it. There can be multiple map declarations of this type "
"with different variable names, but all must be annotated with ``__section(\"maps\")``."
msgstr ""
"``struct bpf_elf_map`` 条目在程序中定义了一个映射，并包含生成从两个 BPF 程序使用的映射所需的所有相关信息（例如键/"
"值大小等）。 该结构必须放在``maps`` 部分，以便加载器可以找到它。 这种类型的映射声明可以有多个不同的变量名，但都必"
"须用 __section(``maps``) 注释。"

#: ../../bpf.rst:1654 c1bd0d57dbf0462da792371d727953eb
msgid ""
"The ``struct bpf_elf_map`` is specific to iproute2. Different BPF ELF loaders can have different formats, for "
"example, the libbpf in the kernel source tree, which is mainly used by ``perf``, has a different specification. "
"iproute2 guarantees backwards compatibility for ``struct bpf_elf_map``. Cilium follows the iproute2 model."
msgstr ""
"``struct bpf_elf_map`` 特定于 iproute2。 不同的 BPF ELF 加载器可以有不同的格式，例如内核源代码树中的 libbpf，主要"
"由 ``perf`` 使用，具有不同的规范。  Cilium 遵循 iproute2 模型，因为iproute2 保证 struct bpf_elf_map 的向后兼容"
"性。"

#: ../../bpf.rst:1660 34d6efa90abb444f9eda7419d7aa5bd4
msgid ""
"The example also demonstrates how BPF helper functions are mapped into the C code and being used. Here, "
"``map_lookup_elem()`` is defined by mapping this function into the ``BPF_FUNC_map_lookup_elem`` enum value which "
"is exposed as a helper in ``uapi/linux/bpf.h``. When the program is later loaded into the kernel, the verifier "
"checks whether the passed arguments are of the expected type and re-points the helper call into a real function "
"call. Moreover, ``map_lookup_elem()`` also demonstrates how maps can be passed to BPF helper functions. Here, "
"``&acc_map`` from the ``maps`` section is passed as the first argument to ``map_lookup_elem()``."
msgstr ""
"该示例还演示了 BPF 辅助函数如何映射到 C 代码中并被使用。 在这里，``map_lookup_elem()``是通过将此函数映射到"
"``BPF_FUNC_map_lookup_elem``枚举值来定义的，该枚举值在``uapi/linux/bpf.h``中作为帮助程序公开。 当程序稍后加载到内"
"核中时，验证器检查传递的参数是否是预期的类型，并将帮助程序调用重新指向真正的函数调用。 此外，"
"``map_lookup_elem()``还演示了如何将映射传递给 BPF 辅助函数。 在这里，来自 ``maps`` 部分的 ``&acc_map`` 作为第一个"
"参数传递给 ``map_lookup_elem()``。"

#: ../../bpf.rst:1670 c61ae16a0210466ebbe32d6aa10923ec
msgid ""
"Since the defined array map is global, the accounting needs to use an atomic operation, which is defined as "
"``lock_xadd()``. LLVM maps ``__sync_fetch_and_add()`` as a built-in function to the BPF atomic add instruction, "
"that is, ``BPF_STX | BPF_XADD | BPF_W`` for word sizes."
msgstr ""
"由于定义的数组映射是全局的，计数需要使用原子操作，定义为``lock_xadd()``。 LLVM 将``__sync_fetch_and_add()`` 作为"
"内置函数映射到 BPF 原子添加指令，即``BPF_STX | BPF_XADD | BPF_W`` 用于字长。"

#: ../../bpf.rst:1675 ba5bc81f95b04596977318a58c7ab5ec
msgid ""
"Last but not least, the ``struct bpf_elf_map`` tells that the map is to be pinned as ``PIN_GLOBAL_NS``. This "
"means that tc will pin the map into the BPF pseudo file system as a node. By default, it will be pinned to ``/"
"sys/fs/bpf/tc/globals/acc_map`` for the given example. Due to the ``PIN_GLOBAL_NS``, the map will be placed "
"under ``/sys/fs/bpf/tc/globals/``. ``globals`` acts as a global namespace that spans across object files. If the "
"example used ``PIN_OBJECT_NS``, then tc would create a directory that is local to the object file. For example, "
"different C files with BPF code could have the same ``acc_map`` definition as above with a ``PIN_GLOBAL_NS`` "
"pinning. In that case, the map will be shared among BPF programs originating from various object files. "
"``PIN_NONE`` would mean that the map is not placed into the BPF file system as a node, and as a result will not "
"be accessible from user space after tc quits. It would also mean that tc creates two separate map instances for "
"each program, since it cannot retrieve a previously pinned map under that name. The ``acc_map`` part from the "
"mentioned path is the name of the map as specified in the source code."
msgstr ""
"最后，``struct bpf_elf_map`` 告诉映射将被固定为``PIN_GLOBAL_NS``。这意味着 tc 会将映射作为节点固定到 BPF 伪文件系"
"统中。默认情况下，对于给定的示例，它将被固定到 /sys/fs/bpf/tc/globals/acc_map 。由于``PIN_GLOBAL_NS``，映射将被放"
"置在``/sys/fs/bpf/tc/globals/``下。 ``globals`` 充当跨对象文件的全局命名空间。如果该示例使用 ``PIN_OBJECT_NS``，"
"则 tc 将创建目标文件的本地目录。例如，具有 BPF 代码的不同 C 文件可能具有与上面相同的 ``acc_map`` 定义，并带有 "
"``PIN_GLOBAL_NS`` 固定。在这种情况下，映射将在源自各种目标文件的 BPF 程序之间共享。 ``PIN_NONE`` 意味着该映射不作"
"为节点放入 BPF 文件系统中，因此在 tc 退出后将无法从用户空间访问。这也意味着 tc 为每个程序创建两个单独的地图实例，"
"因为它无法检索以前以该名称固定的映射。上述路径中的``acc_map``部分是源代码中指定的映射名称。"

#: ../../bpf.rst:1693 732936a94c094afa806b661193ea089a
msgid ""
"Thus, upon loading of the ``ingress`` program, tc will find that no such map exists in the BPF file system and "
"creates a new one. On success, the map will also be pinned, so that when the ``egress`` program is loaded "
"through tc, it will find that such map already exists in the BPF file system and will reuse that for the "
"``egress`` program. The loader also makes sure in case maps exist with the same name that also their properties "
"(key / value size, etc) match."
msgstr ""
"因此，在加载 ``ingress`` 程序时，tc 会先查找这个映射 在 BPF 文件系统中是否存在，不存在就创建一个。创建成功后，映"
"射会被固定到 BPF 文件系统，因此当 ``egress`` 程序通过 tc 加载之后，它就会发现这个映射存在了，接下来会复用这个映射"
"而不是再创建 一个新的。在映射存在的情况下，加载器还会确保映射的属性（properties）是匹配的， 例如 key/value 大小等"
"等。"

#: ../../bpf.rst:1701 b4433ce54bcd4525a67ebeb5aec084fa
msgid ""
"Just like tc can retrieve the same map, also third party applications can use the ``BPF_OBJ_GET`` command from "
"the bpf system call in order to create a new file descriptor pointing to the same map instance, which can then "
"be used to lookup / update / delete map elements."
msgstr ""
"就像 tc 可以检索相同的映射一样，第三方应用程序也可以使用 bpf 系统调用中的``BPF_OBJ_GET``命令来创建指向同一映射实"
"例的新文件描述符，然后可以使用该文件描述符来查找 / 更新/删除映射元素。"

#: ../../bpf.rst:1706 88d9c3b57f894977adaaf13a53fa3457
msgid "The code can be compiled and loaded via iproute2 as follows:"
msgstr "代码可以通过iproute2编译加载，如下："

#: ../../bpf.rst:1738 3c8ed339a92f453f8e1e5636563a6456
msgid "As soon as packets pass the ``em1`` device, counters from the BPF map will be increased."
msgstr "一旦数据包通过``em1``设备，BPF 映射中的计数器就会增加。"

#: ../../bpf.rst:1741 eb2e7ea6965049259ab690a5772d8199
msgid "**There are no global variables allowed.**"
msgstr "**不允许使用全局变量。**"

#: ../../bpf.rst:1743 ffa793ad681c4d83881dd2952db43381
msgid ""
"For the reasons already mentioned in point 1, BPF cannot have global variables as often used in normal C "
"programs."
msgstr "由于第 1 点中已经提到的原因，BPF 不能像普通 C 程序中经常使用全局变量。"

#: ../../bpf.rst:1746 a5933e40c2d5447696962dbd427e3490
msgid ""
"However, there is a work-around in that the program can simply use a BPF map of type "
"``BPF_MAP_TYPE_PERCPU_ARRAY`` with just a single slot of arbitrary value size. This works, because during "
"execution, BPF programs are guaranteed to never get preempted by the kernel and therefore can use the single map "
"entry as a scratch buffer for temporary data, for example, to extend beyond the stack limitation. This also "
"functions across tail calls, since it has the same guarantees with regards to preemption."
msgstr ""
"然而，有一个变通方法，程序可以简单地使用类型为``BPF_MAP_TYPE_PERCPU_ARRAY``的 BPF 映射，只需一个任意值大小的插"
"槽。 因为在执行期间，BPF 程序保证永远不会被内核抢占，因此可以使用单个映射条目作为临时数据的暂存缓冲区。例如扩展堆"
"栈限制。 这也适用于尾调用，因为它在抢占方面具有相同的保证。"

#: ../../bpf.rst:1754 4c38b5990c3742e58a5bd32236bb51cb
msgid "Otherwise, for holding state across multiple BPF program runs, normal BPF maps can be used."
msgstr "否则，为了在多个 BPF 程序运行中保持状态，可以使用普通的 BPF 映射。"

#: ../../bpf.rst:1757 30f22a234b1647e49d248d6b69a05680
msgid "**There are no const strings or arrays allowed.**"
msgstr "**不允许使用 const 字符串或数组。**"

#: ../../bpf.rst:1759 d3b8ba6f215d4f25a37f61e73e73d78a
msgid ""
"Defining ``const`` strings or other arrays in the BPF C program does not work for the same reasons as pointed "
"out in sections 1 and 3, which is, that relocation entries will be generated in the ELF file which will be "
"rejected by loaders due to not being part of the ABI towards loaders (loaders also cannot fix up such entries as "
"it would require large rewrites of the already compiled BPF sequence)."
msgstr ""
"在 BPF C 程序中定义``const``字符串或其他数组不起作用，原因与第 1 节和第 3 节中指出的相同，即，重定位条目将在 ELF "
"文件中生成，这些条目将由于不是面向加载器的 ABI 的一部分（加载器也无法修复此类条目，因为它需要对已编译的 BPF 序列"
"进行大量重写）被加载器拒绝 。"

#: ../../bpf.rst:1765 ea6d9e6e58ef4a4ba5606f0e8b499746
msgid "In the future, LLVM might detect these occurrences and early throw an error to the user."
msgstr "将来，LLVM 可能会检测到这些事件并提前向用户抛出错误。"

#: ../../bpf.rst:1768 b58c2c99bf5a4556a8935062ffdaba60
msgid "Helper functions such as ``trace_printk()`` can be worked around as follows:"
msgstr "如``trace_printk()``之类的辅助函数可以按如下方式工作："

#: ../../bpf.rst:1782 480f63a1cc3247cfabe710572e63142a
#, python-format
msgid ""
"The program can then use the macro naturally like ``printk(\"skb len:%u\\n\", skb->len);``. The output will then "
"be written to the trace pipe. ``tc exec bpf dbg`` can be used to retrieve the messages from there."
msgstr ""
"然后程序可以自然地使用宏，如 ``printk(“skb len:%u\\n”, skb->len);``， 然后将输出写入跟踪管道。 例如``tc exec bpf "
"dbg`` 可用于从那里检索消息。"

#: ../../bpf.rst:1786 02d7eee312604ed69c8f64cc9a68a493
#, python-format
msgid ""
"The use of the ``trace_printk()`` helper function has a couple of disadvantages and thus is not recommended for "
"production usage. Constant strings like the ``\"skb len:%u\\n\"`` need to be loaded into the BPF stack each time "
"the helper function is called, but also BPF helper functions are limited to a maximum of 5 arguments. This "
"leaves room for only 3 additional variables which can be passed for dumping."
msgstr ""
"``trace_printk()`` 辅助函数的使用有几个缺点，因此不建议用于生产用途。 每次调用辅助函数时，都需要将诸如``”skb len:"
"%u\\n”``之类的常量字符串加载到 BPF 堆栈中，但 BPF 辅助函数也被限制为最多 5 个参数。 这为仅可传递转储的 3 个附加变"
"量留下空间。"

#: ../../bpf.rst:1793 0c5645216df741cc93c5fa40f9e552be
msgid ""
"Therefore, despite being helpful for quick debugging, it is recommended (for networking programs) to use the "
"``skb_event_output()`` or the ``xdp_event_output()`` helper, respectively. They allow for passing custom structs "
"from the BPF program to the perf event ring buffer along with an optional packet sample. For example, Cilium's "
"monitor makes use of these helpers in order to implement a debugging framework, notifications for network policy "
"violations, etc. These helpers pass the data through a lockless memory mapped per-CPU ``perf`` ring buffer, and "
"is thus significantly faster than ``trace_printk()``."
msgstr ""
"因此，尽管有助于快速调试，但建议（对于网络程序）分别使用 ``skb_event_output()`` 或 ``xdp_event_output()`` 辅助函"
"数。 它们允许将自定义结构从 BPF 程序传递到 perf 事件环缓冲区以及可选的数据包样本。 例如，Cilium 的监视器使用这些"
"辅助函数来实现调试框架、网络策略违规通知等。这些辅助函数通过无锁内存映射的 per-CPU ``perf`` 环形缓冲区传递数据，"
"因此明显快于“trace_printk()”。"

#: ../../bpf.rst:1802 fa980cc73dfe45ebaabdd0a1347234c3
msgid "**Use of LLVM built-in functions for memset()/memcpy()/memmove()/memcmp().**"
msgstr "**对 memset()/memcpy()/memmove()/memcmp() 使用 LLVM 内置函数。**"

#: ../../bpf.rst:1804 8870efffe011463ebe595febbd043554
msgid ""
"Since BPF programs cannot perform any function calls other than those to BPF helpers, common library code needs "
"to be implemented as inline functions. In addition, also LLVM provides some built-ins that the programs can use "
"for constant sizes (here: ``n``) which will then always get inlined:"
msgstr ""
"由于 BPF 程序除了对 BPF 辅助函数进行调用之外，不能执行任何函数调用，因此需要将公共库代码实现为内联函数。 此外，"
"LLVM 还提供了一些内置程序可用于固定大小（此处为：``n``），它们将始终被内联："

#: ../../bpf.rst:1823 cec623e8354f4e75948ec744c1799fc2
msgid ""
"The ``memcmp()`` built-in had some corner cases where inlining did not take place due to an LLVM issue in the "
"back end, and is therefore not recommended to be used until the issue is fixed."
msgstr "``memcmp()`` 内置有一些极端情况，由于后端的 LLVM 问题无法进行内联，因此在问题得到解决之前不建议使用。"

#: ../../bpf.rst:1827 e0cdfdbb21934c608c5cbb7d1dcfb9de
msgid "**There are no loops available (yet).**"
msgstr "**暂时没有可用的循环。**"

#: ../../bpf.rst:1829 2f7fe253bb984f0eb8a77a290ae60544
msgid ""
"The BPF verifier in the kernel checks that a BPF program does not contain loops by performing a depth first "
"search of all possible program paths besides other control flow graph validations. The purpose is to make sure "
"that the program is always guaranteed to terminate."
msgstr ""
"内核中的 BPF 验证器通过对除其他控制流图验证之外的所有可能的程序路径执行深度优先搜索来检查 BPF 程序是否包含循环。 "
"目的是确保程序始终能够正常结束。"

#: ../../bpf.rst:1834 851139c646bb4a579a9dea453f514223
msgid ""
"A very limited form of looping is available for constant upper loop bounds by using ``#pragma unroll`` "
"directive. Example code that is compiled to BPF:"
msgstr "通过使用 #pragma unroll 指令，一种非常有限的循环形式可用于恒定的循环上限。 编译为 BPF 的示例代码："

#: ../../bpf.rst:1865 1ef39bc379244be2808742ce57e9b708
msgid ""
"Another possibility is to use tail calls by calling into the same program again and using a "
"``BPF_MAP_TYPE_PERCPU_ARRAY`` map for having a local scratch space. While being dynamic, this form of looping "
"however is limited to a maximum of 34 iterations (the initial program, plus 33 iterations from the tail calls)."
msgstr ""
"另一种可能性是通过再次调用同一程序并使用``BPF_MAP_TYPE_PERCPU_ARRAY``映射来获得本地暂存空间来使用尾调用。 虽然是"
"动态的，但这种形式的循环被限制为最多 34 次迭代（初始程序，加上尾部调用的 33 次迭代）。"

#: ../../bpf.rst:1871 6ce728680b6744b5b9f6612b5f6f51d1
msgid "In the future, BPF may have some native, but limited form of implementing loops."
msgstr "将来，BPF 可能会有一些原生的但有限的循环实现形式。"

#: ../../bpf.rst:1873 2b8813b5a79a40c8bc1b9977b2216dc8
msgid "**Partitioning programs with tail calls.**"
msgstr "**使用尾调用对程序进行分区。**"

#: ../../bpf.rst:1875 d7611a0a571d4184845ebc06427cf296
msgid ""
"Tail calls provide the flexibility to atomically alter program behavior during runtime by jumping from one BPF "
"program into another. In order to select the next program, tail calls make use of program array maps "
"(``BPF_MAP_TYPE_PROG_ARRAY``), and pass the map as well as the index to the next program to jump to. There is no "
"return to the old program after the jump has been performed, and in case there was no program present at the "
"given map index, then execution continues on the original program."
msgstr ""
"尾调用提供了灵活性，可以在运行时通过从一个 BPF 程序跳转到另一个程序来原子地改变程序行为。 为了选择下一个程序，尾"
"调用使用程序数组映射（``BPF_MAP_TYPE_PROG_ARRAY``），并将映射以及索引传递给下一个要跳转的程序。 执行跳转后不会返"
"回到旧程序，如果在给定的映射索引处不存在程序，则继续执行原始程序。"

#: ../../bpf.rst:1883 1a63efdab3b1477b98acc0828f9d988e
msgid ""
"For example, this can be used to implement various stages of a parser, where such stages could be updated with "
"new parsing features during runtime."
msgstr "例如，这可用于实现解析器的各个阶段，这些阶段可以在运行时使用新的解析功能进行更新。"

#: ../../bpf.rst:1886 ff32c54301994c739a206a565505d71c
msgid ""
"Another use case are event notifications, for example, Cilium can opt in packet drop notifications during "
"runtime, where the ``skb_event_output()`` call is located inside the tail called program. Thus, during normal "
"operations, the fall-through path will always be executed unless a program is added to the related map index, "
"where the program then prepares the metadata and triggers the event notification to a user space daemon."
msgstr ""
"另一个用例是事件通知，例如，Cilium 可以在运行时选择丢包通知，其中``skb_event_output()``调用位于被调用程序的尾"
"部。 因此，在正常操作期间，除非将程序添加到相关映射索引中，否则将始终执行直通路径，然后该程序准备元数据并触发事件"
"通知给用户空间守护进程。"

#: ../../bpf.rst:1893 867399af65194cb6963a05c9df7fa993
msgid ""
"Program array maps are quite flexible, enabling also individual actions to be implemented for programs located "
"in each map index. For example, the root program attached to XDP or tc could perform an initial tail call to "
"index 0 of the program array map, performing traffic sampling, then jumping to index 1 of the program array map, "
"where firewalling policy is applied and the packet either dropped or further processed in index 2 of the program "
"array map, where it is mangled and sent out of an interface again. Jumps in the program array map can, of "
"course, be arbitrary. The kernel will eventually execute the fall-through path when the maximum tail call limit "
"has been reached."
msgstr ""
"程序数组映射非常灵活，还可以为位于每个映射索引中的程序实现单独的操作。 例如，附加到 XDP 或 tc 的根程序可以对程序"
"数组映射的索引 0 执行初始尾调用，执行流量采样，然后跳转到程序数组映射的索引 1，其中应用了防火墙策略并且数据包要"
"么 在程序数组映射的索引 2 中删除或进一步处理，在那里它被破坏并再次从接口发送出去。 当然，程序数组映射中的跳转可以"
"是任意的。 当达到最大尾调用限制时，内核最终将执行失败路径。"

#: ../../bpf.rst:1903 88681a04c6784a96b4ba58011901b75b
msgid "Minimal example extract of using tail calls:"
msgstr "使用尾调用的最小示例摘录："

#: ../../bpf.rst:1960 f5e8380183414f209dfbe14374281a38
msgid ""
"When loading this toy program, tc will create the program array and pin it to the BPF file system in the global "
"namespace under ``jmp_map``. Also, the BPF ELF loader in iproute2 will also recognize sections that are marked "
"as ``__section_tail()``. The provided ``id`` in ``struct bpf_elf_map`` will be matched against the id marker in "
"the ``__section_tail()``, that is, ``JMP_MAP_ID``, and the program therefore loaded at the user specified "
"program array map index, which is ``0`` in this example. As a result, all provided tail call sections will be "
"populated by the iproute2 loader to the corresponding maps. This mechanism is not specific to tc, but can be "
"applied with any other BPF program type that iproute2 supports (such as XDP, lwt)."
msgstr ""
"当加载这个玩具程序时，tc 将创建程序数组并将其固定到全局命名空间中的 BPF 文件系统中的 jmp_map 下。 此外，iproute2 "
"中的 BPF ELF 加载器还将识别标记为 __section_tail() 的部分。 ``struct bpf_elf_map`` 中提供的``id`` 将与"
"``__section_tail()`` 中的 id 标记匹配，即``JMP_MAP_ID``，因此程序会在用户指定的程序中加载 数组映射索引，在本例中"
"为“0”。 结果，所有提供的尾调用部分将由 iproute2 加载程序填充到相应的映射。 这种机制并非特定于 tc，但可以与 "
"iproute2 支持的任何其他 BPF 程序类型（例如 XDP、lwt）一起应用。"

#: ../../bpf.rst:1971 2782b1f25e214d04a8ba46fcab353467
msgid "The generated elf contains section headers describing the map id and the entry within that map:"
msgstr "生成的 elf 包含描述映射 id 和该映射中的条目的部分标题："

#: ../../bpf.rst:2004 5af1ec0e23984c9492a71ec72bbfb9ba
msgid ""
"In this case, the ``section 1/0`` indicates that the ``looper()`` function resides in the map id ``1`` at "
"position ``0``."
msgstr "在这种情况下，``1/0``部分表示``looper()``函数驻留在映射ID``1``中的``0``位置。"

#: ../../bpf.rst:2007 6973eaf620e44e62b335fd0b805287d4
msgid ""
"The pinned map can be retrieved by a user space applications (e.g. Cilium daemon), but also by tc itself in "
"order to update the map with new programs. Updates happen atomically, the initial entry programs that are "
"triggered first from the various subsystems are also updated atomically."
msgstr ""
"固定映射可以由用户空间应用程序（例如 Cilium 守护程序）检索，也可以由 tc 本身检索，以便使用新程序更新映射。 更新以"
"原子方式发生，从各个子系统首先触发的初始入口程序也以原子方式更新。"

#: ../../bpf.rst:2012 6d3353960f034235b2fe8460ff4632ab
msgid "Example for tc to perform tail call map updates:"
msgstr "以下为 tc 执行尾调用映射更新的示例："

#: ../../bpf.rst:2018 cb6a697b97f840af981d91c37fecbdf1
msgid ""
"In case iproute2 would update the pinned program array, the ``graft`` command can be used. By pointing it to "
"``globals/jmp_map``, tc will update the map at index / key ``0`` with a new program residing in the object file "
"``new.o`` under section ``foo``."
msgstr ""
"如果 iproute2 会更新固定的程序数组，可以使用``graft``命令。 通过将其指向``globals/jmp_map``，tc 将使用位于``foo``"
"部分下的目标文件``new.o``中的新程序更新索引/键``0``处的映射。"

#: ../../bpf.rst:2023 99c905e374ee4ad583d6b49253d51d18
msgid "**Limited stack space of maximum 512 bytes.**"
msgstr "**最大的堆栈空间为 512 字节。**"

#: ../../bpf.rst:2025 a8ae0bd3f384425c97f615afb3d39246
msgid ""
"Stack space in BPF programs is limited to only 512 bytes, which needs to be taken into careful consideration "
"when implementing BPF programs in C. However, as mentioned earlier in point 3, a ``BPF_MAP_TYPE_PERCPU_ARRAY`` "
"map with a single entry can be used in order to enlarge scratch buffer space."
msgstr ""
"BPF 程序中的堆栈空间仅限于 512 字节，在 C 中实现 BPF 程序时需要仔细考虑。但是如前面第 3 点所述，为了扩大暂存缓冲"
"区空间可以使用具有单个条目的 ``BPF_MAP_TYPE_PERCPU_ARRAY`` 映射。"

#: ../../bpf.rst:2030 4f3dfbfc898940cb8a1f1f9b9ff692b6
msgid "**Use of BPF inline assembly possible.**"
msgstr "**可以使用 BPF 内联汇编。**"

#: ../../bpf.rst:2032 388edbe594484cec88f5085297577b53
msgid ""
"LLVM 6.0 or later allows use of inline assembly for BPF for the rare cases where it might be needed. The "
"following (nonsense) toy example shows a 64 bit atomic add. Due to lack of documentation, LLVM source code in "
"``lib/Target/BPF/BPFInstrInfo.td`` as well as ``test/CodeGen/BPF/`` might be helpful for providing some "
"additional examples. Test code:"
msgstr ""
"LLVM 6.0 或更高版本允许在可能需要的极少数情况下使用 BPF 的内联汇编。 下面的示例显示了一个 64 位原子加法。 由于缺"
"乏文档，lib/Target/BPF/BPFInstrInfo.td 和 test/CodeGen/BPF/ 中的 LLVM 源代码可能有助于提供一些额外的示例。 测试代"
"码："

#: ../../bpf.rst:2058 c133b97d630a4e63baea19f77ab2e8e8
msgid "The above program is compiled into the following sequence of BPF instructions:"
msgstr "上面的程序被编译成如下的BPF指令序列："

#: ../../bpf.rst:2075 8a43e4d094bf48cbb81a6fcbec4b9d43
msgid "**Remove struct padding with aligning members by using #pragma pack.**"
msgstr "**使用#pragma pack 禁止带有对齐的结构填充。**"

#: ../../bpf.rst:2077 e7b5774ed6f04d2692dd7d2bedd15a22
msgid ""
"In modern compilers, data structures are aligned by default to access memory efficiently. Structure members are "
"aligned to memory address that multiples their size, and padding is added for the proper alignment. Because of "
"this, the size of struct may often grow larger than expected."
msgstr ""
"在现代编译器中，数据结构默认进行内存对齐以实现更加高效的访问。 结构成员对齐到其大小的倍数的内存地址，并添加填充以"
"进行正确对齐。 正因为如此，struct 的大小可能经常比预期的要大。"

#: ../../bpf.rst:2102 fd84997ba8f94cc68ed2b237a4bb4e9f
msgid ""
"The BPF verifier in the kernel checks the stack boundary that a BPF program does not access outside of boundary "
"or uninitialized stack area. Using struct with the padding as a map value, will cause ``invalid indirect read "
"from stack`` failure on ``bpf_prog_load()``."
msgstr ""
"内核中的 BPF 校验器会检查栈边界（stack boundary），BPF 程序不会访问栈边界外的空间，或者是未初始化的栈空间。如果将"
"结构体中填充出来的内存区域作为一个映射值进行访问，那调用 ``bpf_prog_load()`` 时就会报 ``invalid indirect read "
"from stack`` 错误。"

#: ../../bpf.rst:2107 2af9362d169d4ea69995ea0dd7fcde84
msgid "Example code:"
msgstr "样例代码："

#: ../../bpf.rst:2141 8367ad178d4c496aa72ad6fa1bdd1263
msgid "Corresponding output on ``bpf_load_program()``::"
msgstr "以下为 bpf_load_program() 上的相应输出::"

#: ../../bpf.rst:2154 d582c81254a742339f46184145ab1bf0
msgid ""
"At ``bpf_prog_load()``, an eBPF verifier ``bpf_check()`` is called, and it'll check stack boundary by calling "
"``check_func_arg() -> check_stack_boundary()``. From the upper error shows, ``struct called_info`` is compiled "
"to 24-byte size, and the message says reading a data from +20 is an invalid indirect read. And as we discussed "
"earlier, the address 0x14(20) is the place where PADDING is."
msgstr ""
"在 bpf_prog_load() 中，调用了一个 eBPF 验证器 ``bpf_check()`` ，它将通过调用 ``check_func_arg() -> "
"check_stack_boundary()`` 来检查堆栈边界。 从上面的错误显示，``struct called_info`` 被编译为 24 字节大小，并且消息"
"说从 +20 读取数据是无效的间接读取。 正如我们之前讨论的，地址 0x14(20) 是 PADDING 所在的地方。"

#: ../../bpf.rst:2168 a6d1b4803d834ac0b92bb2a567efa777
msgid ""
"The ``check_stack_boundary()`` internally loops through the every ``access_size`` (24) byte from the start "
"pointer to make sure that it's within stack boundary and all elements of the stack are initialized. Since the "
"padding isn't supposed to be used, it gets the 'invalid indirect read from stack' failure. To avoid this kind of "
"failure, remove the padding from the struct is necessary."
msgstr ""
"``check_stack_boundary()`` 内部循环遍历从起始指针开始的每个``access_size`` (24) 字节，以确保它在堆栈边界内并且堆"
"栈的所有元素都已初始化。 由于不应该使用填充，因此会出现``无效的从堆栈间接读取``报错。 为了避免这种失败，从结构中"
"删除填充是必要的。"

#: ../../bpf.rst:2174 e7840eae57d2461ab2bf28d2a47dabdc
msgid "Removing the padding by using ``#pragma pack(n)`` directive:"
msgstr "使用 #pragma pack(n) 指令删除填充："

#: ../../bpf.rst:2197 b637aa58174641c3ad0d6863a9b8e3df
msgid ""
"By locating ``#pragma pack(4)`` before of ``struct called_info``, compiler will align members of a struct to the "
"least of 4-byte and their natural alignment. As you can see, the size of ``struct called_info`` has been shrunk "
"to 20-byte and the padding is no longer exist."
msgstr ""
"通过在 ``struct called_info`` 之前定位``#pragma pack(4)``，编译器会将结构的成员对齐到至少 4 字节的自然对齐。 如您"
"所见，``struct called_info`` 的大小已缩小到 20 字节，并且填充不再存在。"

#: ../../bpf.rst:2202 9f00fb445f1144a0905475233b7f9df7
msgid ""
"But, removing the padding have downsides either. For example, compiler will generate less optimized code. Since "
"we've removed the padding, processors will conduct unaligned access to the structure and this might lead to "
"performance degradation. And also, unaligned access might get rejected by verifier on some architectures."
msgstr ""
"但是，删除填充也有缺点。 例如，编译器将生成优化程度较低的代码。 由于我们删除了填充，处理器将对结构进行未对齐的访"
"问，这可能会导致性能下降。 此外，在某些架构上，未对齐的访问可能会被验证者拒绝。"

#: ../../bpf.rst:2207 dbad8585c31942a39debb5845bd5c468
msgid ""
"However, there is a way to avoid downsides of packed structure. By simply adding the explicit padding ``u32 "
"pad`` member at the end will resolve the same problem without packing of the structure."
msgstr ""
"但是，有一种方法可以避免打包结构的缺点。 通过简单地在末尾添加显式填充``u32 pad``成员将解决相同的问题，而无需打包"
"结构。"

#: ../../bpf.rst:2232 5a81097bd4a148c086d791a71fd6b4f0
msgid "**Accessing packet data via invalidated references**"
msgstr "**通过无效引用访问数据包数据**"

#: ../../bpf.rst:2234 eeb0ea21a2bc47fa8ffbefcf88ba8b02
msgid ""
"Some networking BPF helper functions such as ``bpf_skb_store_bytes`` might change the size of a packet data. As "
"verifier is not able to track such changes, any a priori reference to the data will be invalidated by verifier. "
"Therefore, the reference needs to be updated before accessing the data to avoid verifier rejecting a program."
msgstr ""
"一些网络 BPF 辅助函数，例如 ``bpf_skb_store_bytes`` 可能会改变数据包数据的大小。 由于验证者无法跟踪此类更改，因此"
"对数据的任何先验引用都将被验证者无效。 因此在访问数据之前需要更新引用，以避免验证者拒绝程序。"

#: ../../bpf.rst:2240 8f9a06ef7bee44068132d0cdd6cf8719
msgid "To illustrate this, consider the following snippet:"
msgstr "为了说明这一点，请考虑以下代码段："

#: ../../bpf.rst:2252 96deedb87b5e450eb7e695ccee1dbd94
msgid "Verifier will reject the snippet due to dereference of the invalidated ``ip4->protocol``:"
msgstr "由于取消引用无效的``ip4->protocol``，验证程序将拒绝该片段："

#: ../../bpf.rst:2268 5c487d9f5c0845639f71a9c42cc689c5
msgid "To fix this, the reference to ``ip4`` has to be updated:"
msgstr "要解决此问题，必须更新对 ip4 的引用："

#: ../../bpf.rst:2283 294b4d6773e44961b31d9c3cb54efce8
msgid "iproute2"
msgstr "iproute2"

#: ../../bpf.rst:2285 31c8c39e339c4c3faf30e2804bbf0f06
msgid ""
"There are various front ends for loading BPF programs into the kernel such as bcc, perf, iproute2 and others. "
"The Linux kernel source tree also provides a user space library under ``tools/lib/bpf/``, which is mainly used "
"and driven by perf for loading BPF tracing programs into the kernel. However, the library itself is generic and "
"not limited to perf only. bcc is a toolkit providing many useful BPF programs mainly for tracing that are loaded "
"ad-hoc through a Python interface embedding the BPF C code. Syntax and semantics for implementing BPF programs "
"slightly differ among front ends in general, though. Additionally, there are also BPF samples in the kernel "
"source tree (``samples/bpf/``) which parse the generated object files and load the code directly through the "
"system call interface."
msgstr ""
"有多种前端用于将 BPF 程序加载到内核中，例如 bcc、perf、iproute2 等。 Linux 内核源码树还在``tools/lib/bpf/`` 下提"
"供了一个用户空间库，主要由 perf 使用和驱动，用于将 BPF 跟踪程序加载到内核中。 但是，库本身是通用的，不仅限于 "
"perf。 bcc 是一个工具包，提供了许多有用的 BPF 程序，主要用于通过嵌入 BPF C 代码的 Python 接口临时加载的跟踪。 不"
"过，总体而言，用于实现 BPF 程序的语法和语义在前端之间略有不同。 此外，内核源代码树 (``samples/bpf/``) 中还有 BPF "
"示例，它们解析生成的目标文件并直接通过系统调用接口加载代码。"

#: ../../bpf.rst:2296 7fd47de1328c4d8cb91819a0ea8cae79
msgid ""
"This and previous sections mainly focus on the iproute2 suite's BPF front end for loading networking programs of "
"XDP, tc or lwt type, since Cilium's programs are implemented against this BPF loader. In future, Cilium will be "
"equipped with a native BPF loader, but programs will still be compatible to be loaded through iproute2 suite in "
"order to facilitate development and debugging."
msgstr ""
"本节和前几节主要关注 iproute2 提供的 BPF 前端，用于加载 XDP、tc 或 lwt 类型的网络程序，因为 Cilium 的程序是针对"
"此 BPF 加载器实现的。 之后 Cilium 会实现自己的原生 BPF 加载器，但程序仍将兼容通过 iproute2 套件加载，以方便开发和"
"调试。"

#: ../../bpf.rst:2302 4b16c6e5ccde428c81a1d60564ff910f
msgid ""
"All BPF program types supported by iproute2 share the same BPF loader logic due to having a common loader back "
"end implemented as a library (``lib/bpf.c`` in iproute2 source tree)."
msgstr ""
"之所以iproute2 支持的所有 BPF 程序类型共享相同的 BPF 加载器逻辑，是因为有一个通用的加载器后端实现为库（iproute2 "
"源代码树中的``lib/bpf.c``）。"

#: ../../bpf.rst:2306 2100315492a749ffade58d484c81486d
msgid ""
"The previous section on LLVM also covered some iproute2 parts related to writing BPF C programs, and later "
"sections in this document are related to tc and XDP specific aspects when writing programs. Therefore, this "
"section will rather focus on usage examples for loading object files with iproute2 as well as some of the "
"generic mechanics of the loader. It does not try to provide a complete coverage of all details, but enough for "
"getting started."
msgstr ""
"前面关于 LLVM 的部分还介绍了一些与编写 BPF C 程序相关的 iproute2 部分，本文档的后面部分涉及编写程序时的 tc 和 "
"XDP 特定方面。 因此本节将重点介绍使用 iproute2 加载目标文件的用法示例以及加载器的一些通用机制。 它不会尝试提供所"
"有细节的完整覆盖，但足以让您入门。"

#: ../../bpf.rst:2313 bbd96a47084a4b189e8163227ac71c7e
msgid "**1. Loading of XDP BPF object files.**"
msgstr "**1. 加载 XDP BPF 目标文件。**"

#: ../../bpf.rst:2315 4b3eec8802c94e5a9d720040cccb7af9
msgid ""
"Given a BPF object file ``prog.o`` has been compiled for XDP, it can be loaded through ``ip`` to a XDP-supported "
"netdevice called ``em1`` with the following command:"
msgstr ""
"给定一个 BPF 目标文件 ``prog.o`` 已经为 XDP 编译，它可以通过 ``ip`` 加载到一个名为 ``em1`` 的 XDP 支持的网络设"
"备，使用以下命令："

#: ../../bpf.rst:2323 b9ee4250c219481c90aa78e5d7e72d07
msgid ""
"The above command assumes that the program code resides in the default section which is called ``prog`` in XDP "
"case. Should this not be the case, and the section is named differently, for example, ``foobar``, then the "
"program needs to be loaded as:"
msgstr ""
"上面的命令假定程序代码位于默认部分，在 XDP 情况下称为``prog``。 如果不是这种情况，并且该部分的名称不同，例如 "
"``foobar``，那么程序需要加载为："

#: ../../bpf.rst:2332 dce7b4e231ca4fa98992ba1ab3a45c08
msgid ""
"Note that it is also possible to load the program out of the ``.text`` section. Changing the minimal, stand-"
"alone XDP drop program by removing the ``__section()`` annotation from the ``xdp_drop`` entry point would look "
"like the following:"
msgstr ""
"请注意，也可以从 .text 部分加载程序。 通过从 ``xdp_drop`` 入口点删除 ``__section()`` 注释来更改最小的独立 XDP 丢"
"包程序，如下所示："

#: ../../bpf.rst:2352 19e8df4ae7394eda8df98f23b9721bb6
msgid "And can be loaded as follows:"
msgstr "并且可以进行如下加载："

#: ../../bpf.rst:2358 cf5ed60a2cee40abae559dda06c04470
msgid ""
"By default, ``ip`` will throw an error in case a XDP program is already attached to the networking interface, to "
"prevent it from being overridden by accident. In order to replace the currently running XDP program with a new "
"one, the ``-force`` option must be used:"
msgstr ""
"默认情况下，如果 XDP 程序已经连接到网络接口，``ip``将抛出异常，以防止它被意外覆盖。 为了用新的替换当前运行的 XDP "
"程序，必须使用``-force`` 选项："

#: ../../bpf.rst:2367 0201d97fbaa64ccf950d33021a50db10
msgid ""
"Most XDP-enabled drivers today support an atomic replacement of the existing program with a new one without "
"traffic interruption. There is always only a single program attached to an XDP-enabled driver due to performance "
"reasons, hence a chain of programs is not supported. However, as described in the previous section, partitioning "
"of programs can be performed through tail calls to achieve a similar use case when necessary."
msgstr ""
"如今，大多数启用 XDP 的驱动程序都支持用新程序原子替换现有程序，而不会中断流量。 由于性能原因，始终只有一个程序附"
"加到启用 XDP 的驱动程序，因此不支持程序链。 但是如上一节所述，可以通过尾调用执行程序分区，以在必要时实现类似的用"
"例。"

#: ../../bpf.rst:2374 15be7737804e4f2e8e075de14cc6fc52
msgid ""
"The ``ip link`` command will display an ``xdp`` flag if the interface has an XDP program attached. ``ip link | "
"grep xdp`` can thus be used to find all interfaces that have XDP running. Further introspection facilities are "
"provided through the detailed view with ``ip -d link`` and ``bpftool`` can be used to retrieve information about "
"the attached program based on the BPF program ID shown in the ``ip link`` dump."
msgstr ""
"如果接口连接了 XDP 程序，``ip link`` 命令将显示 ``xdp`` 标志。 ``ip link | grep xdp`` 可用于查找所有运行 XDP 的接"
"口。 通过 ``ip -d link`` 的详细视图提供了进一步的自省工具，并且 bpftool 可用于根据 ip link 转储中显示的 BPF 程序 "
"ID 检索有关附加程序的信息 ."

#: ../../bpf.rst:2381 94c2f5a0bdbf4d758224fa6c991d1287
msgid "In order to remove the existing XDP program from the interface, the following command must be issued:"
msgstr "为了从界面中删除现有的 XDP 程序，必须使用以下命令："

#: ../../bpf.rst:2388 518bd3dc535f4db190707735fdd2a148
msgid ""
"In the case of switching a driver's operation mode from non-XDP to native XDP and vice versa, typically the "
"driver needs to reconfigure its receive (and transmit) rings in order to ensure received packet are set up "
"linearly within a single page for BPF to read and write into. However, once completed, then most drivers only "
"need to perform an atomic replacement of the program itself when a BPF program is requested to be swapped."
msgstr ""
"在将驱动程序的操作模式从非 XDP 切换到本地 XDP 的情况下，反之亦然，通常驱动程序需要重新配置其接收（和发送）环，以"
"确保接收的数据包在单个页面内线性设置，以便 BPF 读取和写入。 但是，一旦完成，大多数驱动程序只需要在请求交换 BPF 程"
"序时执行程序本身的原子替换。"

#: ../../bpf.rst:2395 15aaffbea2764c1a9f470fed3ba0ee92
msgid ""
"In total, XDP supports three operation modes which iproute2 implements as well: ``xdpdrv``, ``xdpoffload`` and "
"``xdpgeneric``."
msgstr "总的来说，XDP 支持 iproute2 实现的三种操作模式：``xdpdrv``，``xdpoffload`` 和 ``xdpgeneric``。"

#: ../../bpf.rst:2398 af45fb2a5c5a47d9bc6249cb7cc89b20
msgid ""
"``xdpdrv`` stands for native XDP, meaning the BPF program is run directly in the driver's receive path at the "
"earliest possible point in software. This is the normal / conventional XDP mode and requires driver's to "
"implement XDP support, which all major 10G/40G/+ networking drivers in the upstream Linux kernel already provide."
msgstr ""
"``xdpdrv`` 代表原生 XDP，意味着 BPF 程序直接在驱动的接收路径上运行，理论上这是软件层最早可以处理包的位置。 这是正"
"常/传统的 XDP 模式，需要驱动程序来实现 XDP 支持，上游 Linux 内核中所有主要的 10G/40G/+ 网络驱动程序都已提供。"

#: ../../bpf.rst:2404 99a79bf6869d40a890fd636ee8da2970
msgid ""
"``xdpgeneric`` stands for generic XDP and is intended as an experimental test bed for drivers which do not yet "
"support native XDP. Given the generic XDP hook in the ingress path comes at a much later point in time when the "
"packet already enters the stack's main receive path as a ``skb``, the performance is significantly less than "
"with processing in ``xdpdrv`` mode. ``xdpgeneric`` therefore is for the most part only interesting for "
"experimenting, less for production environments."
msgstr ""
"``xdpgeneric`` 代表通用 XDP，旨在作为尚不支持本机 XDP 的驱动程序的实验测试平台。 鉴于入口路径中的通用 XDP hook在"
"数据包已经作为``skb``进入堆栈的主接收路径时出现的时间要晚得多，因此性能明显低于在``xdpdrv``模式下处理。因此，"
"``xdpgeneric``在大多数情况下只在实验场景下被使用，对生产环境的意义不大。"

#: ../../bpf.rst:2411 fdb43e2668974d78b9a765b9406d64fc
msgid ""
"Last but not least, the ``xdpoffload`` mode is implemented by SmartNICs such as those supported by Netronome's "
"nfp driver and allow for offloading the entire BPF/XDP program into hardware, thus the program is run on each "
"packet reception directly on the card. This provides even higher performance than running in native XDP although "
"not all BPF map types or BPF helper functions are available for use compared to native XDP. The BPF verifier "
"will reject the program in such case and report to the user what is unsupported. Other than staying in the realm "
"of supported BPF features and helper functions, no special precautions have to be taken when writing BPF C "
"programs."
msgstr ""
"最后但同样重要的是，``xdpoffload`` 模式由 SmartNIC 实现，例如 Netronome 的 nfp 驱动程序支持的那些，允许将整个 "
"BPF/XDP 程序 offload 到硬件，因此程序在每次数据包接收时直接在网卡上运行。这提供了比在原生 XDP 中运行更高的性能，"
"尽管与原生 XDP 相比，并非所有 BPF 映射类型或 BPF 辅助函数都可以使用。 在这种情况下，BPF 验证器将拒绝该程序并向用"
"户报告不支持的程序。 除了停留在受支持的 BPF 特性和辅助函数的领域之外，在编写 BPF C 程序时不需要采取特殊的预防措"
"施。"

#: ../../bpf.rst:2421 ca5c4fcae29a4f5f8d62746e305c29fa
msgid ""
"When a command like ``ip link set dev em1 xdp obj [...]`` is used, then the kernel will attempt to load the "
"program first as native XDP, and in case the driver does not support native XDP, it will automatically fall back "
"to generic XDP. Thus, for example, using explicitly ``xdpdrv`` instead of ``xdp``, the kernel will only attempt "
"to load the program as native XDP and fail in case the driver does not support it, which provides a guarantee "
"that generic XDP is avoided altogether."
msgstr ""
"当使用 `ip link set dev em1 xdp obj […]` 之类的命令时，内核将首先尝试将程序加载为原生 XDP，如果驱动程序不支持原"
"生 XDP，它将自动回退到通用 XDP。 因此在显式使用``xdpdrv``而不是``xdp``，内核只会尝试将程序加载为本地 XDP，并在驱"
"动程序不支持它的情况下失败，这保证了通用 XDP 不会被误加载。"

#: ../../bpf.rst:2429 bb17d8e3bf554ffab8fd70dc381e5781
msgid ""
"Example for enforcing a BPF/XDP program to be loaded in native XDP mode, dumping the link details and unloading "
"the program again:"
msgstr "强制以原生 XDP 模式加载 BPF/XDP 程序、转储链接详细信息并再次卸载程序的示例："

#: ../../bpf.rst:2443 a04baf613e1340cda583c5b30d4edbf3
msgid ""
"Same example now for forcing generic XDP, even if the driver would support native XDP, and additionally dumping "
"the BPF instructions of the attached dummy program through bpftool:"
msgstr "尽管驱动程序支持原生 XDP，同样的强制使用通用 XDP的例子，并且通过 bpftool 转储附加的虚拟程序的 BPF 指令："

#: ../../bpf.rst:2461 099d826ff0ce4c818f9db657f2d126ad
msgid ""
"And last but not least offloaded XDP, where we additionally dump program information via bpftool for retrieving "
"general metadata:"
msgstr "最后将 XDP 超频，我们还通过 bpftool 转储程序信息以检索一般元数据："

#: ../../bpf.rst:2479 d0825748e2e44dbeb7e0bc09d8b4d314
msgid ""
"Note that it is not possible to use ``xdpdrv`` and ``xdpgeneric`` or other modes at the same time, meaning only "
"one of the XDP operation modes must be picked."
msgstr "请注意，不能同时使用“xdpdrv”和“xdpgeneric”或其他模式，这意味着只能选择其中一种 XDP 操作模式。"

#: ../../bpf.rst:2483 729a90b2d5dc4bfe875827d6f7af8a16
msgid ""
"A switch between different XDP modes e.g. from generic to native or vice versa is not atomically possible. Only "
"switching programs within a specific operation mode is:"
msgstr "不同 XDP 模式之间的切换，例如从通用到本机或反之亦然是不可能的。 只有在特定操作模式下可以进行切换程序："

#: ../../bpf.rst:2497 c36cbea7d75e487fac163fa46eaefb03
msgid ""
"Switching between modes requires to first leave the current operation mode in order to then enter the new one:"
msgstr "切换模式需要先离开当前的操作模式，然后才能进入新的操作模式："

#: ../../bpf.rst:2513 e28d6228bbb046438fbf208714859195
msgid "**2. Loading of tc BPF object files.**"
msgstr "**2。 加载 tc BPF 目标文件。**"

#: ../../bpf.rst:2515 8fce5c5ef78340b4ae83fc84219ea466
msgid ""
"Given a BPF object file ``prog.o`` has been compiled for tc, it can be loaded through the tc command to a "
"netdevice. Unlike XDP, there is no driver dependency for supporting attaching BPF programs to the device. Here, "
"the netdevice is called ``em1``, and with the following command the program can be attached to the networking "
"``ingress`` path of ``em1``:"
msgstr ""
"给定一个已经被 tc 编译 的 BPF 目标文件 ``prog.o``，它可以通过 tc 命令加载到一个网络设备。 与 XDP 不同的是，它支持"
"将 BPF 程序附加到设备没有驱动程序依赖项。 在这里，网络设备被称为``em1``，使用以下命令可以将程序附加到``em1``的网"
"络``ingress``路径上："

#: ../../bpf.rst:2526 b997637283f3463f8c05216969acb8b9
msgid ""
"The first step is to set up a ``clsact`` qdisc (Linux queueing discipline). ``clsact`` is a dummy qdisc similar "
"to the ``ingress`` qdisc, which can only hold classifier and actions, but does not perform actual queueing. It "
"is needed in order to attach the ``bpf`` classifier. The ``clsact`` qdisc provides two special hooks called "
"``ingress`` and ``egress``, where the classifier can be attached to. Both ``ingress`` and ``egress`` hooks are "
"located in central receive and transmit locations in the networking data path, where every packet on the device "
"passes through. The ``ingress`` hook is called from ``__netif_receive_skb_core() -> sch_handle_ingress()`` in "
"the kernel and the ``egress`` hook from ``__dev_queue_xmit() -> sch_handle_egress()``."
msgstr ""
"第一步是设置 ``clsact`` qdisc（Linux 排队规则）。 ``clsact`` 是一个类似于 ``ingress`` qdisc 的虚拟 qdisc，它只能"
"保存分类器和动作，但不会被实际加入队列。 它对于数据包可以和 ``bpf`` 分类器而言是必需的。 ``clsact`` qdisc 提供了"
"两个特殊的hook，称为 ``ingress`` 和 ``egress``，分类器可以附加到其中。 ``ingress`` 和 ``egress`` 钩子都位于网络数"
"据路径中的中央接收和传输位置，而设备上的每个数据包都通过该位置。 ``ingress`` 钩子从内核中的"
"``__netif_receive_skb_core() -> sch_handle_ingress()`` 调用，``egress`` 钩子从``__dev_queue_xmit() -> "
"sch_handle_egress()`` 调用。"

#: ../../bpf.rst:2536 3d669dc475154c0c83cf361d91158098
msgid "The equivalent for attaching the program to the ``egress`` hook looks as follows:"
msgstr "将程序附加到 ``egress`` hook的等效项如下所示："

#: ../../bpf.rst:2542 1b34a67a422b4f9296bbb04969c69fe9
msgid ""
"The ``clsact`` qdisc is processed lockless from ``ingress`` and ``egress`` direction and can also be attached to "
"virtual, queue-less devices such as ``veth`` devices connecting containers."
msgstr ""
"``clsact`` qdisc 从 ``ingress`` 和 ``egress`` 方向无锁处理，也可以连接到虚拟的无队列设备，例如连接容器的 "
"``veth`` 设备。"

#: ../../bpf.rst:2546 01594a515bb54ad5bf5a6d3aed183ca6
msgid ""
"Next to the hook, the ``tc filter`` command selects ``bpf`` to be used in ``da`` (direct-action) mode. ``da`` "
"mode is recommended and should always be specified. It basically means that the ``bpf`` classifier does not need "
"to call into external tc action modules, which are not necessary for ``bpf`` anyway, since all packet mangling, "
"forwarding or other kind of actions can already be performed inside the single BPF program which is to be "
"attached, and is therefore significantly faster."
msgstr ""
"在附加上hook之后，``tc filter`` 命令选择 ``bpf`` 以在 ``da`` （直接动作）模式下使用。 我们推荐``da`` 模式一直保持"
"打开，这基本上意味着 ``bpf`` 分类器不需要调用外部 tc 动作模块，而这种外部调用对于``bpf`` 无论如何都不是必需的，因"
"为所有数据包修改、转发或其他类型的动作都可以在单个 BPF 程序内部执行，因此速度要快得多。"

#: ../../bpf.rst:2554 f839f61e28af4950a75d2b7ec890523f
msgid ""
"At this point, the program has been attached and is executed once packets traverse the device. Like in XDP, "
"should the default section name not be used, then it can be specified during load, for example, in case of "
"section ``foobar``:"
msgstr ""
"此时，程序就会被bpf程序关联并在数据包穿过设备时执行动作。 就像在 XDP 中一样，如果不使用默认的节名称，那么可以在加"
"载期间指定它，例如，在节 ``foobar`` 的情况下："

#: ../../bpf.rst:2562 5305d68c149847f5a7550335794403d6
msgid ""
"iproute2's BPF loader allows for using the same command line syntax across program types, hence the ``obj prog.o "
"sec foobar`` is the same syntax as with XDP mentioned earlier."
msgstr ""
"iproute2 的 BPF 加载器允许跨程序类型使用相同的命令行语法，因此 ``obj prog.o sec foobar`` 与前面提到的 XDP 的语法"
"相同。"

#: ../../bpf.rst:2566 30d234b1e2854a3b8ad283aec87eb663
msgid "The attached programs can be listed through the following commands:"
msgstr "可以通过以下命令列出被关联的程序："

#: ../../bpf.rst:2578 e1e70c0777dc43759d8647bca4f19cd3
msgid ""
"The output of ``prog.o:[ingress]`` tells that program section ``ingress`` was loaded from the file ``prog.o``, "
"and ``bpf`` operates in ``direct-action`` mode. The program ``id`` and ``tag`` is appended for each case, where "
"the latter denotes a hash over the instruction stream which can be correlated with the object file or ``perf`` "
"reports with stack traces, etc. Last but not least, the ``id`` represents the system-wide unique BPF program "
"identifier that can be used along with ``bpftool`` to further inspect or dump the attached BPF program."
msgstr ""
"``prog.o:[ingress]`` 的输出是指程序的``ingress`` 是从文件``prog.o`` 加载的，并且``bpf`` 是在``direct-action``模式"
"下运行的。 程序 ``id`` 和 ``tag`` 被附加到每种情况下，后者表示指令流上的散列，可以与目标文件相关联或带有堆栈跟踪"
"的``perf`` 报告等。 最后，``id`` 表示系统范围内唯一的 BPF 程序标识符，可以与 ``bpftool`` 一起使用，以便进一步检查"
"或转储附加的 BPF 程序。"

#: ../../bpf.rst:2586 8161165f64424213aaf93c7250e5d30d
msgid ""
"tc can attach more than just a single BPF program, it provides various other classifiers which can be chained "
"together. However, attaching a single BPF program is fully sufficient since all packet operations can be "
"contained in the program itself thanks to ``da`` (``direct-action``) mode, meaning the BPF program itself will "
"already return the tc action verdict such as ``TC_ACT_OK``, ``TC_ACT_SHOT`` and others. For optimal performance "
"and flexibility, this is the recommended usage."
msgstr ""
"tc 可以 attach 多个 BPF 程序，并提供了其他的一些分类器，这些分类器可以 chain 到一起使用。但是attach 单个 BPF 程序"
"已经完全足够了，因为有了 ``da`` 模式，所有的包操作都可以放到同一个程序中，这意味着 BPF 程序自身将会返回 tc "
"action verdict，例如 ``TC_ACT_OK``、``TC_ACT_SHOT`` 等等。出于最佳性能和灵活性考虑，这（``da`` 模式）是推 荐的使"
"用方式。"

#: ../../bpf.rst:2593 d5bed8076ce74d5a9b8b21f8de58439c
msgid ""
"In the above ``show`` command, tc also displays ``pref 49152`` and ``handle 0x1`` next to the BPF related "
"output. Both are auto-generated in case they are not explicitly provided through the command line. ``pref`` "
"denotes a priority number, which means that in case multiple classifiers are attached, they will be executed "
"based on ascending priority, and ``handle`` represents an identifier in case multiple instances of the same "
"classifier have been loaded under the same ``pref``. Since in case of BPF, a single program is fully sufficient, "
"``pref`` and ``handle`` can typically be ignored."
msgstr ""
"在上面的``show`` 命令中，tc 还在 BPF 相关输出旁边显示``pref 49152`` 和 ``handle 0x1``。 两者都是自动生成的，以防"
"它们没有通过命令行显式提供。 pref 表示优先级编号，表示如果附加了多个分类器，它们将根据升序优先级执行，和相同的"
"``pref``。 由于在 BPF 的情况下，单个程序就足够了，``pref``和``handle``通常可以忽略。"

#: ../../bpf.rst:2602 0c4ad0bfbe334e89adfa60ad4f774006
msgid ""
"Only in the case where it is planned to atomically replace the attached BPF programs, it would be recommended to "
"explicitly specify ``pref`` and ``handle`` a priori on initial load, so that they do not have to be queried at a "
"later point in time for the ``replace`` operation. Thus, creation becomes:"
msgstr ""
"只有在计划以原子方式替换附加的 BPF 程序的情况下，才建议在初始加载时显式指定``pref``和``handle``，这样就不必在 "
"``replace`` 操作后再被指定了，因此创建过程变为："

#: ../../bpf.rst:2615 7e960698a9cd4f5eb9e68ef2c0c45d65
msgid ""
"And for the atomic replacement, the following can be issued for updating the existing program at ``ingress`` "
"hook with the new BPF program from the file ``prog.o`` in section ``foobar``:"
msgstr ""
"对于原子替换，可以发出以下命令，使用 ``foobar`` 部分中的 ``prog.o`` 文件中的新 BPF 程序更新 ``ingress`` hook处的"
"现有程序："

#: ../../bpf.rst:2623 7878a0f7579c4893beb775f71c89d727
msgid ""
"Last but not least, in order to remove all attached programs from the ``ingress`` respectively ``egress`` hook, "
"the following can be used:"
msgstr "最后但同样重要的是，为了从 ``ingress`` 和 ``egress`` hook中删除所有附加的程序，可以使用以下命令："

#: ../../bpf.rst:2631 014f4a4d68584aa8aa191b59ba843ef8
msgid ""
"For removing the entire ``clsact`` qdisc from the netdevice, which implicitly also removes all attached programs "
"from the ``ingress`` and ``egress`` hooks, the below command is provided:"
msgstr ""
"因为从网络设备中删除整个 ``clsact`` qdisc，这也隐式地从 ``ingress`` 和 ``egress`` hook中删除所有附加的程序，提供"
"以下命令："

#: ../../bpf.rst:2639 a01c0003ca7f41029b7d70aaf2c41e21
msgid ""
"tc BPF programs can also be offloaded if the NIC and driver has support for it similarly as with XDP BPF "
"programs. Netronome's nfp supported NICs offer both types of BPF offload."
msgstr ""
"如果 NIC 和驱动程序支持 tc BPF 程序，那也可以将它们 offload 到网卡。 Netronome 的 nfp 给 NIC 提供了两种类型的 "
"BPF 卸载。"

#: ../../bpf.rst:2650 962c6881372e4355a7dba119f6275824
msgid ""
"If the above error is shown, then tc hardware offload first needs to be enabled for the device through ethtool's "
"``hw-tc-offload`` setting:"
msgstr "如果出现上述错误，则首先需要通过 ethtool 的``hw-tc-offload``设置为设备启用 tc 硬件offload："

#: ../../bpf.rst:2662 a9d479b9106b459fbee5ec02cfe49fab
msgid "The ``in_hw`` flag confirms that the program has been offloaded to the NIC."
msgstr "其中的 ``in_hw`` 标志表示这个程序已经被 offload 到网卡了。"

#: ../../bpf.rst:2664 3def703f4fb8469ca701b307945d870f
msgid ""
"Note that BPF offloads for both tc and XDP cannot be loaded at the same time, either the tc or XDP offload "
"option must be selected."
msgstr "请注意，tc 和 XDP 的 BPF offload不能同时加载，必须选择 tc 或 XDP 的offload项。"

#: ../../bpf.rst:2667 1334ffed7bd04a1db0f10e88b6fa1cac
msgid "**3. Testing BPF offload interface via netdevsim driver.**"
msgstr "**3。 通过 netdevsim 驱动测试 BPF offload。*"

#: ../../bpf.rst:2669 cf3148988e57425f87907114af5e8f6c
msgid ""
"The netdevsim driver which is part of the Linux kernel provides a dummy driver which implements offload "
"interfaces for XDP BPF and tc BPF programs and facilitates testing kernel changes or low-level user space "
"programs implementing a control plane directly against the kernel's UAPI."
msgstr ""
"netdevsim 驱动是 Linux 内核的一部分，它是一个 dummy driver，实现了 XDP BPF 和 tc BPF 程序的 offload 接口，以及其"
"他一些设施。这些设施可以用来测试内核的改动，或者利用内核的 UAPI 实现了一个控制平面功能的底层用户空间程序。"

#: ../../bpf.rst:2674 f2393fa89e6a4fc4960ca00d33a68d2c
msgid "A netdevsim device can be created as follows:"
msgstr "可以按如下方式创建 netdevsim 设备："

#: ../../bpf.rst:2690 0cdd96cf9c4d42ab8f86c7a9ade55926
msgid "After that step, XDP BPF or tc BPF programs can be test loaded as shown in the various examples earlier:"
msgstr "在该步骤之后，可以测试加载 XDP BPF 或 tc BPF 程序，如前面的各种示例所示："

#: ../../bpf.rst:2702 9798ee6084d441c99e8a63b9fdbc0720
msgid "These two workflows are the basic operations to load XDP BPF respectively tc BPF programs with iproute2."
msgstr "这两个工作流是分别用 iproute2 加载 XDP BPF 和 tc BPF 程序的基本操作。"

#: ../../bpf.rst:2705 5171a3ee38cc4b4389267c38e618d480
msgid ""
"There are other various advanced options for the BPF loader that apply both to XDP and tc, some of them are "
"listed here. In the examples only XDP is presented for simplicity."
msgstr ""
"BPF 加载器还有其他各种高级选项，它们同时适用于 XDP 和 tc，这里列出了其中的一些。 在示例中，为简单起见，仅提供 "
"XDP。"

#: ../../bpf.rst:2709 f779441cc71944539d22069537f8eaea
msgid "**1. Verbose log output even on success.**"
msgstr "**1。 即使成功，也会有详细的日志输出。**"

#: ../../bpf.rst:2711 ef2469acbca4477d8ef5cbe7ca6d3ed4
msgid ""
"The option ``verb`` can be appended for loading programs in order to dump the verifier log, even if no error "
"occurred:"
msgstr "即使没有发生错误，也可以附加选项``verb`` 来加载程序，以便转储验证程序日志："

#: ../../bpf.rst:2729 d84de92248e545debbf35c11d51c438a
msgid "**2. Load program that is already pinned in BPF file system.**"
msgstr "**2。 加载已固定在 BPF 文件系统中的程序。**"

#: ../../bpf.rst:2731 237c30c3de7b4c28bf32da548aa03a01
msgid ""
"Instead of loading a program from an object file, iproute2 can also retrieve the program from the BPF file "
"system in case some external entity pinned it there and attach it to the device:"
msgstr ""
"除了从目标文件加载程序，iproute2 还可以从 BPF 文件系统中检索程序，以防某些外部实体将其固定在那里并将其附加到设"
"备："

#: ../../bpf.rst:2739 4b8be56314cf4a3ca109611ae8ee2a7b
msgid "iproute2 can also use the short form that is relative to the detected mount point of the BPF file system:"
msgstr "iproute2 也可以使用基于检测到的 BPF 文件系统的挂载点的简写形式："

#: ../../bpf.rst:2746 338df50b8d0d453483cb8408ce510410
msgid ""
"When loading BPF programs, iproute2 will automatically detect the mounted file system instance in order to "
"perform pinning of nodes. In case no mounted BPF file system instance was found, then tc will automatically "
"mount it to the default location under ``/sys/fs/bpf/``."
msgstr ""
"加载 BPF 程序时，iproute2 会自动检测已挂载的文件系统实例，以便执行节点固定。 如果没有找到挂载的 BPF 文件系统实"
"例，则 tc 将自动将其挂载到 /sys/fs/bpf/ 下的默认位置。"

#: ../../bpf.rst:2751 d609ebf08585431abff3cd4849a7ad11
msgid "In case an instance has already been found, then it will be used and no additional mount will be performed:"
msgstr "果已经找到了一个实例，那么它将被使用并且不会执行额外的挂载："

#: ../../bpf.rst:2770 4ea63e2b6a1c4161abc3f5423a631bcd
msgid ""
"By default tc will create an initial directory structure as shown above, where all subsystem users will point to "
"the same location through symbolic links for the ``globals`` namespace, so that pinned BPF maps can be reused "
"among various BPF program types in iproute2. In case the file system instance has already been mounted and an "
"existing structure already exists, then tc will not override it. This could be the case for separating ``lwt``, "
"``tc`` and ``xdp`` maps in order to not share ``globals`` among all."
msgstr ""
"认情况下，tc 将创建一个如上所示的初始目录结构，其中所有子系统用户将通过 ``globals`` 命名空间的符号链接指向同一位"
"置，因此可以在 iproute2 中的各种 BPF 程序类型之间重用固定的 BPF 映射。如果文件系统实例已经挂载并且现有结构已经存"
"在，则 tc 不会覆盖它。 这可能是分离 ``lwt``、``tc`` 和 ``xdp`` 映射以便在它们中不共享 ``globals`` 的情况。"

#: ../../bpf.rst:2778 fac894dacec14f01bbdeba134b0db221
msgid ""
"As briefly covered in the previous LLVM section, iproute2 will install a header file upon installation which can "
"be included through the standard include path by BPF programs:"
msgstr ""
"正如前面 LLVM 部分简要介绍的那样，iproute2 将在安装时安装一个头文件，该头文件可以通过 BPF 程序通过标准路径包含："

#: ../../bpf.rst:2786 85ee97e215ca447fa1a4e951b9eb8dc4
msgid ""
"The purpose of this header file is to provide an API for maps and default section names used by programs. It's a "
"stable contract between iproute2 and BPF programs."
msgstr "此头文件的目的是为程序使用的映射和默认部分名称提供 API。 这是 iproute2 和 BPF 程序之间的稳定合约。"

#: ../../bpf.rst:2789 e5c61f8ead5948a2b0e017c1d076a5d1
msgid ""
"The map definition for iproute2 is ``struct bpf_elf_map``. Its members have been covered earlier in the LLVM "
"section of this document."
msgstr "有关 iproute2 的映射定义是``struct bpf_elf_map``，其内容已在本文档的 LLVM 部分前面介绍过。"

#: ../../bpf.rst:2792 8f193c01f2314831a545d5a712037770
msgid ""
"When parsing the BPF object file, the iproute2 loader will walk through all ELF sections. It initially fetches "
"ancillary sections like ``maps`` and ``license``. For ``maps``, the ``struct bpf_elf_map`` array will be checked "
"for validity and whenever needed, compatibility workarounds are performed. Subsequently all maps are created "
"with the user provided information, either retrieved as a pinned object, or newly created and then pinned into "
"the BPF file system. Next the loader will handle all program sections that contain ELF relocation entries for "
"maps, meaning that BPF instructions loading map file descriptors into registers are rewritten so that the "
"corresponding map file descriptors are encoded into the instructions immediate value, in order for the kernel to "
"be able to convert them later on into map kernel pointers. After that all the programs themselves are created "
"through the BPF system call, and tail called maps, if present, updated with the program's file descriptors."
msgstr ""
"在解析 BPF 目标文件时，iproute2 加载器将遍历所有 ELF 部分。 它最先获取辅助部分，如``maps`` 和``license``。 对于"
"``maps`` ，将检查``struct bpf_elf_map``数组的有效性，并在需要时执行兼容性变通办法。 随后，所有地图都是使用用户提"
"供的信息创建的，或者作为固定对象检索，或者是新创建的然后固定到 BPF 文件系统中。 接下来，加载器将处理所有包含映射"
"的 ELF 重定位条目的程序部分，这意味着将映射文件描述符加载到寄存器中的 BPF 指令被重写，以便相应的映射文件描述符被"
"编码为指令立即值，以便内核能够 以后能够将它们转换为映射内核指针。 之后，所有程序本身都是通过 BPF 系统调用创建的，"
"并且尾调用的映射（如果存在）会使用程序的文件描述符进行更新。"

#: ../../bpf.rst:2808 3ee747d1dc894bf78cee813f28bd8bb0
msgid "bpftool"
msgstr "bpftool"

#: ../../bpf.rst:2810 0864ebcebe974ea3898023766e4adecc
msgid ""
"bpftool is the main introspection and debugging tool around BPF and developed and shipped along with the Linux "
"kernel tree under ``tools/bpf/bpftool/``."
msgstr "bpftool 是围绕 BPF 的主要自测和调试工具，它与 Linux 内核树一起开发和发布在``tools/bpf/bpftool/`` 目录下。"

#: ../../bpf.rst:2813 a798881d91a641438480838c6d2a886d
msgid ""
"The tool can dump all BPF programs and maps that are currently loaded in the system, or list and correlate all "
"BPF maps used by a specific program. Furthermore, it allows to dump the entire map's key / value pairs, or "
"lookup, update, delete individual ones as well as retrieve a key's neighbor key in the map. Such operations can "
"be performed based on BPF program or map IDs or by specifying the location of a BPF file system pinned program "
"or map. The tool additionally also offers an option to pin maps or programs into the BPF file system."
msgstr ""
"该工具可以转储系统中当前加载的所有 BPF 程序和映射，或者列出并关联特定程序使用的所有 BPF 映射。 此外，它允许转储整"
"个映射的键/值对，或查找、更新、删除单个键，以及检索映射中键的邻居键。 可以基于 BPF 程序或映射 ID 或通过指定 BPF "
"文件系统固定程序或映射的位置来执行此类操作。 该工具还提供了将地图或程序固定到 BPF 文件系统中的选项。"

#: ../../bpf.rst:2822 0e5ad438bdf44017b5873933a6155037
msgid "For a quick overview of all BPF programs currently loaded on the host invoke the following command:"
msgstr "要快速浏览主机上当前加载的所有 BPF 程序，请调用以下命令："

#: ../../bpf.rst:2842 f42567457337402b934127357ab9be80
msgid "Similarly, to get an overview of all active maps:"
msgstr "同样，要获得所有活动映射的概览："

#: ../../bpf.rst:2859 e6cb508762b94ea29328573f03bc7fe2
msgid ""
"Note that for each command, bpftool also supports json based output by appending ``--json`` at the end of the "
"command line. An additional ``--pretty`` improves the output to be more human readable."
msgstr ""
"bpftool 的每个命令都提供了以 json 格式打印的功能，在命令末尾指定 ``--json`` 就行了。 另外 ``--pretty`` 会使得打印"
"更加美观，看起来更清楚。"

#: ../../bpf.rst:2867 1445d796640f469db7ac79ed00f22a6e
msgid ""
"For dumping the post-verifier BPF instruction image of a specific BPF program, one starting point could be to "
"inspect a specific program, e.g. attached to the tc ingress hook:"
msgstr ""
"要 dump 特定 BPF 程序的 post-verifier BPF 指令镜像（instruction image），可以先从查看一个具体程序开始，例如查看 "
"attach 到 tc ingress hook 上的程序："

#: ../../bpf.rst:2878 d1bffe2af0874efda77727d54dfc4710
msgid ""
"The program from the object file ``bpf_host.o``, section ``from-netdev`` has a BPF program ID of ``406`` as "
"denoted in ``id 406``. Based on this information bpftool can provide some high-level metadata specific to the "
"program:"
msgstr ""
"来自目标文件``pf_host.o``，``from-netdev``部分的程序有一个ID为``406``的BPF程序会被显示为``id 406``所示。 基于这些"
"信息，bpftool 可以提供一些特定于程序的高级元数据："

#: ../../bpf.rst:2889 f06c0a603f974faeb6aba8bb6eedd523
msgid ""
"The program of ID 406 is of type ``sched_cls`` (``BPF_PROG_TYPE_SCHED_CLS``), has a ``tag`` of "
"``e0362f5bd9163a0a`` (SHA sum over the instruction sequence), it was loaded by root ``uid 0`` on ``Apr "
"09/16:24``. The BPF instruction sequence is ``11,144 bytes`` long and the JITed image ``7,721 bytes``. The "
"program itself (excluding maps) consumes ``12,288 bytes`` that are accounted / charged against user ``uid 0``. "
"And the BPF program uses the BPF maps with IDs ``18``, ``20``, ``8``, ``5``, ``6`` and ``14``. The latter IDs "
"can further be used to get information or dump the map themselves."
msgstr ""
"ID 406 的程序是 ``sched_cls`` 类型（``BPF_PROG_TYPE_SCHED_CLS``），具有``e0362f5bd9163a0a`` 的``标签`` （指令序列"
"上的 SHA 和），它是由 root 加载的 uid 0`` 在``Apr 09/16:24``。 BPF 指令序列是 ``11,144 字节`` 长，而 JITed 镜像"
"是 ``7,721 字节``。 程序本身（不包括映射）消耗 12,288 字节，这些字节是份配给用户``uid 0``的。 BPF 程序使用 ID 为"
"``18``、``20``、``8``、``5``、``6``和``14``的 BPF 映射。 后面的 ID 可进一步用于获取信息或转储映射本身。"

#: ../../bpf.rst:2898 87fefd74749e4e3abdf8bfce83ec7b7e
msgid "Additionally, bpftool can issue a dump request of the BPF instructions the program runs:"
msgstr "此外，bpftool 可以发出程序运行的 BPF 指令的转储请求："

#: ../../bpf.rst:2919 7356c8077e5e4da08dcd1bac49f36b5e
msgid ""
"bpftool correlates BPF map IDs into the instruction stream as shown above as well as calls to BPF helpers or "
"other BPF programs."
msgstr "bpftool 会将 BPF 映射 ID 关联到如上所示的指令流以及对 BPF 辅助函数或其他 BPF 程序的调用总。"

#: ../../bpf.rst:2922 bf2c5a5b72ae42f7976dbdd4f8be3cf5
msgid ""
"The instruction dump reuses the same 'pretty-printer' as the kernel's BPF verifier. Since the program was JITed "
"and therefore the actual JIT image that was generated out of above ``xlated`` instructions is executed, it can "
"be dumped as well through bpftool:"
msgstr ""
"指令转储重用与内核的 BPF 验证器相同的’pretty-printer’ 。 由于程序是 JIT 的，因此真正执行的是生成的 JIT 镜像（从上"
"面 ``xlated`` 中的指令生成的 ），这些指令也可以通过 ``bpftool`` 查看："

#: ../../bpf.rst:2943 3ed19b1cb22c41e196ddc48713277235
msgid ""
"Mainly for BPF JIT developers, the option also exists to interleave the disassembly with the actual native "
"opcodes:"
msgstr "主要针对 BPF JIT 开发人员，还存在将反汇编与实际本机操作码交错的选项："

#: ../../bpf.rst:2967 ea13fae069f44f02b58b98fb6f918978
msgid ""
"The same interleaving can be done for the normal BPF instructions which can sometimes be useful for debugging in "
"the kernel:"
msgstr "可以对普通的 BPF 指令进行相同的交错，这有时对内核中的调试很有用："

#: ../../bpf.rst:2987 5da16dc927704490b1d838ce759b0f30
msgid ""
"The basic blocks of a program can also be visualized with the help of ``graphviz``. For this purpose bpftool has "
"a ``visual`` dump mode that generates a dot file instead of the plain BPF ``xlated`` instruction dump that can "
"later be converted to a png file:"
msgstr ""
"程序的基本块也可以在``graphviz``的帮助下可视化。 为此，bpftool 有一个 ``visual`` 转储模式，它生成一个点文件，而不"
"是以后可以转换为 png 文件的普通 BPF ``xlated`` 指令转储："

#: ../../bpf.rst:2997 3d8d774978974937aa62f9bfec369f11
msgid ""
"Another option would be to pass the dot file to dotty as a viewer, that is ``dotty output.dot``, where the "
"result for the ``bpf_host.o`` program looks as follows (small extract):"
msgstr ""
"另一种选择是将 dot 文件作为查看器传递给 dotty，即``dotty output.dot``，``bpf_host.o``程序的结果如下所示（小摘"
"录）："

#: ../../bpf.rst:3004 045cfea5e58540b4905a8a5de87692d0
msgid ""
"Note that the ``xlated`` instruction dump provides the post-verifier BPF instruction image which means that it "
"dumps the instructions as if they were to be run through the BPF interpreter. In the kernel, the verifier "
"performs various rewrites of the original instructions provided by the BPF loader."
msgstr ""
"请注意，``xlated`` 指令转储提供了对 BPF 指令映像的后校验，这意味着它当转储指令时就会如同要通过 BPF 解释器运行一遍"
"一样。 而在内核中，验证器对 BPF 加载器提供的原始指令进行了各种重写。"

#: ../../bpf.rst:3010 a85e3367752e4029b46ad418e1deadab
msgid ""
"One example of rewrites is the inlining of helper functions in order to improve runtime performance, here in the "
"case of a map lookup for hash tables:"
msgstr "重写的一个例子是辅助函数的内联，以提高运行时性能，这里是哈希表的映射查找："

#: ../../bpf.rst:3031 46f060bdc7c94c87bc16848fd3b3c75f
msgid ""
"bpftool correlates calls to helper functions or BPF to BPF calls through kallsyms. Therefore, make sure that "
"JITed BPF programs are exposed to kallsyms (``bpf_jit_kallsyms``) and that kallsyms addresses are not obfuscated "
"(calls are otherwise shown as ``call bpf_unspec#0``):"
msgstr ""
"bpftool 通过 kallsyms 将对辅助函数的调用或 BPF 与 BPF 调用相关联。 因此，确保 JITed BPF 程序暴露给 kallsyms "
"(``bpf_jit_kallsyms``) 并且 kallsyms 地址没有被混淆（调用显示为 ``call bpf_unspec#0``）："

#: ../../bpf.rst:3041 e03e61ca5235457aa9175630436e104e
msgid ""
"BPF to BPF calls are correlated as well for both, interpreter as well as JIT case. In the latter, the tag of the "
"subprogram is shown as call target. In each case, the ``pc+2`` is the pc-relative offset of the call target, "
"which denotes the subprogram."
msgstr ""
"BPF 到 BPF 的调用对于解释器和 JIT 案例也是相关的。 在后者中，子程序的标签显示为调用目标。 在每种情况下，``pc+2`` "
"是调用目标的相对于 pc 的偏移量表示子程序。"

#: ../../bpf.rst:3055 b50101362238470cb0628f9f9fc0613c
msgid "JITed variant of the dump:"
msgstr "转储的 JIT 变体："

#: ../../bpf.rst:3066 4908995e1ec141aaadba26441d3e33b2
msgid ""
"In the case of tail calls, the kernel maps them into a single instruction internally, bpftool will still "
"correlate them as a helper call for ease of debugging:"
msgstr "在尾调用的情况下，内核在内部将它们映射到一条指令中，bpftool 仍会将它们关联为辅助调用，以便于调试："

#: ../../bpf.rst:3089 d43ed68943c444bfb756ec045d99bd6a
msgid ""
"Dumping an entire map is possible through the ``map dump`` subcommand which iterates through all present map "
"elements and dumps the key / value pairs."
msgstr "可以通过``map dump``子命令转储整个影射，该命令遍历所有存在的映射元素并转储为键/值对。"

#: ../../bpf.rst:3093 f9172d3fdd964afca6a3a212ef2e2628
msgid ""
"If no BTF (BPF Type Format) data is available for a given map, then the key / value pairs are dumped as hex:"
msgstr "如果给定映射没有可用的 BTF（BPF 类型格式）数据，则键/值对将转储为十六进制："

#: ../../bpf.rst:3119 e804c4c1681b4c40b3e8e58fe4007608
msgid ""
"However, with BTF, the map also holds debugging information about the key and value structures. For example, BTF "
"in combination with BPF maps and the BPF_ANNOTATE_KV_PAIR() macro from iproute2 will result in the following "
"dump (``test_xdp_noinline.o`` from kernel selftests):"
msgstr ""
"即使使用 BTF存储映射，数据中还会包含有关键和值结构的调试信息。 例如BTF 将结合 BPF 映射和 iproute2 中的 "
"BPF_ANNOTATE_KV_PAIR() 宏将进行以下转储（来自内核自测的``test_xdp_noinline.o``）："

#: ../../bpf.rst:3148 3a389b6f4a7f42069a2a95152933749a
msgid ""
"The BPF_ANNOTATE_KV_PAIR() macro forces a map-specific ELF section containing an empty key and value, this "
"enables the iproute2 BPF loader to correlate BTF data with that section and thus allows to choose the "
"corresponding types out of the BTF for loading the map."
msgstr ""
"``BPF_ANNOTATE_KV_PAIR()``宏强制映射特定的 ELF 部分包含一个空键和值，这使 iproute2 BPF 加载器能够将 BTF 数据与该"
"部分相关联，从而允许从 BTF 中选择相应的类型来加载映射。"

#: ../../bpf.rst:3153 2fdb012881644da9b598ed945492ac3e
msgid "Compiling through LLVM and generating BTF through debugging information by ``pahole``:"
msgstr "通过 LLVM 编译并通过 ``pahole`` 调试信息生成 BTF："

#: ../../bpf.rst:3162 92b239d050e04edc84afd1d0e4ca54e1
msgid "Now loading into kernel and dumping the map via bpftool:"
msgstr "现在加载到内核并通过 bpftool 转储映射："

#: ../../bpf.rst:3201 8f87b4abe5154725b0e1f8559d9622b4
msgid ""
"Lookup, update, delete, and 'get next key' operations on the map for specific keys can be performed through "
"bpftool as well."
msgstr "也可以通过 bpftool 在映射上针对特定键执行查找、更新、删除和’获取下一个键‘的操作。"

#: ../../bpf.rst:3204 608ab59d44cb4ab896e955cf7a9f32ef
msgid ""
"If the BPF program has been successfully loaded with BTF debugging information, the BTF ID will be shown in "
"``prog show`` command result denoted in ``btf_id``."
msgstr "如果 BPF 程序已成功加载 BTF 调试信息，BTF ID 将显示在 ``btf_id`` 中表示的``prog show`` 命令结果中。"

#: ../../bpf.rst:3215 57e6d4dfbc854c588a66adcf45484a3c
msgid "This can also be confirmed with ``btf show`` command which dumps all BTF objects loaded on a system."
msgstr "也可以通过 ``btf show`` 命令确认，该命令转储系统上加载的所有 BTF 对象。"

#: ../../bpf.rst:3223 e66ac5f9e16543e0924360c0141f891f
msgid ""
"And the subcommand ``btf dump`` can be used to check which debugging information is included in the BTF. With "
"this command, BTF dump can be formatted either 'raw' or 'c', the one that is used in C code."
msgstr ""
"并且可以使用子命令``btf dump``来检查 BTF 中包含哪些调试信息。 使用此命令，BTF 转储可以格式化为 ‘raw’ 或’c’，即 C "
"代码中使用的格式。"

#: ../../bpf.rst:3243 e8f23240405a432f819038577fff1643
msgid "BPF sysctls"
msgstr "BPF sysctls"

#: ../../bpf.rst:3245 7abe8fdfa8f1443eac15fed8e7db975a
msgid "The Linux kernel provides few sysctls that are BPF related and covered in this section."
msgstr "Linux 内核提供了一些与 BPF 相关并在本节中介绍的 sysctl。"

#: ../../bpf.rst:3247 5f9c36a919a440c99b41a86c74d223f2
msgid "``/proc/sys/net/core/bpf_jit_enable``: Enables or disables the BPF JIT compiler."
msgstr "``/proc/sys/net/core/bpf_jit_enable``：启用或禁用 BPF JIT 编译器。"

#: ../../bpf.rst:3250 ../../bpf.rst:3268 ../../bpf.rst:3285 ../../bpf.rst:3302 6fd3f8e79aed4a31bf0ea026a8ec239a
#: 77081c0481134526a2a4da36aed020a0 8e22da9f4b0b4257bc513138c7cc8d13 c0d5153f874f4705aeda524eed77e349
msgid "Value"
msgstr "Value"

#: ../../bpf.rst:3250 ../../bpf.rst:3268 ../../bpf.rst:3285 ../../bpf.rst:3302 0597706e9b9a4942b1a7f58f83099c6f
#: 24d8d362901c4948b02e08e169de67ac 5451b16529994451b9102d1ad0e2c09b c4a87c357bcb40b9aac2064ef4240d6c
msgid "Description"
msgstr "Description"

#: ../../bpf.rst:3252 ../../bpf.rst:3270 ../../bpf.rst:3287 ../../bpf.rst:3304 1f17f020c52b4641a76972103b6063c7
#: 456e224134254afab21fe8b5010271df a7e2732549ce4ca6bd4aab85d2c316ef cf68f708bc9d46338003b4469f894849
msgid "0"
msgstr "0"

#: ../../bpf.rst:3252 f5508a6564aa400ea230010f8f3ecbd4
msgid "Disable the JIT and use only interpreter (kernel's default value)"
msgstr "禁用 JIT 并仅使用解释器（内核的默认值）"

#: ../../bpf.rst:3254 ../../bpf.rst:3272 ../../bpf.rst:3289 ../../bpf.rst:3306 06ef6d1e2fca400a8e8cf4d2d6f27ccf
#: 0d1003728ed74f54a025d4582858972c b84170b3d9ab4c07b94a8c74edb0e43c b9e083c74a1740bf91679623ebdef937
msgid "1"
msgstr "1"

#: ../../bpf.rst:3254 0c042c38c6014035bb3dbdba6563067e
msgid "Enable the JIT compiler"
msgstr "启用 JIT 编译器"

#: ../../bpf.rst:3256 ../../bpf.rst:3274 1f75d9bbbaa644fb857f89b40b495e62 3886396f41df4cd28c744eddd3504725
msgid "2"
msgstr "2"

#: ../../bpf.rst:3256 c1d5eae20fb64e8d90a7ae3902e818b2
msgid "Enable the JIT and emit debugging traces to the kernel log"
msgstr "启用 JIT 并将调试跟踪发送到内核日志"

#: ../../bpf.rst:3259 a438dc81596846b6b0a5959ebf4d5ae9
msgid ""
"As described in subsequent sections, ``bpf_jit_disasm`` tool can be used to process debugging traces when the "
"JIT compiler is set to debugging mode (option ``2``)."
msgstr "如后续部分所述，当 JIT 编译器设置为调试模式（选项 ``2``）时，``bpf_jit_disasm`` 工具可用于处理调试跟踪。"

#: ../../bpf.rst:3262 2fa4f56949a24eb98102948fb9207976
msgid ""
"``/proc/sys/net/core/bpf_jit_harden``: Enables or disables BPF JIT hardening. Note that enabling hardening "
"trades off performance, but can mitigate JIT spraying by blinding out the BPF program's immediate values. For "
"programs processed through the interpreter, blinding of immediate values is not needed / performed."
msgstr ""
"``/proc/sys/net/core/bpf_jit_harden``：启用或禁用 BPF JIT 加固。 请注意启用加固会牺牲性能，但可以通过屏蔽 BPF 程"
"序的即时值来减轻 JIT 喷射攻击。 对于通过解释器处理的程序，不需要/执行立即值的盲法。"

#: ../../bpf.rst:3270 3c70e4e211354e34b3de69870e973f1f
msgid "Disable JIT hardening (kernel's default value)"
msgstr "禁用 JIT 加固（内核的默认值）"

#: ../../bpf.rst:3272 6f1e8c5b106c49d48f5e75812a7019bd
msgid "Enable JIT hardening for unprivileged users only"
msgstr "仅对非特权用户启用 JIT 加固"

#: ../../bpf.rst:3274 47d994bc69634dc491ef0f69b059d4ed
msgid "Enable JIT hardening for all users"
msgstr "为所有用户启用 JIT 加固"

#: ../../bpf.rst:3277 57161413a8674cb88113ab19110774e1
msgid ""
"``/proc/sys/net/core/bpf_jit_kallsyms``: Enables or disables export of JITed programs as kernel symbols to ``/"
"proc/kallsyms`` so that they can be used together with ``perf`` tooling as well as making these addresses aware "
"to the kernel for stack unwinding, for example, used in dumping stack traces. The symbol names contain the BPF "
"program tag (``bpf_prog_<tag>``). If ``bpf_jit_harden`` is enabled, then this feature is disabled."
msgstr ""
"``/proc/sys/net/core/bpf_jit_kallsyms``：启用或禁用将 JIT 程序作为内核符号导出到 ``/proc/kallsyms`` 以便它们也可"
"以与 ``perf`` 工具一起使用 让内核知道这些地址以进行堆栈展开，例如用于转储堆栈跟踪。 符号名称包含BPF 程序标签"
"（``bpf_prog_<tag>``）。 如果启用了``bpf_jit_harden``则禁用此功能。"

#: ../../bpf.rst:3287 e9f4f92d3297445fa569235e733f7763
msgid "Disable JIT kallsyms export (kernel's default value)"
msgstr "禁用 JIT kallsyms 导出（内核的默认值）"

#: ../../bpf.rst:3289 e184ddf0f1b64fe0b10caf6f5a27cbb1
msgid "Enable JIT kallsyms export for privileged users only"
msgstr "仅为特权用户启用 JIT kallsyms 导出"

#: ../../bpf.rst:3292 0ec4e33e1411412ea4519db28d0c7583
msgid ""
"``/proc/sys/kernel/unprivileged_bpf_disabled``: Enables or disable unprivileged use of the ``bpf(2)`` system "
"call. The Linux kernel has unprivileged use of ``bpf(2)`` enabled by default, but once the switch is flipped, "
"unprivileged use will be permanently disabled until the next reboot. This sysctl knob is a one-time switch, "
"meaning if once set, then neither an application nor an admin can reset the value anymore. This knob does not "
"affect any cBPF programs such as seccomp or traditional socket filters that do not use the ``bpf(2)`` system "
"call for loading the program into the kernel."
msgstr ""
"``/proc/sys/kernel/unprivileged_bpf_disabled``：启用或禁用 ``bpf(2)`` 系统调用的非特权使用。 Linux 内核默认启用 "
"``bpf(2)`` 的非特权使用，但是一旦切换开关，非特权使用将被永久禁用直到下次重新启动。 这个 sysctl 旋钮是一次性开"
"关，这意味着一旦设置，应用程序和管理员都不能再重置该值。 此选项不会影响任何 cBPF 程序，例如 seccomp 或不使用 "
"``bpf(2)`` 系统调用将程序加载到内核中的传统套接字过滤器。"

#: ../../bpf.rst:3304 e689cae725c34473b4b16b03b02002bc
msgid "Unprivileged use of bpf syscall enabled (kernel's default value)"
msgstr "开启 bpf syscall 的非特权使用（内核的默认值）"

#: ../../bpf.rst:3306 9b867af2a974403f9439866729cf87d4
msgid "Unprivileged use of bpf syscall disabled"
msgstr "禁用 bpf 系统调用的非特权使用"

#: ../../bpf.rst:3310 60643390ed3c46daa845e025a69c090d
msgid "Kernel Testing"
msgstr "内核测试"

#: ../../bpf.rst:3312 b0c267ec9c7844119752021c8442308d
msgid ""
"The Linux kernel ships a BPF selftest suite, which can be found in the kernel source tree under ``tools/testing/"
"selftests/bpf/``."
msgstr "Linux 内核提供了一个 BPF 自测套件，它可以在内核源代码树的``tools/testing/selftests/bpf/`` 下找到。"

#: ../../bpf.rst:3321 fdce0bd9063547b6b6974ee8b332c81f
msgid ""
"The test suite contains test cases against the BPF verifier, program tags, various tests against the BPF map "
"interface and map types. It contains various runtime tests from C code for checking LLVM back end, and eBPF as "
"well as cBPF asm code that is run in the kernel for testing the interpreter and JITs."
msgstr ""
"测试套件包含针对 BPF 验证器的测试用例、程序标签、以及针对 BPF 映射接口和映射类型的各种测试。 它包含来自 C 代码的"
"各种运行时测试，用于检查 LLVM 后端，以及 eBPF 以及在内核中运行的用于测试解释器和 JIT 的 cBPF asm 代码。"

#: ../../bpf.rst:3327 ad24f88ca470445eab292f2971220374
msgid "JIT Debugging"
msgstr "JIT 调试"

#: ../../bpf.rst:3329 39ef289cc15943dbaaa3b6eab6420866
msgid ""
"For JIT developers performing audits or writing extensions, each compile run can output the generated JIT image "
"into the kernel log through:"
msgstr "对于执行审计或编写扩展的 JIT 开发人员，每次编译运行都可以通过以下方式将生成的 JIT 映像输出到内核日志中："

#: ../../bpf.rst:3336 0b252ca2194b46e68e16185140884eae
msgid ""
"Whenever a new BPF program is loaded, the JIT compiler will dump the output, which can then be inspected with "
"``dmesg``, for example:"
msgstr "每当加载新的 BPF 程序时，JIT 编译器都会转储输出，然后可以使用 ``dmesg`` 检查，例如："

#: ../../bpf.rst:3348 f93ed4cab4504bd08e74eb36d31e4f06
msgid ""
"``flen`` is the length of the BPF program (here, 6 BPF instructions), and ``proglen`` tells the number of bytes "
"generated by the JIT for the opcode image (here, 70 bytes in size). ``pass`` means that the image was generated "
"in 3 compiler passes, for example, ``x86_64`` can have various optimization passes to further reduce the image "
"size when possible. ``image`` contains the address of the generated JIT image, ``from`` and ``pid`` the user "
"space application name and PID respectively, which triggered the compilation process. The dump output for eBPF "
"and cBPF JITs is the same format."
msgstr ""
"``flen`` 是 BPF 程序的长度（这里是 6 个 BPF 指令），``proglen`` 告诉 JIT 为操作码图像生成的字节数（这里是 70 字节"
"大小）。 ``pass`` 表示图像是在 3 个编译器通道中生成的，例如``x86_64`` 可以有各种优化通道，从而在可能的情况下进一"
"步减小图像大小。 ``image`` 包含生成的 JIT 映像的地址，``from`` 和 ``pid`` 分别是用户空间应用程序名称和 PID，它们"
"触发了编译过程。 eBPF 和 cBPF JIT 的转储输出格式相同。"

#: ../../bpf.rst:3356 5f52c1aeb2424f28b49db73069b262ef
msgid ""
"In the kernel tree under ``tools/bpf/``, there is a tool called ``bpf_jit_disasm``. It reads out the latest dump "
"and prints the disassembly for further inspection:"
msgstr ""
"在 ``tools/bpf/`` 下的内核树中，有一个名为 ``bpf_jit_disasm`` 的工具。 它读出最新的转储并打印反汇编以供进一步检"
"查："

#: ../../bpf.rst:3385 283dc339ae8a46669d9b174930049300
msgid "Alternatively, the tool can also dump related opcodes along with the disassembly."
msgstr "或者，该工具还可以将相关操作码与反汇编一起转储。"

#: ../../bpf.rst:3433 f743010e78c54eb1a7226693ae1deff0
msgid ""
"More recently, ``bpftool`` adapted the same feature of dumping the BPF JIT image based on a given BPF program ID "
"already loaded in the system (see bpftool section)."
msgstr ""
"最近，``bpftool`` 拥有基于已经加载到系统中的给定 BPF 程序 的ID 进行转储 BPF JIT 映像的相同功能（请参阅 bpftool 部"
"分）。"

#: ../../bpf.rst:3437 086ffacbaaf74b8a9160b80cbeeb5bd1
msgid ""
"For performance analysis of JITed BPF programs, ``perf`` can be used as usual. As a prerequisite, JITed programs "
"need to be exported through kallsyms infrastructure."
msgstr ""
"对于 JITed BPF 程序的性能分析，可以照常使用``perf``。 作为先决条件，需要通过 kallsyms 基础设施导出 JIT 程序。"

#: ../../bpf.rst:3446 63ec9ed1ca6a4c548a1c1d11645a5a16
msgid ""
"Enabling or disabling ``bpf_jit_kallsyms`` does not require a reload of the related BPF programs. Next, a small "
"workflow example is provided for profiling BPF programs. A crafted tc BPF program is used for demonstration "
"purposes, where perf records a failed allocation inside ``bpf_clone_redirect()`` helper. Due to the use of "
"direct write, ``bpf_try_make_head_writable()`` failed, which would then release the cloned ``skb`` again and "
"return with an error message. ``perf`` thus records all ``kfree_skb`` events."
msgstr ""
"启用或禁用 ``bpf_jit_kallsyms`` 不需要重新加载相关的 BPF 程序。 我们提供了一个小型工作流示例来分析 BPF 程序。 一"
"个精心制作的 tc BPF 程序用于演示目的，其中 perf 在 ``bpf_clone_redirect()`` 帮助程序中记录了失败的分配。 由于使用"
"直接写入``bpf_try_make_head_writable()`` 失败，然后会再次释放克隆的``skb`` 并返回错误消息。 在此过程中``perf`` 记"
"录了所有 ``kfree_skb`` 事件。"

#: ../../bpf.rst:3487 1902b120fbe2461e925eeda0b4cda984
msgid ""
"The stack trace recorded by ``perf`` will then show the ``bpf_prog_8227addf251b7543()`` symbol as part of the "
"call trace, meaning that the BPF program with the tag ``8227addf251b7543`` was related to the ``kfree_skb`` "
"event, and such program was attached to netdevice ``em1`` on the ingress hook as shown by tc."
msgstr ""
"因此 perf 记录的堆栈跟踪将显示 ``bpf_prog_8227addf251b7543()`` 符号作为调用跟踪的一部分，这意味着带有标签 "
"``8227addf251b7543`` 的 BPF 程序与 ``kfree_skb`` 事件相关，并且此类程序已附加到入口挂钩上的 netdevice ``em1``上，"
"如 tc 所示。"

#: ../../bpf.rst:3494 c5436a6f2f1b48ec814cf24e4f25194d
msgid "Introspection"
msgstr "自我检查"

#: ../../bpf.rst:3496 3c7e95fcff2d480b94ca33ca748632fa
msgid ""
"The Linux kernel provides various tracepoints around BPF and XDP which can be used for additional introspection, "
"for example, to trace interactions of user space programs with the bpf system call."
msgstr "Linux 内核围绕 BPF 和 XDP 提供了各种跟踪点可用于自我检查，例如，跟踪用户空间程序与 bpf 系统调用的交互。"

#: ../../bpf.rst:3500 787277f1202c4d958d54151181c50a23
msgid "Tracepoints for BPF:"
msgstr "BPF 的跟踪点："

#: ../../bpf.rst:3518 cdd18d42ca624f0b99d9f2ac36f40d8e
msgid ""
"Example usage with ``perf`` (alternatively to ``sleep`` example used here, a specific application like ``tc`` "
"could be used here instead, of course):"
msgstr ""
"使用 ``perf`` 的示例（作为此处使用的 ``sleep`` 示例的替代方法，当然可以在此处使用像 ``tc`` 之类的特定应用程序）："

#: ../../bpf.rst:3533 0ee1d9e4f8034732934dae6a7e44fe8e
msgid "For the BPF programs, their individual program tag is displayed."
msgstr "对于 BPF 程序，将显示它们各自的程序标签。"

#: ../../bpf.rst:3535 1d14dfd1a8f04fa0a0c1784298879e6a
msgid "For debugging, XDP also has a tracepoint that is triggered when exceptions are raised:"
msgstr "对于 BPF 程序，会显示它们各自的程序标签。对于调试，XDP 也有一个跟踪点，当引发异常时会触发该跟踪点："

#: ../../bpf.rst:3542 dad2c238763d410a8c2ec932ccdcc5a2
msgid "Exceptions are triggered in the following scenarios:"
msgstr "在以下情况下会触发异常："

#: ../../bpf.rst:3544 6c2a4b4c30c147158afee4dbb0d3ca98
msgid "The BPF program returned an invalid / unknown XDP action code."
msgstr "BPF 程序返回了一个无效/未知的 XDP 操作代码。"

#: ../../bpf.rst:3545 6fc04065aad74298b47075b696a1066c
msgid "The BPF program returned with ``XDP_ABORTED`` indicating a non-graceful exit."
msgstr "BPF 程序返回 XDP_ABORTED 表示非正常退出。"

#: ../../bpf.rst:3546 46d6138ebc0d4603be5d137c61d6e47c
msgid ""
"The BPF program returned with ``XDP_TX``, but there was an error on transmit, for example, due to the port not "
"being up, due to the transmit ring being full, due to allocation failures, etc."
msgstr "BPF 程序返回``XDP_TX``，但传输时出错，例如，由于端口未启动、传输环已满、分配失败等。"

#: ../../bpf.rst:3550 aaa39d2252284697bdb7da5da4e74e18
msgid ""
"Both tracepoint classes can also be inspected with a BPF program itself attached to one or more tracepoints, "
"collecting further information in a map or punting such events to a user space collector through the "
"``bpf_perf_event_output()`` helper, for example."
msgstr ""
"这两个跟踪点类也可以使用附加到一个或多个跟踪点的 BPF 程序中进行检查，在地图中收集更多信息或通过 "
"``bpf_perf_event_output()`` 帮助程序将此类事件推送到用户空间收集器。"

#: ../../bpf.rst:3556 ad7e9337a4894759b202b4659fea2258
msgid "Tracing pipe"
msgstr "追踪管道"

#: ../../bpf.rst:3558 c15a5d28543441bca473aeee67381f62
msgid ""
"When a BPF program makes a call to ``bpf_trace_printk()``, the output is sent to the kernel tracing pipe. Users "
"may read from this file to consume events that are traced to this buffer:"
msgstr ""
"当 BPF 程序调用 ``bpf_trace_printk()`` 时，输出被发送到内核跟踪管道。 用户可以从此文件中读取以使用跟踪到此缓冲区"
"的事件："

#: ../../bpf.rst:3569 eadd114e18714361a8ea37fa79b3b053
msgid "Miscellaneous"
msgstr "杂项"

#: ../../bpf.rst:3571 ca09a17587714f1c9209ae76cfc38adf
msgid ""
"BPF programs and maps are memory accounted against ``RLIMIT_MEMLOCK`` similar to ``perf``. The currently "
"available size in unit of system pages which may be locked into memory can be inspected through ``ulimit -l``. "
"The setrlimit system call man page provides further details."
msgstr ""
"BPF 程序和映射是会占内存的并可以通过 ``RLIMIT_MEMLOCK`` 调整。类似于``perf``，可以通过 ``ulimit -l`` 检查当前可用"
"的以系统页面为单位的可能被锁定到内存中的大小。 setrlimit 系统调用手册页提供了更多详细信息。"

#: ../../bpf.rst:3576 61935384fc844a19b8f9dcb705b31165
msgid ""
"The default limit is usually insufficient to load more complex programs or larger BPF maps, so that the BPF "
"system call will return with ``errno`` of ``EPERM``. In such situations a workaround with ``ulimit -l "
"unlimited`` or with a sufficiently large limit could be performed. The ``RLIMIT_MEMLOCK`` is mainly enforcing "
"limits for unprivileged users. Depending on the setup, setting a higher limit for privileged users is often "
"acceptable."
msgstr ""
"默认限制通常不足以加载更复杂的程序或更大的 BPF 映射，因此 BPF 系统调用将返回 ``EPERM`` 的 ``errno``。 在这种情况"
"下，可以使用``ulimit -l unlimited``或足够大的限制来解决。 ``RLIMIT_MEMLOCK`` 主要是对非特权用户实施限制。 根据设"
"置，为特权用户设置更高的限制通常是可以接受的。"

#: ../../bpf.rst:3584 3f650f26bb0f4275b67ee080124f7ae3
msgid "Program Types"
msgstr "程序类型"

#: ../../bpf.rst:3586 41048ca710824806a6b4e81f35dbdca8
msgid ""
"At the time of this writing, there are eighteen different BPF program types available, two of the main types for "
"networking are further explained in below subsections, namely XDP BPF programs as well as tc BPF programs. "
"Extensive usage examples for the two program types for LLVM, iproute2 or other tools are spread throughout the "
"toolchain section and not covered here. Instead, this section focuses on their architecture, concepts and use "
"cases."
msgstr ""
"在撰写本文时，有 18 种不同的 BPF 程序类型可用，以下小节将进一步解释两种主要的网络类型，即 XDP BPF 程序和 tc BPF "
"程序。 LLVM、iproute2 或其他工具的两种程序类型的广泛使用示例遍布整个工具链部分，此处不予介绍。 本节重点介绍它们的"
"架构、概念和用例。"

#: ../../bpf.rst:3594 486aca8503ad44eea4909237e0cf170b
msgid "XDP"
msgstr "XDP"

#: ../../bpf.rst:3596 cb2eaf11bef94a0782d19440823fdf9e
msgid ""
"XDP stands for eXpress Data Path and provides a framework for BPF that enables high-performance programmable "
"packet processing in the Linux kernel. It runs the BPF program at the earliest possible point in software, "
"namely at the moment the network driver receives the packet."
msgstr ""
"XDP（eXpress Data Path）提供了一个内核态、高性能、可编程 BPF 包处理框架（a framework for BPF that enables high-"
"performance programmable packet processing in the Linux kernel）。这个框架在软件中最早可以处理包的位置（即网卡驱"
"动收到包的 时刻）运行 BPF 程序。"

#: ../../bpf.rst:3601 3628df474e5249998ce9292c12a87de2
msgid ""
"At this point in the fast-path the driver just picked up the packet from its receive rings, without having done "
"any expensive operations such as allocating an ``skb`` for pushing the packet further up the networking stack, "
"without having pushed the packet into the GRO engine, etc. Thus, the XDP BPF program is executed at the earliest "
"point when it becomes available to the CPU for processing."
msgstr ""
"XDP hook 位于网络驱动的快速路径上，XDP 程序直接从接收缓冲区（receive ring）中将 包拿下来，无需执行任何耗时的操"
"作，例如分配 ``skb`` 然后将包推送到网络协议栈，或者将包推送给 GRO 引擎等等。因此，只要有 CPU 资源，XDP BPF 程序就"
"能够在最早的位置执行处理。"

#: ../../bpf.rst:3608 9b0527e9bced46d6ace9535c2a98e824
msgid ""
"XDP works in concert with the Linux kernel and its infrastructure, meaning the kernel is not bypassed as in "
"various networking frameworks that operate in user space only. Keeping the packet in kernel space has several "
"major advantages:"
msgstr ""
"XDP 与 Linux 内核及其基础架构协同工作，这意味着内核不会像在仅在用户空间中运行的各种网络框架中那样被绕过。 将数据"
"包保存在内核空间有几个主要优点："

#: ../../bpf.rst:3613 0ff5ab32415f45339e0c055a7fb11051
msgid ""
"XDP is able to reuse all the upstream developed kernel networking drivers, user space tooling, or even other "
"available in-kernel infrastructure such as routing tables, sockets, etc in BPF helper calls itself."
msgstr ""
"XDP 能够在 BPF 辅助调用本身中重用所有上游开发的内核网络驱动程序、用户空间工具，甚至其他可用的内核基础设施，如路由"
"表、套接字等。"

#: ../../bpf.rst:3616 40e4302a477b4770b5498ebd44d9c2f6
msgid "Residing in kernel space, XDP has the same security model as the rest of the kernel for accessing hardware."
msgstr "XDP 放在内核空间中，具有与内核其余部分相同的安全模型，可用于访问硬件。"

#: ../../bpf.rst:3618 92c43536088f48178749625da0ec783d
msgid ""
"There is no need for crossing kernel / user space boundaries since the processed packet already resides in the "
"kernel and can therefore flexibly forward packets into other in-kernel entities like namespaces used by "
"containers or the kernel's networking stack itself. This is particularly relevant in times of Meltdown and "
"Spectre."
msgstr ""
"因为处理后的数据包已经驻留在内核中所以无需跨越内核/用户空间边界，所以可以灵活地将数据包转发到其他内核实体，如容器"
"使用的命名空间或内核的网络堆栈本身。 这在 Meltdown 和 Spectre 漏洞尤为重要。"

#: ../../bpf.rst:3623 43f4daded88e46e38226490ec751d2ad
msgid ""
"Punting packets from XDP to the kernel's robust, widely used and efficient TCP/IP stack is trivially possible, "
"allows for full reuse and does not require maintaining a separate TCP/IP stack as with user space frameworks."
msgstr ""
"将数据包从 XDP 转移到内核的健壮、广泛使用和高效的 TCP/IP 堆栈是很可能的，允许完全重用，并且不需要像用户空间框架那"
"样维护单独的 TCP/IP 堆栈。"

#: ../../bpf.rst:3626 8d051587c85248248a4374aeb3eb5fea
msgid ""
"The use of BPF allows for full programmability, keeping a stable ABI with the same 'never-break-user-space' "
"guarantees as with the kernel's system call ABI and compared to modules it also provides safety measures thanks "
"to the BPF verifier that ensures the stability of the kernel's operation."
msgstr ""
"BPF 的使用允许完全的可编程性，保持稳定的 ABI 与内核的系统调用 ABI 相同的“永不中断用户空间”保证，并且与模块相比，"
"它还提供了安全措施，这要归功于 BPF 验证程序确保内核运行的稳定性。"

#: ../../bpf.rst:3630 b82d43a35787436aa719d0c2b9bb6b99
msgid ""
"XDP trivially allows for atomically swapping programs during runtime without any network traffic interruption or "
"even kernel / system reboot."
msgstr "DP 允许在运行时自动交换程序，而不会中断任何网络流量，甚至不会重新启动内核/系统。"

#: ../../bpf.rst:3632 bac802f20eb14b5b99a6939ca2091cc9
msgid ""
"XDP allows for flexible structuring of workloads integrated into the kernel. For example, it can operate in "
"\"busy polling\" or \"interrupt driven\" mode. Explicitly dedicating CPUs to XDP is not required. There are no "
"special hardware requirements and it does not rely on hugepages."
msgstr ""
"XDP 允许灵活地构建集成到内核中的工作负载。 例如，它可以在“忙轮询”或“中断驱动”模式下运行。 不需要显式地将 CPU 专用"
"于 XDP。 没有特殊的硬件要求，它不依赖于大页。"

#: ../../bpf.rst:3636 c915d07e071f4467ba55d124735c7032
msgid ""
"XDP does not require any third party kernel modules or licensing. It is a long-term architectural solution, a "
"core part of the Linux kernel, and developed by the kernel community."
msgstr "XDP 不需要任何第三方内核模块或许可。 它是一个长期的架构解决方案，是 Linux 内核的核心部分，由内核社区开发。"

#: ../../bpf.rst:3639 05b24ff2e2ff4ae58849bb8b2d670fe2
msgid ""
"XDP is already enabled and shipped everywhere with major distributions running a kernel equivalent to 4.8 or "
"higher and supports most major 10G or higher networking drivers."
msgstr ""
"XDP 已启用并随主要发行版随处提供，其内核相当于 4.8 或更高版本，并支持大多数主要的 10G 或更高版本的网络驱动程序。"

#: ../../bpf.rst:3643 ff2e06a32c3f45ec8484798a04d64a38
msgid ""
"As a framework for running BPF in the driver, XDP additionally ensures that packets are laid out linearly and "
"fit into a single DMA'ed page which is readable and writable by the BPF program. XDP also ensures that "
"additional headroom of 256 bytes is available to the program for implementing custom encapsulation headers with "
"the help of the ``bpf_xdp_adjust_head()`` BPF helper or adding custom metadata in front of the packet through "
"``bpf_xdp_adjust_meta()``."
msgstr ""
"作为在驱动程序中运行 BPF 的框架，XDP 还确保数据包呈线性布局，并适合 BPF 程序可读写的单个 DMA 页面。 XDP 还确保额"
"外的 256 字节空间可用于在 ``bpf_xdp_adjust_head()`` BPF 帮助器的帮助下实现自定义封装头，或通过 "
"``bpf_xdp_adjust_meta() `` 在数据包前面添加自定义元数据 ."

#: ../../bpf.rst:3650 2e5c3acfe93f433fb472b876db5cb26c
msgid ""
"The framework contains XDP action codes further described in the section below which a BPF program can return in "
"order to instruct the driver how to proceed with the packet, and it enables the possibility to atomically "
"replace BPF programs running at the XDP layer. XDP is tailored for high-performance by design. BPF allows to "
"access the packet data through 'direct packet access' which means that the program holds data pointers directly "
"in registers, loads the content into registers, respectively writes from there into the packet."
msgstr ""
"下节进一步描述的 XDP 操作代码，BPF 程序可以返回这些代码以指示驱动程序如何处理数据包，并且它可以原子地替换在 XDP "
"层运行的 BPF 程序。 XDP 专为高性能而设计，因此BPF 允许通过“直接数据包访问”访问数据包数据，这意味着程序直接将数据"
"指针保存在寄存器中，将内容加载到寄存器中，然后分别从那里写入数据包。"

#: ../../bpf.rst:3659 cfaf0b1e1d9a40b1ada3358a19a11105
msgid "The packet representation in XDP that is passed to the BPF program as the BPF context looks as follows:"
msgstr "XDP 中作为 BPF 上下文传递给 BPF 程序的数据包表示形式如下所示："

#: ../../bpf.rst:3672 79067b4b43a440c19e6b04b4bc50e433
msgid ""
"``data`` points to the start of the packet data in the page, and as the name suggests, ``data_end`` points to "
"the end of the packet data. Since XDP allows for a headroom, ``data_hard_start`` points to the maximum possible "
"headroom start in the page, meaning, when the packet should be encapsulated, then ``data`` is moved closer "
"towards ``data_hard_start`` via ``bpf_xdp_adjust_head()``. The same BPF helper function also allows for "
"decapsulation in which case ``data`` is moved further away from ``data_hard_start``."
msgstr ""
"``data``指向页面中分组数据的开始，顾名思义，``data_end``指向分组数据的末尾。 由于 XDP 允许留有余量，"
"``data_hard_start`` 指向页面中最大可能的空间开始，这意味着当应该封装数据包时，``data`` 会通过``data_hard_start`` "
"靠近 bpf_xdp_adjust_head()``。 相同的 BPF 辅助函数还允许解封装，在这种情况下，``data`` 会远离"
"``data_hard_start``。"

#: ../../bpf.rst:3680 b0bef7369a4746878a4908b6dabe6b84
msgid ""
"``data_meta`` initially points to the same location as ``data`` but ``bpf_xdp_adjust_meta()`` is able to move "
"the pointer towards ``data_hard_start`` as well in order to provide room for custom metadata which is invisible "
"to the normal kernel networking stack but can be read by tc BPF programs since it is transferred from XDP to the "
"``skb``. Vice versa, it can remove or reduce the size of the custom metadata through the same BPF helper "
"function by moving ``data_meta`` away from ``data_hard_start`` again. ``data_meta`` can also be used solely for "
"passing state between tail calls similarly to the ``skb->cb[]`` control block case that is accessible in tc BPF "
"programs."
msgstr ""
"``data_meta`` 最初指向与``data`` 相同的位置，但``bpf_xdp_adjust_meta()`` 也能够将指针移向``data_hard_start``，以"
"便为不可见的自定义元数据提供空间 到正常的内核网络堆栈，但可以被 tc BPF 程序读取，因为它是从 XDP 传输到“skb”的。 "
"反之亦然，它可以通过相同的 BPF 辅助函数删除或减小自定义元数据的大小，方法是将 ``data_meta`` 再次从 "
"``data_hard_start`` 移开。 ``data_meta`` 也可以单独用于在尾调用之间传递状态，类似于在 tc BPF 程序中可访问的``skb-"
">cb[]`` 控制块案例。"

#: ../../bpf.rst:3690 b1d9869042754fc7a3ea7bd054b53886
msgid ""
"This gives the following relation respectively invariant for the ``struct xdp_buff`` packet pointers: "
"``data_hard_start`` <= ``data_meta`` <= ``data`` < ``data_end``."
msgstr ""
"这为 ``struct xdp_buff`` 数据包指针分别给出了以下关系：``data_hard_start`` <= ``data_meta`` <= ``data`` < "
"``data_end``。"

#: ../../bpf.rst:3693 b4b8ffec5fbd4585b6739111b473a253
msgid ""
"The ``rxq`` field points to some additional per receive queue metadata which is populated at ring setup time "
"(not at XDP runtime):"
msgstr "``rxq`` 字段指向一些额外的每个接收队列元数据，这些元数据在环设置时填充（而不是在 XDP 运行时）："

#: ../../bpf.rst:3704 72db231a3d594b5aa152f9dc8992ef93
msgid ""
"The BPF program can retrieve ``queue_index`` as well as additional data from the netdevice itself such as "
"``ifindex``, etc."
msgstr "BPF 程序可以检索``queue_index``以及来自网络设备本身的附加数据，例如``ifindex``等。"

#: ../../bpf.rst:3707 ../../bpf.rst:4122 26c7770582234a9bae5969d56a2768bb f2e2f25d185d4c1f898d3f99e46e4757
msgid "**BPF program return codes**"
msgstr "**BPF 程序返回码**"

#: ../../bpf.rst:3709 f5f7b4d67ec0405588c6cc523b335b05
msgid ""
"After running the XDP BPF program, a verdict is returned from the program in order to tell the driver how to "
"process the packet next. In the ``linux/bpf.h`` system header file all available return verdicts are enumerated:"
msgstr ""
"运行 XDP BPF 程序后，程序会返回一个判断，以便告诉驱动程序接下来如何处理数据包。 在 ``linux/bpf.h`` 系统头文件中枚"
"举了所有可用的返回判断："

#: ../../bpf.rst:3723 c8210f4521df4753b4a34d7349e6e7d6
msgid ""
"``XDP_DROP`` as the name suggests will drop the packet right at the driver level without wasting any further "
"resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling "
"in general. The ``XDP_PASS`` return code means that the packet is allowed to be passed up to the kernel's "
"networking stack. Meaning, the current CPU that was processing this packet now allocates a ``skb``, populates "
"it, and passes it onwards into the GRO engine. This would be equivalent to the default packet handling behavior "
"without XDP. With ``XDP_TX`` the BPF program has an efficient option to transmit the network packet out of the "
"same NIC it just arrived on again. This is typically useful when few nodes are implementing, for example, "
"firewalling with subsequent load balancing in a cluster and thus act as a hairpinned load balancer pushing the "
"incoming packets back into the switch after rewriting them in XDP BPF. ``XDP_REDIRECT`` is similar to ``XDP_TX`` "
"in that it is able to transmit the XDP packet, but through another NIC. Another option for the ``XDP_REDIRECT`` "
"case is to redirect into a BPF cpumap, meaning, the CPUs serving XDP on the NIC's receive queues can continue to "
"do so and push the packet for processing the upper kernel stack to a remote CPU. This is similar to "
"``XDP_PASS``, but with the ability that the XDP BPF program can keep serving the incoming high load as opposed "
"to temporarily spend work on the current packet for pushing into upper layers. Last but not least, "
"``XDP_ABORTED`` which serves denoting an exception like state from the program and has the same behavior as "
"``XDP_DROP`` only that ``XDP_ABORTED`` passes the ``trace_xdp_exception`` tracepoint which can be additionally "
"monitored to detect misbehavior."
msgstr ""
"顾名思义，``XDP_DROP`` 将在驱动程序级别丢弃数据包，而不会浪费任何进一步的资源。这对于实现 DDoS 缓解机制或一般防火"
"墙的 BPF 程序特别有用。 ``XDP_PASS`` 返回码意味着数据包被允许向上传递到内核的网络堆栈。这意味着，正在处理这个数据"
"包的当前 CPU 现在分配了一个``skb``，填充它然后将它传递给 GRO 引擎。这相当于没有 XDP 的默认数据包处理行为。使用"
"``XDP_TX``，BPF 程序有一个有效的选项，可以将网络数据包从它刚刚到达的同一个 NIC 中传输出去。当很少有节点正在实施"
"时，这通常很有用。例如防火墙和集群中的后续负载平衡，因此充当发夹式负载平衡器，将传入的数据包在 XDP BPF 中重写后推"
"回交换机。 ``XDP_REDIRECT`` 与``XDP_TX`` 相似之处在于它能够传输 XDP 数据包，但通过另一个 NIC。 ``XDP_REDIRECT`` "
"情况的另一个选项是重定向到 BPF cpumap，这意味着在 NIC 的接收队列上为 XDP 服务的 CPU 可以继续这样做，并将用于处理"
"上层内核堆栈的数据包推送到远程 CPU。这类似于``XDP_PASS``，但具有 XDP BPF 程序可以继续为传入的高负载提供服务的能"
"力，而不是暂时将工作花在当前数据包上以推送到上层。最后但并非最不重要的一点是，``XDP_ABORTED`` 用于表示程序中的异"
"常状态，并且具有与``XDP_DROP`` 相同的行为，只是``XDP_ABORTED`` 通过了``trace_xdp_exception`` 跟踪点，这可以用于监"
"控以发现不当行为。"

#: ../../bpf.rst:3748 7168833f24694dafa5eb2ebdff6d14e5
msgid "**Use cases for XDP**"
msgstr "**XDP 用例**"

#: ../../bpf.rst:3750 1c9cb0206dc147389deeab56810911be
msgid ""
"Some of the main use cases for XDP are presented in this subsection. The list is non-exhaustive and given the "
"programmability and efficiency XDP and BPF enables, it can easily be adapted to solve very specific use cases."
msgstr ""
"本小节介绍了 XDP 的一些主要用例。 该列表并非详尽无遗，并且考虑到 XDP 和 BPF 支持的可编程性和效率，它可以很容易地"
"适应解决非常具体的用例。"

#: ../../bpf.rst:3755 9392b9e8e69f4423981b8ee61c59bafe
msgid "**DDoS mitigation, firewalling**"
msgstr "**DDoS 缓解、防火墙**"

#: ../../bpf.rst:3757 d8585e86415b41f78f6a842dc610f766
msgid ""
"One of the basic XDP BPF features is to tell the driver to drop a packet with ``XDP_DROP`` at this early stage "
"which allows for any kind of efficient network policy enforcement with having an extremely low per-packet cost. "
"This is ideal in situations when needing to cope with any sort of DDoS attacks, but also more general allows to "
"implement any sort of firewalling policies with close to no overhead in BPF e.g. in either case as stand alone "
"appliance (e.g. scrubbing 'clean' traffic through ``XDP_TX``) or widely deployed on nodes protecting end hosts "
"themselves (via ``XDP_PASS`` or cpumap ``XDP_REDIRECT`` for good traffic). Offloaded XDP takes this even one "
"step further by moving the already small per-packet cost entirely into the NIC with processing at line-rate."
msgstr ""
"XDP BPF 的一个基本功能是告诉驱动程序在这个早期阶段用``XDP_DROP``丢弃一个数据包，这允许任何类型的高效网络策略执"
"行，并且每个数据包的成本极低。 这在需要应对任何类型的 DDoS 攻击的情况下是理想的，但更一般地允许在 BPF 中实现几乎"
"没有开销的任何类型的防火墙策略，例如在任何一种情况下，作为独立设备（例如通过 XDP_TX 清理“干净”流量）或广泛部署在"
"保护终端主机本身的节点上（通过 ``XDP_PASS`` 或 cpumap ``XDP_REDIRECT`` 以获得好的流量）。 卸载 XDP 通过将已经很小"
"的每个数据包成本完全转移到 NIC 中，并以线速进行处理，从而更进一步。"

#: ../../bpf.rst:3771 ../../bpf.rst:4264 76473a1faea844f9a1a7268ec55962dc 9da58fb6d6234b81845f9deb487ab584
msgid "**Forwarding and load-balancing**"
msgstr "**转发和负载平衡**"

#: ../../bpf.rst:3773 2a6ca45088f94566ab385599b10103fb
msgid ""
"Another major use case of XDP is packet forwarding and load-balancing through either ``XDP_TX`` or "
"``XDP_REDIRECT`` actions. The packet can be arbitrarily mangled by the BPF program running in the XDP layer, "
"even BPF helper functions are available for increasing or decreasing the packet's headroom in order to "
"arbitrarily encapsulate respectively decapsulate the packet before sending it out again. With ``XDP_TX`` "
"hairpinned load-balancers can be implemented that push the packet out of the same networking device it "
"originally arrived on, or with the ``XDP_REDIRECT`` action it can be forwarded to another NIC for transmission. "
"The latter return code can also be used in combination with BPF's cpumap to load-balance packets for passing up "
"the local stack, but on remote, non-XDP processing CPUs."
msgstr ""
"XDP 的另一个主要用例是通过``XDP_TX``或``XDP_REDIRECT``操作进行数据包转发和负载平衡。 数据包可以被运行在 XDP 层的 "
"BPF 程序任意修改，甚至可以使用 BPF 辅助函数来增加或减少数据包的净空，以便在再次发送之前任意封装和解封装数据包。 "
"使用``XDP_TX``可以实现发夹式负载平衡器，将数据包从最初到达的同一网络设备中推出，或者使用``XDP_REDIRECT``操作可以"
"将其转发到另一个网卡进行传输。 后一个返回码也可以与 BPF 的 cpumap 结合使用，在远程、非 XDP 处理 CPU 上对数据包进"
"行负载平衡，以便向上传递本地堆栈。"

#: ../../bpf.rst:3788 9e4c4f7abc36461a8e3122555f32c9d6
msgid "**Pre-stack filtering / processing**"
msgstr "**堆栈前过滤/处理**"

#: ../../bpf.rst:3790 85025a248a3d486a85c94c9166da441c
msgid ""
"Besides policy enforcement, XDP can also be used for hardening the kernel's networking stack with the help of "
"``XDP_DROP`` case, meaning, it can drop irrelevant packets for a local node right at the earliest possible point "
"before the networking stack sees them e.g. given we know that a node only serves TCP traffic, any UDP, SCTP or "
"other L4 traffic can be dropped right away. This has the advantage that packets do not need to traverse various "
"entities like GRO engine, the kernel's flow dissector and others before it can be determined to drop them and "
"thus this allows for reducing the kernel's attack surface. Thanks to XDP's early processing stage, this "
"effectively 'pretends' to the kernel's networking stack that these packets have never been seen by the "
"networking device. Additionally, if a potential bug in the stack's receive path got uncovered and would cause a "
"'ping of death' like scenario, XDP can be utilized to drop such packets right away without having to reboot the "
"kernel or restart any services. Due to the ability to atomically swap such programs to enforce a drop of bad "
"packets, no network traffic is even interrupted on a host."
msgstr ""
"除了策略执行之外，XDP 还可以在 ``XDP_DROP`` 的帮助下用于强化内核的网络堆栈，这意味着它可以在网络堆栈看到它们之前"
"尽早丢弃与本地节点无关的数据包，例如鉴于我们知道一个节点只服务于 TCP 流量，任何 UDP、SCTP 或其他 L4 流量都可以立"
"即丢弃。这样做的好处是数据包在确定丢弃它们之前不需要遍历各种实体，如 GRO 引擎、内核的流解析器和其他实体，因此可以"
"减少内核的攻击面。由于 XDP 的处理阶段发生在收到流量的早期，这有效地向内核的网络堆栈“假装”这些数据包从未被网络设备"
"看到。此外，如果堆栈接收路径中的潜在错误被发现并会导致类似“死亡 ping”的情况，则可以使用 XDP 立即丢弃此类数据包，"
"而无需重新启动内核或重新启动任何服务。由于能够自动交换此类程序以强制丢弃不良数据包，因此主机上的网络流量甚至不会"
"中断。"

#: ../../bpf.rst:3808 8e5d3001ae42402e84eac313c714e7e3
msgid ""
"Another use case for pre-stack processing is that given the kernel has not yet allocated an ``skb`` for the "
"packet, the BPF program is free to modify the packet and, again, have it 'pretend' to the stack that it was "
"received by the networking device this way. This allows for cases such as having custom packet mangling and "
"encapsulation protocols where the packet can be decapsulated prior to entering GRO aggregation in which GRO "
"otherwise would not be able to perform any sort of aggregation due to not being aware of the custom protocol. "
"XDP also allows to push metadata (non-packet data) in front of the packet. This is 'invisible' to the normal "
"kernel stack, can be GRO aggregated (for matching metadata) and later on processed in coordination with a tc "
"ingress BPF program where it has the context of a ``skb`` available for e.g. setting various skb fields."
msgstr ""
"栈前处理的另一个用例是，鉴于内核尚未为数据包分配``skb``，BPF 程序可以自由地修改数据包，并且再次让它“假装”给网络设"
"备以堆栈的方式接收到。 这允许诸如具有自定义数据包修改和封装协议的情况，其中数据包可以在进入 GRO 聚合之前解封装，"
"在这种情况下，由于不知道自定义协议，GRO 将无法执行任何类型的聚合。 XDP 还允许在数据包前面推送元数据（非数据包数"
"据）。 这对普通内核堆栈是“不可见的”，可以进行 GRO 聚合（用于匹配元数据），然后与 tc ingress BPF 程序协调处理，其"
"中它具有可用于例如 ``skb`` 的上下文便于设置各种skb字段。"

#: ../../bpf.rst:3823 ../../bpf.rst:4283 08daa02e17ee4d9c8a5bc62c1f757867 2778fdbc4a8b4874830c3dbee36ac698
msgid "**Flow sampling, monitoring**"
msgstr "**流量采样、监控**"

#: ../../bpf.rst:3825 9aa289959bd54f3386c09d3948e15824
msgid ""
"XDP can also be used for cases such as packet monitoring, sampling or any other network analytics, for example, "
"as part of an intermediate node in the path or on end hosts in combination also with prior mentioned use cases. "
"For complex packet analysis, XDP provides a facility to efficiently push network packets (truncated or with full "
"payload) and custom metadata into a fast lockless per CPU memory mapped ring buffer provided from the Linux perf "
"infrastructure to an user space application. This also allows for cases where only a flow's initial data can be "
"analyzed and once determined as good traffic having the monitoring bypassed. Thanks to the flexibility brought "
"by BPF, this allows for implementing any sort of custom monitoring or sampling."
msgstr ""
"XDP 还可用于数据包监控、采样或任何其他网络分析等情况，例如作为路径中或终端主机上的中间节点的一部分，还可以与前面"
"提到的用例结合使用。 对于复杂的数据包分析，XDP 提供了一种工具，可以有效地将网络数据包（截断或带有完整有效负载）和"
"自定义元数据推送到从 Linux perf 基础架构提供给用户空间应用程序的快速无锁每个 CPU 内存映射的环形缓冲区中。 这也允"
"许只有流的初始数据可以被分析并且一旦确定为良好流量而绕过监控的情况。 由于 BPF 带来的灵活性，这允许实现任何类型的"
"自定义监控或采样。"

#: ../../bpf.rst:3839 84c00277d2f340f8b60fc84649eb7d73
msgid ""
"One example of XDP BPF production usage is Facebook's SHIV and Droplet infrastructure which implement their L4 "
"load-balancing and DDoS countermeasures. Migrating their production infrastructure away from netfilter's IPVS "
"(IP Virtual Server) over to XDP BPF allowed for a 10x speedup compared to their previous IPVS setup. This was "
"first presented at the netdev 2.1 conference:"
msgstr ""
"XDP BPF 生产使用的一个例子是 Facebook 的 SHIV 和 Droplet 基础设施，它们实现了他们的 L4 负载平衡和 DDoS 对策。 将"
"他们的生产基础设施从 netfilter 的 IPVS（IP 虚拟服务器）迁移到 XDP BPF，与之前的 IPVS 设置相比，速度提高了 10 "
"倍。 这是在 netdev 2.1 会议上首次提出的："

#: ../../bpf.rst:3846 7207d7818d0c467ba1811087499e31a6
msgid "Slides: https://netdevconf.info/2.1/slides/apr6/zhou-netdev-xdp-2017.pdf"
msgstr "PPT: https://netdevconf.info/2.1/slides/apr6/zhou-netdev-xdp-2017.pdf"

#: ../../bpf.rst:3847 ee425dadb2734dc5b3fb266825fcb7be
msgid "Video: https://youtu.be/YEU2ClcGqts"
msgstr "视频: https://youtu.be/YEU2ClcGqts"

#: ../../bpf.rst:3849 627cdd601ac64cf7b7ae4f60d94dd9fe
msgid ""
"Another example is the integration of XDP into Cloudflare's DDoS mitigation pipeline, which originally was using "
"cBPF instead of eBPF for attack signature matching through iptables' ``xt_bpf`` module. Due to use of iptables "
"this caused severe performance problems under attack where a user space bypass solution was deemed necessary but "
"came with drawbacks as well such as needing to busy poll the NIC and expensive packet re-injection into the "
"kernel's stack. The migration over to eBPF and XDP combined best of both worlds by having high-performance "
"programmable packet processing directly inside the kernel:"
msgstr ""
"另一个例子是将 XDP 集成到 Cloudflare 的 DDoS 缓解管道中，该管道最初使用 cBPF 而不是 eBPF 通过 iptables 的 xt_bpf "
"模块进行攻击签名匹配。 由于使用 iptables，这在攻击下会导致严重的性能问题，其中用户空间绕过解决方案被认为是必要"
"的，但也带来了一些缺点，例如需要忙于轮询 NIC 以及将昂贵的数据包重新注入内核堆栈。 向 eBPF 和 XDP 的迁移通过直接在"
"内核内部进行高性能可编程数据包处理，结合了两全其美："

#: ../../bpf.rst:3858 db60a8e31bad4faca5125cc4db4bebd7
msgid "Slides: https://netdevconf.info/2.1/slides/apr6/bertin_Netdev-XDP.pdf"
msgstr "PPT: https://netdevconf.info/2.1/slides/apr6/bertin_Netdev-XDP.pdf"

#: ../../bpf.rst:3859 15ca2c239b09469dae2715f38927d4e2
msgid "Video: https://youtu.be/7OuOukmuivg"
msgstr "视频: https://youtu.be/7OuOukmuivg"

#: ../../bpf.rst:3861 43bc15ec1fde4e99909067a8beecbd9c
msgid "**XDP operation modes**"
msgstr "**XDP 操作模式**"

#: ../../bpf.rst:3863 784996bd2b7f4e95b573a53baa9531a5
msgid ""
"XDP has three operation modes where 'native' XDP is the default mode. When talked about XDP this mode is "
"typically implied."
msgstr "XDP 具有三种操作模式，其中“本机”XDP 是默认模式。 当谈到 XDP 时，通常会暗示这种模式。"

#: ../../bpf.rst:3866 0e46985df424474893db75681eff431e
msgid "**Native XDP**"
msgstr "**原生 XDP**"

#: ../../bpf.rst:3868 5ac51c1f0d42438581df17ac4d5e8eca
msgid ""
"This is the default mode where the XDP BPF program is run directly out of the networking driver's early receive "
"path. Most widespread used NICs for 10G and higher support native XDP already."
msgstr ""
"这是 XDP BPF 程序直接在网络驱动程序的早期接收路径之外运行的默认模式。 最广泛使用的 10G 和更高版本的 NIC 已经支持"
"原生 XDP。"

#: ../../bpf.rst:3874 3e4a2fe47c994fe08bbc49a9b9ce6f1c
msgid "**Offloaded XDP**"
msgstr "**Offloaded XDP**"

#: ../../bpf.rst:3876 a058b0f6a943498ca44caf191645e41e
msgid ""
"In the offloaded XDP mode the XDP BPF program is directly offloaded into the NIC instead of being executed on "
"the host CPU. Thus, the already extremely low per-packet cost is pushed off the host CPU entirely and executed "
"on the NIC, providing even higher performance than running in native XDP. This offload is typically implemented "
"by SmartNICs containing multi-threaded, multicore flow processors where a in-kernel JIT compiler translates BPF "
"into native instructions for the latter. Drivers supporting offloaded XDP usually also support native XDP for "
"cases where some BPF helpers may not yet or only be available for the native mode."
msgstr ""
"在这种模式中，XDP BPF 程序直接 offload 到网卡，而不是在主机的 CPU 上执行。 因此，本来就已经很低的 per-packet 开销"
"完全从主机下放到网卡，能够比运行在 native XDP 模式取得更高的性能。这种 offload 通常由智能网卡实现，这些网卡有多线"
"程、多核流处理器，一个位于内核中的 JIT 编译器将 BPF 翻译成网卡的原生指令。支持 offloaded XDP 模式的驱动通常也支"
"持 native XDP 模式，因为 BPF 辅助函数可 能目前还只支持后者。"

#: ../../bpf.rst:3889 0849dd9c91a849f0bc845d44890f00c8
msgid "**Generic XDP**"
msgstr "**通用 XDP**"

#: ../../bpf.rst:3891 aee978fa68fc4904a4db9328dfbd0e22
msgid ""
"For drivers not implementing native or offloaded XDP yet, the kernel provides an option for generic XDP which "
"does not require any driver changes since run at a much later point out of the networking stack. This setting is "
"primarily targeted at developers who want to write and test programs against the kernel's XDP API, and will not "
"operate at the performance rate of the native or offloaded modes. For XDP usage in a production environment "
"either the native or offloaded mode is better suited and the recommended way to run XDP."
msgstr ""
"对于尚未实现本机或卸载 XDP 的驱动程序，内核为通用 XDP 提供了一个选项，该选项不需要任何驱动程序更改，因为在网络堆"
"栈之外运行的时间要晚得多。 此设置主要针对希望针对内核的 XDP API 编写和测试程序的开发人员，并且不会以本机或卸载模"
"式的性能速率运行。 对于生产环境中的 XDP 使用，本机或卸载模式更适合并推荐运行 XDP 的方式。"

#: ../../bpf.rst:3902 ../../bpf.rst:4331 107d3d58b1f743e1a471f917de406c76 7fbe2552137d43789c35ec0a638f7b59
msgid "**Driver support**"
msgstr "**驱动支持**"

#: ../../bpf.rst:3904 2e9673fe646548c1a515bb9a4869ecbc
msgid ""
"Since BPF and XDP is evolving quickly in terms of feature and driver support, the following lists native and "
"offloaded XDP drivers as of kernel 4.17."
msgstr ""
"由于 BPF 和 XDP 的特性和驱动支持还在快速发展和变化，因此这里的列表只统计到了 4.17 内核支持的 native 和 offloaded "
"XDP 驱动。"

#: ../../bpf.rst:3907 d64659cff061445483e4743e53cf0a0d
msgid "**Drivers supporting native XDP**"
msgstr "**支持原生 XDP 的驱动程序**"

#: ../../bpf.rst:3909 c3fc3c9b40c54401ba81842df7e5caef
msgid "**Broadcom**"
msgstr "**Broadcom**"

#: ../../bpf.rst:3911 2797c8fd9f9843239f9db8e4494f600d
msgid "bnxt"
msgstr "bnxt"

#: ../../bpf.rst:3915 de0ad336f793462da1ae8cadcf5ed715
msgid "**Cavium**"
msgstr "**Cavium**"

#: ../../bpf.rst:3917 8f911421c8b9499faf005b2398a3a789
msgid "thunderx"
msgstr "thunderx"

#: ../../bpf.rst:3921 60dc527697f443c0a9390ec335a52582
msgid "**Intel**"
msgstr "**Intel**"

#: ../../bpf.rst:3923 5348925205494487b2f0dedf0637771e
msgid "ixgbe"
msgstr "ixgbe"

#: ../../bpf.rst:3924 ce6fa71fbb0c4f51bbaacc2dc6f46ca6
msgid "ixgbevf"
msgstr "ixgbevf"

#: ../../bpf.rst:3925 a5b87632512a4a7cb84193fd6affc176
msgid "i40e"
msgstr "i40e"

#: ../../bpf.rst:3929 8fba15631ddf492db111a82fb927287b
msgid "**Mellanox**"
msgstr "**Mellanox**"

#: ../../bpf.rst:3931 3130af5f82954fd8a87e0d7d16ad55d8
msgid "mlx4"
msgstr "mlx4"

#: ../../bpf.rst:3932 3fdbd1b102bd4ac78671f955ce99d43f
msgid "mlx5"
msgstr "mlx5"

#: ../../bpf.rst:3936 ../../bpf.rst:3961 ../../bpf.rst:4340 2f9c38bcc96f44a685f4b656afc25009
#: 5a395b2d1cb44f5589e9d3d252c940ba f21e050c74f74fa5874598034b230145
msgid "**Netronome**"
msgstr "**Netronome**"

#: ../../bpf.rst:3938 9ab4c30128a544709737cb5cac538db8
msgid "nfp"
msgstr "nfp"

#: ../../bpf.rst:3942 ../../bpf.rst:4545 acbf92a033834a3782a6a140345fc355 c506c2e1c0984ede8c82821510196e8b
msgid "**Others**"
msgstr "**Others**"

#: ../../bpf.rst:3944 00957bf79fc9413f9b138a8708630747
msgid "tun"
msgstr "tun"

#: ../../bpf.rst:3945 072885c6235b4208b8d852b041160226
msgid "virtio_net"
msgstr "virtio_net"

#: ../../bpf.rst:3949 3a4d2cfffe1a411a803740874447fa92
msgid "**Qlogic**"
msgstr "**Qlogic**"

#: ../../bpf.rst:3951 9e73da1bdfdc46c792c6db1c1311e505
msgid "qede"
msgstr "qede"

#: ../../bpf.rst:3955 d55e9732b4544ef1a55532313463515c
msgid "**Solarflare**"
msgstr "**Solarflare**"

#: ../../bpf.rst:3957 644ce4e1d64642bbbb1cf15ccd0ba41e
msgid "sfc [1]_"
msgstr "**Solarflare**"

#: ../../bpf.rst:3959 2d220c404dd04275abc9fd8710acdb88
msgid "**Drivers supporting offloaded XDP**"
msgstr "**Drivers supporting offloaded XDP**"

#: ../../bpf.rst:3963 ../../bpf.rst:4342 7a455204b48447f9aa3d4fcdd07f7f84 dfc3449361ef4f34b28039a76bd3611a
msgid "nfp [2]_"
msgstr "nfp [2]_"

#: ../../bpf.rst:3965 c343da5e9d40410d844d4022cedb7ebd
msgid ""
"Note that examples for writing and loading XDP programs are included in the toolchain section under the "
"respective tools."
msgstr "请注意，编写和加载 XDP 程序的示例包含在相应工具下的工具链部分中。"

#: ../../bpf.rst:3968 031b3d9f7fed4fdbba2bd4650ca0cbbe
msgid "XDP for sfc available via out of tree driver as of kernel 4.17, but will be upstreamed soon."
msgstr "从内核 4.17 开始，XDP for sfc 可通过树外驱动程序获得，但很快就会被上游化。"

#: ../../bpf.rst:3970 4dab84408ee04a469dce8b3bbcab442e
msgid ""
"Some BPF helper functions such as retrieving the current CPU number will not be available in an offloaded "
"setting."
msgstr "某些 BPF 辅助函数（例如检索当前 CPU 编号）在卸载设置中将不可用。"

#: ../../bpf.rst:3974 88f14696070641c98450fa78e206c1a9
msgid "tc (traffic control)"
msgstr "tc (traffic control)"

#: ../../bpf.rst:3976 09e7f35a66684751b7b54443d006d957
msgid ""
"Aside from other program types such as XDP, BPF can also be used out of the kernel's tc (traffic control) layer "
"in the networking data path. On a high-level there are three major differences when comparing XDP BPF programs "
"to tc BPF ones:"
msgstr ""
"除了 XDP 等其他程序类型之外，BPF 还可以在网络数据路径中的内核的 tc（流量控制）层之外使用。 在将 XDP BPF 程序与 "
"tc BPF 程序进行比较时，在上层存在三个主要区别："

#: ../../bpf.rst:3981 20204173593247a9b532f26ccbd52632
msgid ""
"The BPF input context is a ``sk_buff`` not a ``xdp_buff``. When the kernel's networking stack receives a packet, "
"after the XDP layer, it allocates a buffer and parses the packet to store metadata about the packet. This "
"representation is known as the ``sk_buff``. This structure is then exposed in the BPF input context so that BPF "
"programs from the tc ingress layer can use the metadata that the stack extracts from the packet. This can be "
"useful, but comes with an associated cost of the stack performing this allocation and metadata extraction, and "
"handling the packet until it hits the tc hook. By definition, the ``xdp_buff`` doesn't have access to this "
"metadata because the XDP hook is called before this work is done. This is a significant contributor to the "
"performance difference between the XDP and tc hooks."
msgstr ""
"BPF 输入上下文是 ``sk_buff`` 而不是 ``xdp_buff``。 当内核的网络堆栈接收到一个数据包时，经过 XDP 层，它会分配一个"
"缓冲区并解析数据包以存储有关数据包的元数据。 这种表示被称为``sk_buff``。 这个结构体会暴露给 BPF 输入上下文，以便"
"来自 tc 入口层的 BPF 程序可以使用堆栈从数据包中提取的元数据。 这可能很有用，但随着堆栈执行此分配和元数据提取以及"
"处理数据包直到它到达 tc hook的会不断增加相关成本。 根据定义，``xdp_buff`` 无权访问此元数据，因为在此工作完成之前"
"调用了 XDP 挂钩。 这是 XDP 和 tc hook之间性能差异的重要原因。"

#: ../../bpf.rst:3993 354fb924db8845dbbe2ffce1a98c3855
msgid ""
"Therefore, BPF programs attached to the tc BPF hook can, for instance, read or write the skb's ``mark``, "
"``pkt_type``, ``protocol``, ``priority``, ``queue_mapping``, ``napi_id``, ``cb[]`` array, ``hash``, "
"``tc_classid`` or ``tc_index``, vlan metadata, the XDP transferred custom metadata and various other "
"information. All members of the ``struct __sk_buff`` BPF context used in tc BPF are defined in the ``linux/bpf."
"h`` system header."
msgstr ""
"因此，附加到 tc BPF 钩子的 BPF 程序可以读取或写入 skb 的``mark``、``pkt_type``、``protocol``、``priority``、"
"``queue_mapping``、 ``napi_id``、``cb[]`` 数组、``hash``、``tc_classid`` 或 ``tc_index``、vlan 元数据、XDP 传输的"
"自定义元数据和各种其他信息。 tc BPF 中使用的 ``struct __sk_buff`` BPF 上下文的所有成员都在 ``linux/bpf.h`` 系统头"
"文件中定义。"

#: ../../bpf.rst:4000 0dddeb17d8a646c7971a85f06ca21cad
msgid ""
"Generally, the ``sk_buff`` is of a completely different nature than ``xdp_buff`` where both come with advantages "
"and disadvantages. For example, the ``sk_buff`` case has the advantage that it is rather straight forward to "
"mangle its associated metadata, however, it also contains a lot of protocol specific information (e.g. GSO "
"related state) which makes it difficult to simply switch protocols by solely rewriting the packet data. This is "
"due to the stack processing the packet based on the metadata rather than having the cost of accessing the packet "
"contents each time. Thus, additional conversion is required from BPF helper functions taking care that "
"``sk_buff`` internals are properly converted as well. The ``xdp_buff`` case however does not face such issues "
"since it comes at such an early stage where the kernel has not even allocated an ``sk_buff`` yet, thus packet "
"rewrites of any kind can be realized trivially. However, the ``xdp_buff`` case has the disadvantage that "
"``sk_buff`` metadata is not available for mangling at this stage. The latter is overcome by passing custom "
"metadata from XDP BPF to tc BPF, though. In this way, the limitations of each program type can be overcome by "
"operating complementary programs of both types as the use case requires."
msgstr ""
"通常，``sk_buff`` 与``xdp_buff`` 具有完全不同的性质，两者都有优点和缺点。例如，``sk_buff``方式的优点是可以直接修"
"改其关联的元数据，但是它还包含许多协议特定信息（例如 GSO 相关状态），这使得简单地切换协议变得困难通过仅重写数据包"
"数据。这是由于堆栈基于元数据处理数据包，而不是每次都访问数据包内容的成本。因此需要从 BPF 辅助函数进行额外的转换，"
"同时注意 ``sk_buff`` 内部也正确转换。然而``xdp_buff`` 的情况并没有遇到这样的问题，因为它处于内核甚至还没有分配"
"``sk_buff`` 的早期阶段，因此任何类型的数据包重写都可以轻松实现。但是``xdp_buff`` 情况的缺点是``sk_buff`` 元数据在"
"此阶段不可用于修改。不过后者是通过将自定义元数据从 XDP BPF 传递到 tc BPF 来克服的。这样，根据使 用场景的不同，可"
"以同时利用这两者 BPF 程序，以达到互补的效果。"

#: ../../bpf.rst:4021 8f09559839e7459d91f77f57f3510f55
msgid ""
"Compared to XDP, tc BPF programs can be triggered out of ingress and also egress points in the networking data "
"path as opposed to ingress only in the case of XDP."
msgstr ""
"与 XDP 相比，tc BPF 程序可以从入口触发，也可以在网络数据路径中的出口点触发，而 XDP 的情况是只能在入口处触发。"

#: ../../bpf.rst:4025 860c9a9cc75a4e19aa3bde887dd1f65b
msgid ""
"The two hook points ``sch_handle_ingress()`` and ``sch_handle_egress()`` in the kernel are triggered out of "
"``__netif_receive_skb_core()`` and ``__dev_queue_xmit()``, respectively. The latter two are the main receive and "
"transmit functions in the data path that, setting XDP aside, are triggered for every network packet going in or "
"coming out of the node allowing for full visibility for tc BPF programs at these hook points."
msgstr ""
"内核中的两个挂载点``sch_handle_ingress()``和``sch_handle_egress()``分别由``__netif_receive_skb_core()``和"
"``__dev_queue_xmit()``触发。 后两个是数据路径中的主要接收和传输功能，除了 XDP 之外，每个进出节点的网络数据包都会"
"触发这些功能，从而使 tc BPF 程序在这些挂载点上完全可见。"

#: ../../bpf.rst:4034 5f196cbc78974f7998fd57f1b8a89777
msgid ""
"The tc BPF programs do not require any driver changes since they are run at hook points in generic layers in the "
"networking stack. Therefore, they can be attached to any type of networking device."
msgstr ""
"而 c BPF 程序不需要任何驱动程序更改，因为它们在网络堆栈中通用层的挂载点处运行。 因此它们可以连接到任何类型的网络"
"设备。"

#: ../../bpf.rst:4038 3ab990c591894590aad465fc3ef7546d
msgid ""
"While this provides flexibility, it also trades off performance compared to running at the native XDP layer. "
"However, tc BPF programs still come at the earliest point in the generic kernel's networking data path after GRO "
"has been run but **before** any protocol processing, traditional iptables firewalling such as iptables "
"PREROUTING or nftables ingress hooks or other packet processing takes place. Likewise on egress, tc BPF programs "
"execute at the latest point before handing the packet to the driver itself for transmission, meaning **after** "
"traditional iptables firewalling hooks like iptables POSTROUTING, but still before handing the packet to the "
"kernel's GSO engine."
msgstr ""
"虽然这提供了灵活性，但与在原生 XDP 层运行相比，它也牺牲了性能。 然而tc BPF 程序仍然在 GRO 运行之后通用内核的网络"
"数据路径中的最早时间点，**比**任何协议例如传统 iptables 防火墙（如 iptables PREROUTING 或 nftables 入口挂钩或其他"
"数据包处理）都要早。同样在出口处，tc BPF 程序在将数据包交给驱动程序本身进行传输之前最晚执行，这意味着**在**传统"
"的 iptables 防火墙钩子（如 iptables POSTROUTING）之后，但仍然在将数据包交给内核的 GSO 引擎之前。"

#: ../../bpf.rst:4049 29504e7462694c9faf2bd3ac7f64cf37
msgid ""
"One exception which does require driver changes however are offloaded tc BPF programs, typically provided by "
"SmartNICs in a similar way as offloaded XDP just with differing set of features due to the differences in the "
"BPF input context, helper functions and verdict codes."
msgstr ""
"唯一需要驱动做改动的场景是：将 tc BPF 程序 offload 到网卡。形式通常和 XDP offload 类似，只是特性列表不同，因为二"
"者的 BPF 输入上下文、辅助函数和返回码（ verdict）不同。"

#: ../../bpf.rst:4056 f48a7e9e61e544ef9b924ebe8c2a2bc3
msgid ""
"BPF programs run in the tc layer are run from the ``cls_bpf`` classifier. While the tc terminology describes the "
"BPF attachment point as a \"classifier\", this is a bit misleading since it under-represents what ``cls_bpf`` is "
"capable of. That is to say, a fully programmable packet processor being able not only to read the ``skb`` "
"metadata and packet data, but to also arbitrarily mangle both, and terminate the tc processing with an action "
"verdict. ``cls_bpf`` can thus be regarded as a self-contained entity that manages and executes tc BPF programs."
msgstr ""
"在 tc 层中运行的 BPF 程序是从 ``cls_bpf`` 分类器中运行的。 虽然 tc 术语将 BPF 连接点描述为“分类器”，但这有点误"
"导，因为它低估了 ``cls_bpf`` 的能力。 也就是说一个完全可编程的数据包处理器不仅能够读取“skb”元数据和数据包数据，还"
"可以任意破坏两者，并以对应动作决定是否终止 tc 处理。 因此``cls_bpf`` 可以被视为一个管理和执行 tc BPF 程序的自包含"
"实体。"

#: ../../bpf.rst:4065 5cc6e1a5f14e4a149eb6b14601690b4d
msgid ""
"``cls_bpf`` can hold one or more tc BPF programs. In the case where Cilium deploys ``cls_bpf`` programs, it "
"attaches only a single program for a given hook in ``direct-action`` mode. Typically, in the traditional tc "
"scheme, there is a split between classifier and action modules, where the classifier has one or more actions "
"attached to it that are triggered once the classifier has a match. In the modern world for using tc in the "
"software data path this model does not scale well for complex packet processing. Given tc BPF programs attached "
"to ``cls_bpf`` are fully self-contained, they effectively fuse the parsing and action process together into a "
"single unit. Thanks to ``cls_bpf``'s ``direct-action`` mode, it will just return the tc action verdict and "
"terminate the processing pipeline immediately. This allows for implementing scalable programmable packet "
"processing in the networking data path by avoiding linear iteration of actions. ``cls_bpf`` is the only such "
"\"classifier\" module in the tc layer capable of such a fast-path."
msgstr ""
"``cls_bpf`` 可以保存一个或多个 tc BPF 程序。在 Cilium 部署 ``cls_bpf`` 程序的情况下，它在``direct-action`` 模式下"
"只为给定的钩子附加一个程序。通常，在传统的 tc 方案中，分类器和动作模块之间存在分离，其中分类器具有一个或多个附加"
"到它的动作，一旦分类器匹配，就会触发这些动作。在软件数据路径中使用 tc 的现代世界中，该模型不能很好地扩展复杂的数"
"据包处理。鉴于附加到 cls_bpf 的 tc BPF 程序是完全自包含的，它们有效地将解析和操作过程融合到一个单元中。感谢 "
"``cls_bpf`` 的 ``direct-action`` 模式，它只会返回 tc 动作判断并立即终止处理管道。这允许通过避免动作的线性迭代在网"
"络数据路径中实现可扩展的可编程数据包处理。 ``cls_bpf`` 是 tc 层中唯一能够提供这种快速路径的“分类器”模块。"

#: ../../bpf.rst:4080 befafd63126246699aeb2246708b7545
msgid ""
"Like XDP BPF programs, tc BPF programs can be atomically updated at runtime via ``cls_bpf`` without interrupting "
"any network traffic or having to restart services."
msgstr ""
"与 XDP BPF 程序一样，tc BPF 程序可以在运行时通过``cls_bpf``自动更新，而无需中断任何网络流量或重新启动服务。"

#: ../../bpf.rst:4084 4662156f272e47e0890ac9011973943f
msgid ""
"Both the tc ingress and the egress hook where ``cls_bpf`` itself can be attached to is managed by a pseudo qdisc "
"called ``sch_clsact``. This is a drop-in replacement and proper superset of the ingress qdisc since it is able "
"to manage both, ingress and egress tc hooks. For tc's egress hook in ``__dev_queue_xmit()`` it is important to "
"stress that it is not executed under the kernel's qdisc root lock. Thus, both tc ingress and egress hooks are "
"executed in a lockless manner in the fast-path. In either case, preemption is disabled and execution happens "
"under RCU read side."
msgstr ""
"可以将 ``cls_bpf`` 本身附加到的 tc 入口和出口钩子都由名为 ``sch_clsact`` 的伪 qdisc 管理。 这是入口 qdisc 的直接"
"替代和适当的超集，因为它能够管理入口和出口 tc 挂钩。 对于 ``__dev_queue_xmit()`` 中 tc 的 egress hook，需要强调的"
"是它不是在内核的 qdisc 根锁下执行的。 因此tc ingress 和 egress 钩子都在快速路径中以无锁方式执行。 在任何一种情况"
"下，抢占都被禁用并且执行发生在 RCU 读取端。"

#: ../../bpf.rst:4093 602d1ee5e36247b9afbc37faff6edd57
msgid ""
"Typically on egress there are qdiscs attached to netdevices such as ``sch_mq``, ``sch_fq``, ``sch_fq_codel`` or "
"``sch_htb`` where some of them are classful qdiscs that contain subclasses and thus require a packet "
"classification mechanism to determine a verdict where to demux the packet. This is handled by a call to "
"``tcf_classify()`` which calls into tc classifiers if present. ``cls_bpf`` can also be attached and used in such "
"cases. Such operation usually happens under the qdisc root lock and can be subject to lock contention. The "
"``sch_clsact`` qdisc's egress hook comes at a much earlier point however which does not fall under that and "
"operates completely independent from conventional egress qdiscs. Thus for cases like ``sch_htb`` the "
"``sch_clsact`` qdisc could perform the heavy lifting packet classification through tc BPF outside of the qdisc "
"root lock, setting the ``skb->mark`` or ``skb->priority`` from there such that ``sch_htb`` only requires a flat "
"mapping without expensive packet classification under the root lock thus reducing contention."
msgstr ""
"通常在出口有 qdisc 附加到网络设备，例如 ``sch_mq``、``sch_fq``、``sch_fq_codel`` 或 ``sch_htb`` 其中一些是包含子"
"类的有类 qdisc，因此需要数据包分类机制来确定在哪里解复用数据包。这是通过调用 tcf_classify() 来处理的，如果存在，"
"它会调用 tc 分类器。 ``cls_bpf`` 也可以在这种情况下附加和使用。此类操作通常发生在 qdisc 根锁下，可能会发生锁争"
"用。 ``sch_clsact`` qdisc 的 egress hook 出现的时间要早​​得多，但它不属于此范围，并且完全独立于传统的 egress qdisc "
"运行。因此对于像 ``sch_htb`` 这样的情况，``sch_clsact`` qdisc 可以通过 qdisc 根锁之外的 tc BPF 执行繁重的数据包分"
"类，设置 ``skb->mark`` 或 ``skb->priority `` 从那里开始，``sch_htb`` 只需要一个平面映射，而无需在根锁下进行昂贵的"
"数据包分类，从而减少了竞争。"

#: ../../bpf.rst:4108 23eca7a7df21496e8b6463053bb1aa14
msgid ""
"Offloaded tc BPF programs are supported for the case of ``sch_clsact`` in combination with ``cls_bpf`` where the "
"prior loaded BPF program was JITed from a SmartNIC driver to be run natively on the NIC. Only ``cls_bpf`` "
"programs operating in ``direct-action`` mode are supported to be offloaded. ``cls_bpf`` only supports offloading "
"a single program and cannot offload multiple programs. Furthermore only the ingress hook supports offloading BPF "
"programs."
msgstr ""
"卸载的 tc BPF 程序支持 ``sch_clsact`` 结合 ``cls_bpf`` 的情况，其中先前加载的 BPF 程序是从 SmartNIC 驱动程序 "
"JITed 以在 NIC 上本地运行。 仅支持卸载以 ``direct-action`` 模式运行的``cls_bpf``程序。 ``cls_bpf`` 只支持卸载单个"
"程序，不能卸载多个程序。 此外只有 ingress hook 支持卸载 BPF 程序。"

#: ../../bpf.rst:4116 615f907361584f32955d49cf978371f4
msgid ""
"One ``cls_bpf`` instance is able to hold multiple tc BPF programs internally. If this is the case, then the "
"``TC_ACT_UNSPEC`` program return code will continue execution with the next tc BPF program in that list. "
"However, this has the drawback that several programs would need to parse the packet over and over again "
"resulting in degraded performance."
msgstr ""
"一个``cls_bpf`` 实例能够在内部保存多个 tc BPF 程序。 如果是这种情况，则 ``TC_ACT_UNSPEC`` 程序返回代码将继续执行"
"该列表中的下一个 tc BPF 程序。 但是这样做的缺点是多个程序需要一遍又一遍地解析数据包，从而导致性能下降。"

#: ../../bpf.rst:4124 e854f60c7e334920a0a4329d42062b7a
msgid ""
"Both the tc ingress and egress hook share the same action return verdicts that tc BPF programs can use. They are "
"defined in the ``linux/pkt_cls.h`` system header:"
msgstr ""
"在 tc BPF 程序中可以使用 tc ingress 和 egress 钩子共享相同的动作返回判断。 它们在 ``linux/pkt_cls.h`` 系统头文件"
"中定义："

#: ../../bpf.rst:4136 c4459fb23f114de08b7858feaca53262
msgid ""
"There are a few more action ``TC_ACT_*`` verdicts available in the system header file which are also used in the "
"two hooks. However, they share the same semantics with the ones above. Meaning, from a tc BPF perspective, "
"``TC_ACT_OK`` and ``TC_ACT_RECLASSIFY`` have the same semantics, as well as the three ``TC_ACT_STOLEN``, "
"``TC_ACT_QUEUED`` and ``TC_ACT_TRAP`` opcodes. Therefore, for these cases we only describe ``TC_ACT_OK`` and the "
"``TC_ACT_STOLEN`` opcode for the two groups."
msgstr ""
"系统头文件中还有一些动作 ``TC_ACT_*`` 判断可用，它们也用于两个钩子。 但是它们与上面的语义共享相同的语义。 这意味"
"着从 tc BPF 的角度来看，``TC_ACT_OK``和``TC_ACT_RECLASSIFY``具有相同的语义，以及三个``TC_ACT_STOLEN``、"
"``TC_ACT_QUEUED``和``TC_ACT_TRAP``操作码也是类似情况。 因此对于这些情况，我们只描述``TC_ACT_OK``和"
"``TC_ACT_STOLEN``操作码。"

#: ../../bpf.rst:4144 0c51515a06164c158076ef991b8e9e42
msgid ""
"Starting out with ``TC_ACT_UNSPEC``. It has the meaning of \"unspecified action\" and is used in three cases, i) "
"when an offloaded tc BPF program is attached and the tc ingress hook is run where the ``cls_bpf`` representation "
"for the offloaded program will return ``TC_ACT_UNSPEC``, ii) in order to continue with the next tc BPF program "
"in ``cls_bpf`` for the multi-program case. The latter also works in combination with offloaded tc BPF programs "
"from point i) where the ``TC_ACT_UNSPEC`` from there continues with a next tc BPF program solely running in non-"
"offloaded case. Last but not least, iii) ``TC_ACT_UNSPEC`` is also used for the single program case to simply "
"tell the kernel to continue with the ``skb`` without additional side-effects. ``TC_ACT_UNSPEC`` is very similar "
"to the ``TC_ACT_OK`` action code in the sense that both pass the ``skb`` onwards either to upper layers of the "
"stack on ingress or down to the networking device driver for transmission on egress, respectively. The only "
"difference to ``TC_ACT_OK`` is that ``TC_ACT_OK`` sets ``skb->tc_index`` based on the classid the tc BPF program "
"set. The latter is set out of the tc BPF program itself through ``skb->tc_classid`` from the BPF context."
msgstr ""
"从 ``TC_ACT_UNSPEC`` 开始。它具有“未指定操作”的含义，并在三种情况下使用，i) attach 了一个 offloaded tc BPF 程序，"
"tc ingress hook 正在运行，被 offload 的 程序的 ``cls_bpf`` 表示会返回 TC_ACT_UNSPEC`, ii) 为了在 ``cls_bpf`` 多程"
"序的情况下，继续下一个 tc BPF 程序。这种情况可以和 第一种情况中提到的 offloaded tc BPF 程序一起使用，此时第一种情"
"况返回的 ``TC_ACT_UNSPEC`` 继续执行下一个没有被 offloaded BPF 程序，iii) ``TC_ACT_UNSPEC`` 也用于单个程序案例，以"
"简单地告诉内核继续使用``skb`` 而没有额外的副作用。 ``TC_ACT_UNSPEC`` 与 ``TC_ACT_OK`` 动作代码非常相似，因为两者"
"都将 ``skb`` 向前传递到堆栈的上层或向下传递到网络设备驱动程序以在出口传输， 其与 ``TC_ACT_OK`` 的唯一区别是"
"``TC_ACT_OK`` 根据 tc BPF 程序集的 classid 设置``skb->tc_index``，而后者通过 BPF 上下文中的 ``skb->tc_classid`` "
"设置在 tc BPF 程序本身之外。"

#: ../../bpf.rst:4161 0d7034fab6a4416cb97ff4dc37d74182
msgid ""
"``TC_ACT_SHOT`` instructs the kernel to drop the packet, meaning, upper layers of the networking stack will "
"never see the ``skb`` on ingress and similarly the packet will never be submitted for transmission on egress. "
"``TC_ACT_SHOT`` and ``TC_ACT_STOLEN`` are both similar in nature with few differences: ``TC_ACT_SHOT`` will "
"indicate to the kernel that the ``skb`` was released through ``kfree_skb()`` and return ``NET_XMIT_DROP`` to the "
"callers for immediate feedback, whereas ``TC_ACT_STOLEN`` will release the ``skb`` through ``consume_skb()`` and "
"pretend to upper layers that the transmission was successful through ``NET_XMIT_SUCCESS``. The perf's drop "
"monitor which records traces of ``kfree_skb()`` will therefore also not see any drop indications from "
"``TC_ACT_STOLEN`` since its semantics are such that the ``skb`` has been \"consumed\" or queued but certainly "
"not \"dropped\"."
msgstr ""
"``TC_ACT_SHOT`` 指示内核丢弃数据包，这意味着网络堆栈的上层将永远不会在入口处看到 ``skb``，并且类似地，数据包将永"
"远不会被提交并在出口处传输。 ``TC_ACT_SHOT`` 和 ``TC_ACT_STOLEN`` 本质上是相似的，只有很少的区别："
"``TC_ACT_SHOT`` 将向内核表明``skb`` 是通过``kfree_skb()`` 释放的并返回 ` `NET_XMIT_DROP` 向调用者提供即时反馈，"
"而 ``TC_ACT_STOLEN`` 将通过 ``consume_skb()` `释放 ``skb` `并通过 ``NET_XMIT_SUCCESS`` 向上层假装传输成功。 因"
"此，记录 kfree_skb() 跟踪的 perf 的丢弃监视器也不会看到来自 ``TC_ACT_STOLEN`` 的任何丢弃指示，因为它的语义是这样"
"的，即 skb 已经“消耗”或排队，但肯定没有“被丢弃”。"

#: ../../bpf.rst:4175 abf623a7e35744ed843901c4299de72a
msgid ""
"Last but not least the ``TC_ACT_REDIRECT`` action which is available for tc BPF programs as well. This allows to "
"redirect the ``skb`` to the same or another's device ingress or egress path together with the ``bpf_redirect()`` "
"helper. Being able to inject the packet into another device's ingress or egress direction allows for full "
"flexibility in packet forwarding with BPF. There are no requirements on the target networking device other than "
"being a networking device itself, there is no need to run another instance of ``cls_bpf`` on the target device "
"or other such restrictions."
msgstr ""
"最后一点是 ``TC_ACT_REDIRECT`` 动作也可用于 tc BPF 程序。 这允许将``skb``与``bpf_redirect()``一起重定向到相同或另"
"一个设备的入口或出口路径。 能够将数据包注入另一个设备的入口或出口方向，可以充分灵活地使用 BPF 转发数据包。 除了作"
"为网络设备本身之外，对目标网络设备没有任何要求，不需要在目标设备上运行另一个 ``cls_bpf`` 实例或其他此类限制。"

#: ../../bpf.rst:4184 1bf6b89acdb449b0b817bb1894f404eb
msgid "**tc BPF FAQ**"
msgstr "**tc BPF FAQ**"

#: ../../bpf.rst:4186 1a786ead73da486c86def818e905f423
msgid ""
"This section contains a few miscellaneous question and answer pairs related to tc BPF programs that are asked "
"from time to time."
msgstr "本节包含一些与 tc BPF 程序相关的FAQ，这些问题和答案不时被问到。"

#: ../../bpf.rst:4189 7de2b89949fb46bb825e24568af78998
msgid "**Question:** What about ``act_bpf`` as a tc action module, is it still relevant?"
msgstr "**问题：** ``act_bpf`` 作为一个 tc 模块是否仍然起作用？"

#: ../../bpf.rst:4190 fd1a268bdfde4f77bbb8e2aa6530a53e
msgid ""
"**Answer:** Not really. Although ``cls_bpf`` and ``act_bpf`` share the same functionality for tc BPF programs, "
"``cls_bpf`` is more flexible since it is a proper superset of ``act_bpf``. The way tc works is that tc actions "
"need to be attached to tc classifiers. In order to achieve the same flexibility as ``cls_bpf``, ``act_bpf`` "
"would need to be attached to the ``cls_matchall`` classifier. As the name says, this will match on every packet "
"in order to pass them through for attached tc action processing. For ``act_bpf``, this is will result in less "
"efficient packet processing than using ``cls_bpf`` in ``direct-action`` mode directly. If ``act_bpf`` is used in "
"a setting with other classifiers than ``cls_bpf`` or ``cls_matchall`` then this will perform even worse due to "
"the nature of operation of tc classifiers. Meaning, if classifier A has a mismatch, then the packet is passed to "
"classifier B, reparsing the packet, etc, thus in the typical case there will be linear processing where the "
"packet would need to traverse N classifiers in the worst case to find a match and execute ``act_bpf`` on that. "
"Therefore, ``act_bpf`` has never been largely relevant. Additionally, ``act_bpf`` does not provide a tc "
"offloading interface either compared to ``cls_bpf``."
msgstr ""
"**答案：** 不，尽管 ``cls_bpf`` 和 ``act_bpf`` 共享 tc BPF 程序的相同功能，但``cls_bpf`` 更灵活，因为它是 "
"``act_bpf`` 的适当超集。 tc 的工作方式是 tc 动作需要附加到 tc 分类器。为了获得与 ``cls_bpf`` 相同的灵活性，"
"``act_bpf`` 需要附加到 ``cls_matchall`` 分类器。顾名思义，这将匹配每个数据包，以便将它们传递给附加的 tc 动作处"
"理。对于 ``act_bpf``，这将导致比在``direct-action`` 模式下直接使用``cls_bpf`` 的数据包处理效率低。如果 "
"``act_bpf`` 用于与 ``cls_bpf`` 或 ``cls_matchall`` 以外的其他分类器的设置中，那么由于 tc 分类器的操作性质会导致性"
"能变得得更糟。意思是，如果分类器 A 不匹配，则将数据包传递给分类器 B，重新解析数据包等，因此在典型情况下，这种线性"
"处理的方式会导致数据包在最坏的情况下需要遍历 N 个分类器才能找到匹配并在其上执行“act_bpf”。因此，``act_bpf`` 从来"
"没有在很大程度上相关。此外，与 ``cls_bpf`` 相比，``act_bpf`` 也不提供 tc 卸载接口。"

#: ../../bpf.rst:4209 a9dfabfc826d456cbfc385e01ce95deb
msgid "**Question:** Is it recommended to use ``cls_bpf`` not in ``direct-action`` mode?"
msgstr "**问题：** 是否建议使用 ``cls_bpf`` 而不是 ``direct-action`` 模式？"

#: ../../bpf.rst:4210 a637b49ac22f434e91dc845ef08a4354
msgid ""
"**Answer:** No. The answer is similar to the one above in that this is otherwise unable to scale for more "
"complex processing. tc BPF can already do everything needed by itself in an efficient manner and thus there is "
"no need for anything other than ``direct-action`` mode."
msgstr ""
"**答案：** 否。答案与上述答案类似，否则无法扩展以进行更复杂的处理。 tc BPF 已经能够以一种有效的方式自行完成所有需"
"要的事情，因此除了“direct-action”模式之外不需要任何其他东西。"

#: ../../bpf.rst:4217 b280f66d6da845eab25e0ac76bb7bc7a
msgid "**Question:** Is there any performance difference in offloaded ``cls_bpf`` and offloaded XDP?"
msgstr "**问题：** offloaded ``cls_bpf`` 和offloaded XDP 有性能差异吗？"

#: ../../bpf.rst:4219 09ef6498c6124fa4b9951958cfceac24
msgid ""
"**Answer:** No. Both are JITed through the same compiler in the kernel which handles the offloading to the "
"SmartNIC and the loading mechanism for both is very similar as well. Thus, the BPF program gets translated into "
"the same target instruction set in order to be able to run on the NIC natively. The two tc BPF and XDP BPF "
"program types have a differing set of features, so depending on the use case one might be picked over the other "
"due to availability of certain helper functions in the offload case, for example."
msgstr ""
"没有。二者都是由内核内的同一个编译器 JIT 的，这个编译器负责 offload 到智能网 卡以及，并且对二者的加载机制是非常相"
"似的。因此，要在 NIC 上原生执行，BPF 程 序会被翻译成相同的目标指令。tc BPF 和 XDP BPF 这两种程序类型有不同的特性"
"集合，因此根据使用场景的不同，你 可以选择 tc BPF 或者是 XDP BPF，例如，二者的在 offload 场景下的辅助函数可能 会有"
"差异。"

#: ../../bpf.rst:4227 c1fc260855f6474a9014ac752df69a20
msgid "**Use cases for tc BPF**"
msgstr "** tc BPF 的用例**"

#: ../../bpf.rst:4229 920b38646f0f4836ba3ccab522f7f942
msgid ""
"Some of the main use cases for tc BPF programs are presented in this subsection. Also here, the list is non-"
"exhaustive and given the programmability and efficiency of tc BPF, it can easily be tailored and integrated into "
"orchestration systems in order to solve very specific use cases. While some use cases with XDP may overlap, tc "
"BPF and XDP BPF are mostly complementary to each other and both can also be used at the same time or one over "
"the other depending which is most suitable for a given problem to solve."
msgstr ""
"本小节介绍了 tc BPF 程序的一些主要用例。 同样在这里，该列表并非详尽无遗，并且鉴于 tc BPF 的可编程性和效率，它可以"
"轻松定制并集成到编排系统中，以解决非常具体的用例。 虽然 XDP 的一些用例可能会重叠，但 tc BPF 和 XDP BPF 大多是相互"
"补充的，两者也可以同时使用，也可以根据最适合解决给定问题的情况来使用。"

#: ../../bpf.rst:4237 80436b3a4afe48d49ed368f5ba43f806
msgid "**Policy enforcement for containers**"
msgstr "**容器的策略执行**"

#: ../../bpf.rst:4239 2d43873fcfcf498186bd4814787509ed
msgid ""
"One application which tc BPF programs are suitable for is to implement policy enforcement, custom firewalling or "
"similar security measures for containers or pods, respectively. In the conventional case, container isolation is "
"implemented through network namespaces with veth networking devices connecting the host's initial namespace with "
"the dedicated container's namespace. Since one end of the veth pair has been moved into the container's "
"namespace whereas the other end remains in the initial namespace of the host, all network traffic from the "
"container has to pass through the host-facing veth device allowing for attaching tc BPF programs on the tc "
"ingress and egress hook of the veth. Network traffic going into the container will pass through the host-facing "
"veth's tc egress hook whereas network traffic coming from the container will pass through the host-facing veth's "
"tc ingress hook."
msgstr ""
"一般 tc BPF 程序适用于分别为容器或 Pod 实现执行策略、自定义防火墙或类似的安全措施。 在传统情况下，容器隔离是通过"
"网络命名空间实现的，veth 网络设备将主机的初始命名空间与专用容器的命名空间连接起来。 由于 veth 对的一端已移至容器"
"的命名空间，而另一端仍保留在主机的初始命名空间中，因此来自容器的所有网络流量都必须通过面向主机的 veth 设备，从而"
"允许在其上附加 tc BPF 程序 veth 的 tc 入口和出口hook。 进入容器的网络流量将通过面向主机的 veth 的 tc 出口关联，而"
"来自容器的网络流量将通过面向主机的 veth 的 tc 入口关联。"

#: ../../bpf.rst:4252 14b8f09507bc46648c6a7005944c6a63
msgid ""
"For virtual devices like veth devices XDP is unsuitable in this case since the kernel operates solely on a "
"``skb`` here and generic XDP has a few limitations where it does not operate with cloned ``skb``'s. The latter "
"is heavily used from the TCP/IP stack in order to hold data segments for retransmission where the generic XDP "
"hook would simply get bypassed instead. Moreover, generic XDP needs to linearize the entire ``skb`` resulting in "
"heavily degraded performance. tc BPF on the other hand is more flexible as it specializes on the ``skb`` input "
"context case and thus does not need to cope with the limitations from generic XDP."
msgstr ""
"对于像 veth 设备这样的虚拟设备，XDP 在这种情况下是不合适的，因为内核在这里只在 ``skb`` 上运行，而通用 XDP 有一些"
"限制，它不能在克隆的 ``skb`` 上运行。 后者在 TCP/IP 堆栈中大量使用，以保存数据段以进行重传，而通用 XDP 的hook将被"
"绕过。 此外，通用 XDP 需要对整个“skb”进行线性化，从而导致性能严重下降。 另一方面，tc BPF 更加灵活，因为它专门处"
"理“skb”输入上下文情况，因此不需要处理通用 XDP 的限制。"

#: ../../bpf.rst:4266 0ce2e82ae01243cba536d1d3a5da80a0
msgid ""
"The forwarding and load-balancing use case is quite similar to XDP, although slightly more targeted towards east-"
"west container workloads rather than north-south traffic (though both technologies can be used in either case). "
"Since XDP is only available on ingress side, tc BPF programs allow for further use cases that apply in "
"particular on egress, for example, container based traffic can already be NATed and load-balanced on the egress "
"side through BPF out of the initial namespace such that this is done transparent to the container itself. Egress "
"traffic is already based on the ``sk_buff`` structure due to the nature of the kernel's networking stack, so "
"packet rewrites and redirects are suitable out of tc BPF. By utilizing the ``bpf_redirect()`` helper function, "
"BPF can take over the forwarding logic to push the packet either into the ingress or egress path of another "
"networking device. Thus, any bridge-like devices become unnecessary to use as well by utilizing tc BPF as "
"forwarding fabric."
msgstr ""
"转发和负载平衡用例与 XDP 非常相似，尽管更针对东西向容器工作负载而不是南北向流量（尽管这两种技术都可以在任何一种情"
"况下使用）。由于 XDP 仅在入口端可用，tc BPF 程序允许进一步的用例特别适用于出口，例如，基于容器的流量已经可以通过"
"初始命名空间之外的 BPF 在出口端进行 NAT 和负载平衡，例如这是对容器本身透明的。由于内核网络堆栈的性质，出口流量已"
"经基于“sk_buff”结构，因此数据包重写和重定向适用于 tc BPF。通过使用 bpf_redirect() 辅助函数，BPF 可以接管转发逻"
"辑，将数据包推送到另一个网络设备的入口或出口路径。因此，通过使用 tc BPF 作为转发结构，任何类似桥接的设备也变得不"
"再需要使用。"

#: ../../bpf.rst:4285 2549fd101d704011bea556bdaffc1739
msgid ""
"Like in XDP case, flow sampling and monitoring can be realized through a high-performance lockless per-CPU "
"memory mapped perf ring buffer where the BPF program is able to push custom data, the full or truncated packet "
"contents, or both up to a user space application. From the tc BPF program this is realized through the "
"``bpf_skb_event_output()`` BPF helper function which has the same function signature and semantics as "
"``bpf_xdp_event_output()``. Given tc BPF programs can be attached to ingress and egress as opposed to only "
"ingress in XDP BPF case plus the two tc hooks are at the lowest layer in the (generic) networking stack, this "
"allows for bidirectional monitoring of all network traffic from a particular node. This might be somewhat "
"related to the cBPF case which tcpdump and Wireshark makes use of, though, without having to clone the ``skb`` "
"and with being a lot more flexible in terms of programmability where, for example, BPF can already perform in-"
"kernel aggregation rather than pushing everything up to user space as well as custom annotations for packets "
"pushed into the ring buffer. The latter is also heavily used in Cilium where packet drops can be further "
"annotated to correlate container labels and reasons for why a given packet had to be dropped (such as due to "
"policy violation) in order to provide a richer context."
msgstr ""
"就像在 XDP 案例中一样，流采样和监控可以通过高性能无锁 per-CPU 内存映射 perf 环形缓冲区来实现，其中 BPF 程序能够将"
"自定义数据、完整或截断的数据包内容或两者都推送给用户空间应用。在 tc BPF 程序中，这是通过 "
"``bpf_skb_event_output()`` BPF 辅助函数实现的，它具有与 ``bpf_xdp_event_output()`` 相同的函数签名和语义。鉴于 tc "
"BPF 程序可以附加到入口和出口，而不是仅在 XDP BPF 案例中的入口加上两个 tc hook位于（通用）网络堆栈的最低层，这允许"
"双向监控来自特定网络的所有网络流量节点。这可能与 tcpdump 和 Wireshark 使用的 cBPF 案例有关，但不必克隆``skb``，并"
"且在可编程性方面更加灵活，例如，BPF 已经可以在-内核聚合而不是将所有内容推送到用户空间以及推送到环形缓冲区的数据包"
"的自定义注释。后者在 Cilium 中也大量使用，其中可以进一步注释数据包丢弃以关联容器标签和必须丢弃给定数据包的原因"
"（例如由于违反策略），以提供更丰富的上下文。"

#: ../../bpf.rst:4307 f5f8e30286dd43c6979fc14b185d4a41
msgid "**Packet scheduler pre-processing**"
msgstr "**数据包调度程序预处理**"

#: ../../bpf.rst:4309 48c0007551cd45cdbde90d93b1280a0c
msgid ""
"The ``sch_clsact``'s egress hook which is called ``sch_handle_egress()`` runs right before taking the kernel's "
"qdisc root lock, thus tc BPF programs can be utilized to perform all the heavy lifting packet classification and "
"mangling before the packet is transmitted into a real full blown qdisc such as ``sch_htb``. This type of "
"interaction of ``sch_clsact`` with a real qdisc like ``sch_htb`` coming later in the transmission phase allows "
"to reduce the lock contention on transmission since ``sch_clsact``'s egress hook is executed without taking "
"locks."
msgstr ""
"名为 ``sch_handle_egress()`` 的 ``sch_clsact`` 出口hook在获取内核的 qdisc 根锁之前运行，因此 tc BPF 程序可用于在"
"数据包之前执行所有繁重的数据包分类和处理并被传输到一个真正完整的 qdisc 中，例如 ``sch_htb``。 这种 sch_clsact 与"
"真正的 qdisc（如 sch_htb ）在传输阶段后期的交互允许减少传输时的锁争用，因为 sch_clsact 的出口挂钩是在不获取锁的情"
"况下执行的。"

#: ../../bpf.rst:4320 39f87d88a18b470faf8944064bcf320a
msgid ""
"One concrete example user of tc BPF but also XDP BPF programs is Cilium. Cilium is open source software for "
"transparently securing the network connectivity between application services deployed using Linux container "
"management platforms like Docker and Kubernetes and operates at Layer 3/4 as well as Layer 7. At the heart of "
"Cilium operates BPF in order to implement the policy enforcement as well as load balancing and monitoring."
msgstr ""
"Cilium 是 tc BPF 和 XDP BPF 程序的一个具体示例用户。 Cilium 是开源软件，用于透明地保护使用 Docker 和 Kubernetes "
"等 Linux 容器管理平台部署的应用程序服务之间的网络连接，并在第 3/4 层和第 7 层运行。Cilium 的核心运行 BPF 以实施该"
"策略 执行以及负载平衡和监控。"

#: ../../bpf.rst:4327 074290117de44e778e0dec9f30a1fe1f
msgid ""
"Slides: https://www.slideshare.net/ThomasGraf5/dockercon-2017-cilium-network-and-application-security-with-bpf-"
"and-xdp"
msgstr ""
"PPT: https://www.slideshare.net/ThomasGraf5/dockercon-2017-cilium-network-and-application-security-with-bpf-and-"
"xdp"

#: ../../bpf.rst:4328 413341ffaa764126a698d16b08840d1c
msgid "Video: https://youtu.be/ilKlmTDdFgk"
msgstr "视频: https://youtu.be/ilKlmTDdFgk"

#: ../../bpf.rst:4329 df29a7b5ed16409c8be2befe0ea616f4
msgid "Github: https://github.com/cilium/cilium"
msgstr "Github: https://github.com/cilium/cilium"

#: ../../bpf.rst:4333 a5dcf21122714831bc6e71f4675d5799
msgid ""
"Since tc BPF programs are triggered from the kernel's networking stack and not directly out of the driver, they "
"do not require any extra driver modification and therefore can run on any networking device. The only exception "
"listed below is for offloading tc BPF programs to the NIC."
msgstr ""
"由于 tc BPF 程序是从内核的网络堆栈触发的，而不是直接从驱动程序中触发的，因此它们不需要任何额外的驱动程序修改，因"
"此可以在任何网络设备上运行。 下面列出的唯一例外是将 tc BPF 程序从NIC中卸载。"

#: ../../bpf.rst:4338 30fd6199d9684dcbaf58fd6a8f76dca7
msgid "**Drivers supporting offloaded tc BPF**"
msgstr "**支持offload tc BPF 的驱动程序**"

#: ../../bpf.rst:4344 366673cbb9324ea292ca13db87181904
msgid ""
"Note that also here examples for writing and loading tc BPF programs are included in the toolchain section under "
"the respective tools."
msgstr "请注意，此处编写和加载 tc BPF 程序的示例也包含在相应工具下的工具链部分中。"

#: ../../bpf.rst:4350 2ea023e3b660421b8b1983c51872dc0e
msgid "Further Reading"
msgstr "进一步阅读"

#: ../../bpf.rst:4352 138aa6b3db69465096b9901028061aaf
msgid ""
"Mentioned lists of docs, projects, talks, papers, and further reading material are likely not complete. Thus, "
"feel free to open pull requests to complete the list."
msgstr "提到的文档、项目、演讲、论文和进一步阅读材料的列表可能不完整。 因此，请随时打开pull request。"

#: ../../bpf.rst:4357 e356c2d78afb40bfb82116700b6c0411
msgid "Kernel Developer FAQ"
msgstr "内核开发人员常见问题解答"

#: ../../bpf.rst:4359 63cfbd5f04bd4bc183fd4ae674932b72
msgid ""
"Under ``Documentation/bpf/``, the Linux kernel provides two FAQ files that are mainly targeted for kernel "
"developers involved in the BPF subsystem."
msgstr ""
"在 ``Documentation/bpf/`` 下，Linux 内核提供了两个常见问题解答文件，主要针对涉及 BPF 子系统的内核开发人员。"

#: ../../bpf.rst:4362 babd4250a795471786a5edea8187cd51
msgid ""
"**BPF Devel FAQ:** this document provides mostly information around patch submission process as well as BPF "
"kernel tree, stable tree and bug reporting workflows, questions around BPF's extensibility and interaction with "
"LLVM and more."
msgstr ""
"**BPF 开发常见问题解答：** 本文档主要提供有关补丁提交过程以及 BPF 内核树、稳定树和错误报告工作流程、有关 BPF 的可"
"扩展性和与 LLVM 的交互等问题的信息。"

#: ../../bpf.rst:4367 ab49285dd5b349d0a4ce0b9baeb6aee8
msgid "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/bpf/bpf_devel_QA.rst"
msgstr "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/bpf/bpf_devel_QA.rst"

#: ../../bpf.rst:4371 130c77000575407b85e0a1e275c952a2
msgid ""
"**BPF Design FAQ:** this document tries to answer frequently asked questions around BPF design decisions related "
"to the instruction set, verifier, calling convention, JITs, etc."
msgstr "**BPF 设计常见问题解答：** 本文档试图回答与指令集、验证器、调用约定、JIT 等相关的 BPF 设计决策的常见问题。"

#: ../../bpf.rst:4375 df7c4fd5259c4503a662fb2bd465f062
msgid "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/bpf/bpf_design_QA.rst"
msgstr ""
"https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/bpf/bpf_design_QA.rst"

#: ../../bpf.rst:4378 6e4bd3b852614728b67febbf211621f9
msgid "Projects using BPF"
msgstr "使用 BPF 的项目"

#: ../../bpf.rst:4380 1d336296686f41d69fb72d5dda30dd4d
msgid ""
"The following list includes a selection of open source projects making use of BPF respectively provide tooling "
"for BPF. In this context the eBPF instruction set is specifically meant instead of projects utilizing the legacy "
"cBPF:"
msgstr ""
"下面的列表包括一些使用 BPF 的开源项目，它们分别为 BPF 提供工具。 在这种情况下，eBPF 指令集是专门用来代替使用传统 "
"cBPF 的项目的："

#: ../../bpf.rst:4385 a3263889491a43308e6f39af1afbb468
msgid "**Tracing**"
msgstr "**Tracing**"

#: ../../bpf.rst:4387 c1b824774bfa462b8623b53022177ffe
msgid "**BCC**"
msgstr "**BCC**"

#: ../../bpf.rst:4389 19ab085b14434122975e970f3de0b188
msgid ""
"BCC stands for BPF Compiler Collection and its key feature is to provide a set of easy to use and efficient "
"kernel tracing utilities all based upon BPF programs hooking into kernel infrastructure based upon kprobes, "
"kretprobes, tracepoints, uprobes, uretprobes as well as USDT probes. The collection provides close to hundred "
"tools targeting different layers across the stack from applications, system libraries, to the various different "
"kernel subsystems in order to analyze a system's performance characteristics or problems. Additionally, BCC "
"provides an API in order to be used as a library for other projects."
msgstr ""
"BCC 代表 BPF Compiler Collection，它的关键特性是提供一组易于使用且高效的内核跟踪实用程序，所有这些都基于 BPF 程序"
"挂钩到基于 kprobes、kretprobes、tracepoints、uprobes、uretprobes 以及 USDT 探针的内核基础设施。 该集合提供了近百"
"种工具，针对堆栈中的不同层，从应用程序、系统库到各种不同的内核子系统，以分析系统的性能特征或问题。 此外，BCC 提供"
"了一个 API，以便用作其他项目的库。"

#: ../../bpf.rst:4399 d6b82a65c4c0408aa96fa98634a11009
msgid "https://github.com/iovisor/bcc"
msgstr "https://github.com/iovisor/bcc"

#: ../../bpf.rst:4403 06881478091a42aab40e745b0fd0b8a4
msgid "**bpftrace**"
msgstr "**bpftrace**"

#: ../../bpf.rst:4405 3a121292fbee4e7e84a0904962883e67
msgid ""
"bpftrace is a DTrace-style dynamic tracing tool for Linux and uses LLVM as a back end to compile scripts to BPF-"
"bytecode and makes use of BCC for interacting with the kernel's BPF tracing infrastructure. It provides a higher-"
"level language for implementing tracing scripts compared to native BCC."
msgstr ""
"bpftrace 是一个 DTrace 风格的 Linux 动态跟踪工具，它使用 LLVM 作为后端将脚本编译为 BPF 字节码，并利用 BCC 与内核"
"的 BPF 跟踪基础设施进行交互。 与原生 BCC 相比，它提供了一种用于实现跟踪脚本的高级语言。"

#: ../../bpf.rst:4411 9e1f90ebafb4481cb1300bf0ae6a6227
msgid "https://github.com/ajor/bpftrace"
msgstr "https://github.com/ajor/bpftrace"

#: ../../bpf.rst:4415 2f06f2ed75ce4fc0891a4f5b20633342
msgid "**perf**"
msgstr "**perf**"

#: ../../bpf.rst:4417 642d0e20514746f5a53a9f3202c1ba4f
msgid ""
"The perf tool which is developed by the Linux kernel community as part of the kernel source tree provides a way "
"to load tracing BPF programs through the conventional perf record subcommand where the aggregated data from BPF "
"can be retrieved and post processed in perf.data for example through perf script and other means."
msgstr ""
"作为内核源代码树的一部分，由 Linux 内核社区开发的 perf 工具提供了一种通过常规 perf record 子命令加载跟踪 BPF 程序"
"的方法，其中可以检索来自 BPF 的聚合数据并在 perf.data 中进行后处理 通过 perf 脚本等方式。"

#: ../../bpf.rst:4423 41a0947d23a34c7da65224f1d1db02a3
msgid "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/perf"
msgstr "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/perf"

#: ../../bpf.rst:4427 ae27578344e94d98abf6b8f69804f2d3
msgid "**ply**"
msgstr "**ply**"

#: ../../bpf.rst:4429 9a29b8d80d8e42f6850fef224b31af87
msgid ""
"ply is a tracing tool that follows the 'Little Language' approach of yore, and compiles ply scripts into Linux "
"BPF programs that are attached to kprobes and tracepoints in the kernel. The scripts have a C-like syntax, "
"heavily inspired by DTrace and by extension awk. ply keeps dependencies to very minimum and only requires flex "
"and bison at build time, only libc at runtime."
msgstr ""
"ply 是一个跟踪工具，它遵循过去的“小语言”方法，并将 ply 脚本编译成 Linux BPF 程序，这些程序附加到内核中的 kprobes "
"和跟踪点。 这些脚本具有类似 C 的语法，深受 DTrace 和扩展 awk 的启发。 ply 将依赖关系保持在最低限度，并且只在构建"
"时需要 flex 和 bison，在运行时只需要 libc。"

#: ../../bpf.rst:4436 e146bea064fc4c47b95a4f70506a0e9c
msgid "https://github.com/wkz/ply"
msgstr "https://github.com/wkz/ply"

#: ../../bpf.rst:4440 f9b08781cc084290850797a2816171ff
msgid "**systemtap**"
msgstr "**systemtap**"

#: ../../bpf.rst:4442 2dc0f46cada14cddafe74a9b743c19ef
msgid ""
"systemtap is a scripting language and tool for extracting, filtering and summarizing data in order to diagnose "
"and analyze performance or functional problems. It comes with a BPF back end called stapbpf which translates the "
"script directly into BPF without the need of an additional compiler and injects the probe into the kernel. Thus, "
"unlike stap's kernel modules this does neither have external dependencies nor requires to load kernel modules."
msgstr ""
"ystemtap 是一种脚本语言和工具，用于提取、过滤和汇总数据，以诊断和分析性能或功能问题。 它带有一个名为 stapbpf 的 "
"BPF 后端，无需额外的编译器即可将脚本直接转换为 BPF，并将探针注入内核。 因此与 stap 的内核模块不同，它既没有外部依"
"赖，也不需要加载内核模块。"

#: ../../bpf.rst:4450 c70b7ac22e104c888153f58565ce8872
msgid "https://sourceware.org/git/gitweb.cgi?p=systemtap.git;a=summary"
msgstr "https://sourceware.org/git/gitweb.cgi?p=systemtap.git;a=summary"

#: ../../bpf.rst:4454 3ee5878f2a094a6eb03d5c2477289199
msgid "**PCP**"
msgstr "**PCP**"

#: ../../bpf.rst:4456 e976f56704824aa291d1f2937d829f3a
msgid ""
"Performance Co-Pilot (PCP) is a system performance and analysis framework which is able to collect metrics "
"through a variety of agents as well as analyze collected systems' performance metrics in real-time or by using "
"historical data. With pmdabcc, PCP has a BCC based performance metrics domain agent which extracts data from the "
"kernel via BPF and BCC."
msgstr ""
"Performance Co-Pilot (PCP) 是一个系统性能和分析框架，能够通过各种代理收集指标，并实时或使用历史数据分析收集的系统"
"性能指标。 使用 pmdabcc，PCP 有一个基于 BCC 的性能指标域代理，它通过 BPF 和 BCC 从内核中提取数据。"

#: ../../bpf.rst:4462 844105abde574319b2fe0ca281c181b5
msgid "https://github.com/performancecopilot/pcp"
msgstr "https://github.com/performancecopilot/pcp"

#: ../../bpf.rst:4466 be1692e426f34b1a8ca1b46286007b67
msgid "**Weave Scope**"
msgstr "**Weave Scope**"

#: ../../bpf.rst:4468 195c856ba8ad45b4a56a489be2a2fedf
msgid ""
"Weave Scope is a cloud monitoring tool collecting data about processes, networking connections or other system "
"data by making use of BPF in combination with kprobes. Weave Scope works on top of the gobpf library in order to "
"load BPF ELF files into the kernel, and comes with a tcptracer-bpf tool which monitors connect, accept and close "
"calls in order to trace TCP events."
msgstr ""
"Weave Scope 是一个云监控工具，通过结合使用 BPF 和 kprobes 来收集有关进程、网络连接或其他系统数据的数据。 Weave "
"Scope 在 gobpf 库之上工作，以便将 BPF ELF 文件加载到内核中，并附带一个 tcptracer-bpf 工具，该工具监视连接、接受和"
"关闭调用以跟踪 TCP 事件。"

#: ../../bpf.rst:4474 933dae24ae00413c8c9aac10f0e40e9f
msgid "https://github.com/weaveworks/scope"
msgstr "https://github.com/weaveworks/scope"

#: ../../bpf.rst:4478 c827737164b340a3be9e919922981082
msgid "**Networking**"
msgstr "**Networking**"

#: ../../bpf.rst:4480 6665ef46a3504f3e9fc8a2d72d864759
msgid "**Cilium**"
msgstr "**Cilium**"

#: ../../bpf.rst:4482 3848770e513c488fb4d8fe676427dc8f
msgid ""
"Cilium provides and transparently secures network connectivity and load-balancing between application workloads "
"such as application containers or processes. Cilium operates at Layer 3/4 to provide traditional networking and "
"security services as well as Layer 7 to protect and secure use of modern application protocols such as HTTP, "
"gRPC and Kafka. It is integrated into orchestration frameworks such as Kubernetes. BPF is the foundational part "
"of Cilium that operates in the kernel's networking data path."
msgstr ""
"Cilium 提供并透明地保护应用程序工作负载（如应用程序容器或进程）之间的网络连接和负载平衡。 Cilium 在第 3/4 层运行"
"以提供传统的网络和安全服务，并在第 7 层运行以保护和保护现代应用程序协议（如 HTTP、gRPC 和 Kafka）的使用。 它被集"
"成到 Kubernetes 等编排框架中。 BPF 是 Cilium 的基础部分，在内核的网络数据路径中运行。"

#: ../../bpf.rst:4490 2ed8ffd6e522439997bab8333287a8cc
msgid "https://github.com/cilium/cilium"
msgstr "https://github.com/cilium/cilium"

#: ../../bpf.rst:4494 f94fd3f13e6d46ec8fd22e42938be115
msgid "**Suricata**"
msgstr "**Suricata**"

#: ../../bpf.rst:4496 2460f0d243054f0191c97dfca851f246
msgid ""
"Suricata is a network IDS, IPS and NSM engine, and utilizes BPF as well as XDP in three different areas, that "
"is, as BPF filter in order to process or bypass certain packets, as a BPF based load balancer in order to allow "
"for programmable load balancing and for XDP to implement a bypass or dropping mechanism at high packet rates."
msgstr ""
"Suricata 是一个网络 IDS、IPS 和 NSM 引擎，并在三个不同的领域利用 BPF 和 XDP，即作为 BPF 过滤器以处理或绕过某些数"
"据包，作为基于 BPF 的负载平衡器以允许可编程，进行负载平衡和 XDP 在高数据包速率下实现绕过或丢弃机制。"

#: ../../bpf.rst:4502 7889d62960b349c8adc7c9444b39bcb5
msgid "https://suricata.readthedocs.io/en/suricata-5.0.2/capture-hardware/ebpf-xdp.html"
msgstr "https://suricata.readthedocs.io/en/suricata-5.0.2/capture-hardware/ebpf-xdp.html"

#: ../../bpf.rst:4504 2e041b152c03401daaed6efbfa66ab20
msgid "https://github.com/OISF/suricata"
msgstr "https://github.com/OISF/suricata"

#: ../../bpf.rst:4508 a567db19e0604090b68c1b83499dc751
msgid "**systemd**"
msgstr "**systemd**"

#: ../../bpf.rst:4510 d2370030c1434f6b985be9f35bc3748a
msgid ""
"systemd allows for IPv4/v6 accounting as well as implementing network access control for its systemd units based "
"on BPF's cgroup ingress and egress hooks. Accounting is based on packets / bytes, and ACLs can be specified as "
"address prefixes for allow / deny rules. More information can be found at:"
msgstr ""
"systemd 允许 IPv4/v6 计费以及基于 BPF 的 cgroup 入口和出口hook为其 systemd 单元实现网络访问控制。 计费基于数据包/"
"字节，ACL 可以指定为允许/拒绝规则的地址前缀。 更多信息可以在以下位置找到："

#: ../../bpf.rst:4515 a1ad205f944d4c38a74d6cda4fe1943a
msgid "http://0pointer.net/blog/ip-accounting-and-access-lists-with-systemd.html"
msgstr "http://0pointer.net/blog/ip-accounting-and-access-lists-with-systemd.html"

#: ../../bpf.rst:4517 6445efbb10c64d36b6f4aaa388ed03f1
msgid "https://github.com/systemd/systemd"
msgstr "https://github.com/systemd/systemd"

#: ../../bpf.rst:4521 70c4d1bf0b2e42509421900a0e8eb0df
msgid "**iproute2**"
msgstr "**iproute2**"

#: ../../bpf.rst:4523 6354d660b1fd41079113f1851023d4f2
msgid ""
"iproute2 offers the ability to load BPF programs as LLVM generated ELF files into the kernel. iproute2 supports "
"both, XDP BPF programs as well as tc BPF programs through a common BPF loader backend. The tc and ip command "
"line utilities enable loader and introspection functionality for the user."
msgstr ""
"iproute2 提供了将 BPF 程序作为 LLVM 生成的 ELF 文件加载到内核中的能力。 iproute2 通过一个通用的 BPF 加载器后端同"
"时支持 XDP BPF 程序和 tc BPF 程序。 tc 和 ip 命令行实用程序为用户启用加载程序和自省功能。"

#: ../../bpf.rst:4528 ebf2be6f048c4f0aaa3ebee5cd40e8e2
msgid "https://git.kernel.org/pub/scm/network/iproute2/iproute2.git/"
msgstr "https://git.kernel.org/pub/scm/network/iproute2/iproute2.git/"

#: ../../bpf.rst:4532 3804dea081d8411ca18046103960a639
msgid "**p4c-xdp**"
msgstr "**p4c-xdp**"

#: ../../bpf.rst:4534 64bf511838c248c3b2d72d1dc0d3f8e3
msgid ""
"p4c-xdp presents a P4 compiler backend targeting BPF and XDP. P4 is a domain specific language describing how "
"packets are processed by the data plane of a programmable network element such as NICs, appliances or switches, "
"and with the help of p4c-xdp P4 programs can be translated into BPF C programs which can be compiled by clang / "
"LLVM and loaded as BPF programs into the kernel at XDP layer for high performance packet processing."
msgstr ""
"p4c-xdp 提供了一个针对 BPF 和 XDP 的 P4 编译器后端。 P4 是一种领域特定语言，描述了可编程网络元素（如 NIC、设备或"
"交换机）的数据平面如何处理数据包，并且在 p4c-xdp 的帮助下，P4 程序可以被翻译成 BPF C 程序，这些程序可以通过以下方"
"式编译 clang / LLVM 并作为 BPF 程序加载到 XDP 层的内核中，以进行高性能数据包处理。"

#: ../../bpf.rst:4541 3d32a4b18c734d89a02695d0cbb09311
msgid "https://github.com/vmware/p4c-xdp"
msgstr "https://github.com/vmware/p4c-xdp"

#: ../../bpf.rst:4547 9b41335f10bd444daa6efc681a50fb06
msgid "**LLVM**"
msgstr "**LLVM**"

#: ../../bpf.rst:4549 f15c556a2c5a4a998945d3ce41f0631f
msgid ""
"clang / LLVM provides the BPF back end in order to compile C BPF programs into BPF instructions contained in ELF "
"files. The LLVM BPF back end is developed alongside with the BPF core infrastructure in the Linux kernel and "
"maintained by the same community. clang / LLVM is a key part in the toolchain for developing BPF programs."
msgstr ""
"clang / LLVM 提供 BPF 后端，以便将 C BPF 程序编译成 ELF 文件中包含的 BPF 指令。 LLVM BPF 后端与 Linux 内核中的 "
"BPF 核心基础设施一起开发，并由同一社区维护。 clang / LLVM 是开发 BPF 程序的工具链中的关键部分。"

#: ../../bpf.rst:4555 dc11cf556e9946609fe1e2b27cf55ebb
msgid "https://llvm.org/"
msgstr "https://llvm.org/"

#: ../../bpf.rst:4559 779a1ed0506b42d69a5db1b8ac06ee98
msgid "**libbpf**"
msgstr "**libbpf**"

#: ../../bpf.rst:4561 2c56af46ba274f8cacc3cc7bcdda9a5e
msgid ""
"libbpf is a generic BPF library which is developed by the Linux kernel community as part of the kernel source "
"tree and allows for loading and attaching BPF programs from LLVM generated ELF files into the kernel. The "
"library is used by other kernel projects such as perf and bpftool."
msgstr ""
"libbpf 是一个通用的 BPF 库，由 Linux 内核社区开发，作为内核源代码树的一部分，允许将 BPF 程序从 LLVM 生成的 ELF 文"
"件加载和附加到内核中。 该库被其他内核项目使用，例如 perf 和 bpftool。"

#: ../../bpf.rst:4566 987802fc1b9c4bc09e211ed37f347f1d
msgid "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/lib/bpf"
msgstr "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/lib/bpf"

#: ../../bpf.rst:4570 baf976b0c61f4f98aca6c46b0959f099
msgid "**bpftool**"
msgstr "**bpftool**"

#: ../../bpf.rst:4572 697b83124fe24f02ad3b5b773a0d5bbf
msgid ""
"bpftool is the main tool for introspecting and debugging BPF programs and BPF maps, and like libbpf is developed "
"by the Linux kernel community. It allows for dumping all active BPF programs and maps in the system, dumping and "
"disassembling BPF or JITed BPF instructions from a program as well as dumping and manipulating BPF maps in the "
"system. bpftool supports interaction with the BPF filesystem, loading various program types from an object file "
"into the kernel and much more."
msgstr ""
"bpftool 是用于自省和调试 BPF 程序和 BPF 映射的主要工具，与 libbpf 一样是由 Linux 内核社区开发的。 它允许转储系统"
"中所有活动的 BPF 程序和映射，转储和反汇编程序中的 BPF 或 JITed BPF 指令，以及转储和操作系统中的 BPF 映射。 "
"bpftool 支持与 BPF 文件系统的交互，将各种程序类型从目标文件加载到内核等等。"

#: ../../bpf.rst:4580 24e36ffe8faa444da9eea0c106626545
msgid "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/bpf/bpftool"
msgstr "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/bpf/bpftool"

#: ../../bpf.rst:4584 d71a142a78b74a09945f97b1dbfbfc05
msgid "**cilium/ebpf**"
msgstr "**cilium/ebpf**"

#: ../../bpf.rst:4586 00fa7e3f08ac43589b93b6ffbb294874
msgid ""
"``cilium/ebpf`` (ebpf-go) is a pure Go library that provides utilities for loading, compiling, and debugging "
"eBPF programs. It has minimal external dependencies and is intended to be used in long-running processes."
msgstr ""
"``cilium/ebpf`` (ebpf-go) 是一个纯 Go 库，提供用于加载、编译和调试 eBPF 程序的实用程序。 它具有最小的外部依赖性，"
"旨在用于长时间运行的进程。"

#: ../../bpf.rst:4590 8051da6203474786ad84f3eac18221a8
msgid "Its ``bpf2go`` utility automates away compiling eBPF C programs and embedding them into Go binaries."
msgstr "它的 ``bpf2go`` 程序会自动编译 eBPF C 程序并将它们嵌入到 Go 二进制文件中。"

#: ../../bpf.rst:4593 ec789629c8aa48458418babc19185a35
msgid ""
"It implements attaching programs to various kernel hooks, as well as kprobes and uprobes for tracing arbitrary "
"kernel and user space functions. It also features a complete assembler that allows constructing eBPF programs at "
"runtime using Go, or modifying them after they've been loaded from an ELF object."
msgstr ""
"它实现了将程序附加到各种内核hook，以及用于跟踪任意内核和用户空间函数的 kprobes 和 uprobes。 它还具有一个完整的汇"
"编器，允许在运行时使用 Go 构建 eBPF 程序，或者在从 ELF 对象加载它们之后对其进行修改。"

#: ../../bpf.rst:4599 be1ff7e8d51649b88817cd1d523e6c6f
msgid "https://github.com/cilium/ebpf"
msgstr "https://github.com/cilium/ebpf"

#: ../../bpf.rst:4603 32cc92a88ea546a7ba8d39c3151d5bcd
msgid "**ebpf_asm**"
msgstr "**ebpf_asm**"

#: ../../bpf.rst:4605 e65900b07b184837b326aaf299e23d78
msgid ""
"ebpf_asm provides an assembler for BPF programs written in an Intel-like assembly syntax, and therefore offers "
"an alternative for writing BPF programs directly in assembly for cases where programs are rather small and "
"simple without needing the clang / LLVM toolchain."
msgstr ""
"ebpf_asm 为以类似 Intel 的汇编语法编写的 BPF 程序提供了一个汇编器，因此为程序相当小且简单而无需 clang / LLVM 工具"
"链的情况提供了一种直接在汇编中编写 BPF 程序的替代方案。"

#: ../../bpf.rst:4610 a75a66cd9e4341619640d8c8e4ae9cce
msgid "https://github.com/Xilinx-CNS/ebpf_asm"
msgstr "https://github.com/Xilinx-CNS/ebpf_asm"

#: ../../bpf.rst:4615 0f9f659136734a8b8633a01b15e7f045
msgid "XDP Newbies"
msgstr "XDP 新手"

#: ../../bpf.rst:4617 358e305dd3e7448993bd5ea36df6e80b
msgid ""
"There are a couple of walk-through posts by David S. Miller to the xdp-newbies mailing list (http://vger.kernel."
"org/vger-lists.html#xdp-newbies), which explain various parts of XDP and BPF:"
msgstr ""
"David S. Miller 在 xdp-newbies 邮件列表 (http://vger.kernel.org/vger-lists.html#xdp-newbies) 上发表了几篇入门文"
"章，解释了 XDP 的各个部分和 BPF："

#: ../../bpf.rst:4624 ../../bpf.rst:4629 ../../bpf.rst:4634 ../../bpf.rst:4706 ../../bpf.rst:4711
#: ../../bpf.rst:4716 ../../bpf.rst:4893 ../../bpf.rst:4899 ../../bpf.rst:4905 ../../bpf.rst:4911
#: 170547f543d94d9e8aad5679edfde816 179e90c2602c4c0d9fd36567176f16af 1c9058c548584ab0932c274a4a84ee14
#: 21e0a38368e74f38b65d019225bfaaeb 43d685cc681240e6a5f6ccfb3b0b8f56 50e6caced0d94aadb6c711eae61cd6a5
#: 70634430630d42feb308c7cbf502e9d2 8d4e2ffc297d4b03a67fe0e9698c88a2 a3d71184ac51455e8b05adb4ea636457
#: fcf683e9ed9041e18333d10644c40634
msgid "May 2017,"
msgstr "May 2017,"

#: ../../bpf.rst:4622 0d700b6f48e04e90bcc625222d0ff087
msgid "BPF Verifier Overview, David S. Miller, https://www.spinics.net/lists/xdp-newbies/msg00185.html"
msgstr "BPF Verifier Overview, David S. Miller, https://www.spinics.net/lists/xdp-newbies/msg00185.html"

#: ../../bpf.rst:4627 912b7045c76145e39294a8cef950f475
msgid "Contextually speaking..., David S. Miller, https://www.spinics.net/lists/xdp-newbies/msg00181.html"
msgstr "Contextually speaking…, David S. Miller, https://www.spinics.net/lists/xdp-newbies/msg00181.html"

#: ../../bpf.rst:4632 eb0763046c1d442989507df625c56953
msgid "bpf.h and you..., David S. Miller, https://www.spinics.net/lists/xdp-newbies/msg00179.html"
msgstr "bpf.h and you…, David S. Miller, https://www.spinics.net/lists/xdp-newbies/msg00179.html"

#: ../../bpf.rst:4639 ../../bpf.rst:4721 ../../bpf.rst:4726 ../../bpf.rst:4731 ../../bpf.rst:4917
#: ../../bpf.rst:4923 ../../bpf.rst:4929 ../../bpf.rst:4935 ../../bpf.rst:4941 1031575401224d618acad9e961628eb1
#: 2c2953621dd540a5b9d5c67c58e2b23f 424a894b9dd541688533ace0adb12aaf 59a52a5b467a4530a47a98c52107fde0
#: a42e6ca4b6b142c98e914d00e6da67b3 a97cb3bda2354d2d8bb621a609460e62 d0b145ece8f14bb5a0d1e718c4752182
#: ee6f24b7feed4032a3045f19233dc143 f1270939dc75411aa9372be46ad0b192
msgid "Apr 2017,"
msgstr "Apr 2017,"

#: ../../bpf.rst:4637 9a4720d31d004aa78c56ff7438961daa
msgid "XDP example of the day, David S. Miller, https://www.spinics.net/lists/xdp-newbies/msg00009.html"
msgstr "XDP example of the day, David S. Miller, https://www.spinics.net/lists/xdp-newbies/msg00009.html"

#: ../../bpf.rst:4642 4ea2d64eaf6a4c629e1f1aa70f1755a2
msgid "BPF Newsletter"
msgstr "BPF Newsletter"

#: ../../bpf.rst:4644 49ce9864e8704a12b5d6d919093381be
msgid ""
"Alexander Alemayhu initiated a newsletter around BPF roughly once per week covering latest developments around "
"BPF in Linux kernel land and its surrounding ecosystem in user space."
msgstr ""
"Alexander Alemayhu 大约每周发起一次关于 BPF 的时事通讯，涵盖 Linux 内核领域中 BPF 及其在用户空间中的周边生态系统"
"的最新进展。"

#: ../../bpf.rst:4648 7ee2f161de7d47c28cd2380a0e9e149d
msgid "All BPF update newsletters (01 - 12) can be found here:"
msgstr "所有 BPF 更新时事通讯 (01 - 12) 都可以在这里找到："

#: ../../bpf.rst:4650 139047dc7c9a46de9139dbbddc3ea9d6
msgid "https://cilium.io/blog/categories/eBPF/"
msgstr "https://cilium.io/blog/categories/eBPF/"

#: ../../bpf.rst:4652 e3b354c0623741b0ab986bb6a59ef78a
msgid "And for the news on the latest resources and developments in the eBPF world, please refer to the link here:"
msgstr "有关 eBPF 世界最新资源和发展的新闻，请参阅此处的链接："

#: ../../bpf.rst:4655 f7d5f95be5ae410b86a1d37730128e23
msgid "https://ebpf.io/blog"
msgstr "https://ebpf.io/blog"

#: ../../bpf.rst:4658 058e65cefdae488b8b29dfca2009af39
msgid "Podcasts"
msgstr "播客"

#: ../../bpf.rst:4660 53b2b517825d420ca8422301e94de323
msgid "There have been a number of technical podcasts partially covering BPF. Incomplete list:"
msgstr "有许多技术播客部分涵盖了 BPF。 不完整清单："

#: ../../bpf.rst:4668 ../../bpf.rst:4970 ../../bpf.rst:4976 ../../bpf.rst:4982 1b16c001b24943b58326de09f69cc4bf
#: 3b1e3f8685c243c39f2270c0518fd4f4 91901a9c1c4842288078055dbebcba9b 9e458dccc1d44df19074ca35c6134666
msgid "Feb 2017,"
msgstr "Feb 2017,"

#: ../../bpf.rst:4664 5a5732be479e4cc4ae420514519460ca
msgid ""
"Linux Networking Update from Netdev Conference, Thomas Graf, Software Gone Wild, Show 71, https://blog.ipspace."
"net/2017/02/linux-networking-update-from-netdev.html https://www.ipspace.net/nuggets/podcast/Show_71-"
"NetDev_Update.mp3"
msgstr ""
"Linux Networking Update from Netdev Conference, Thomas Graf, Software Gone Wild, Show 71, https://blog.ipspace."
"net/2017/02/linux-networking-update-from-netdev.html https://www.ipspace.net/nuggets/podcast/Show_71-"
"NetDev_Update.mp3"

#: ../../bpf.rst:4675 ../../bpf.rst:4741 ../../bpf.rst:4988 0c79919b365f456a890bbd2dd2913a17
#: 37aa1f35a7bc412e8a05ae68c6646fca f8298de8e0914b24a53df130728b93f6
msgid "Jan 2017,"
msgstr "Jan 2017,"

#: ../../bpf.rst:4671 a78fe614c35d4acf9799b902d6832117
msgid ""
"The IO Visor Project, Brenden Blanco, OVS Orbit, Episode 23, https://ovsorbit.org/#e23 https://ovsorbit.org/"
"episode-23.mp3"
msgstr ""
"The IO Visor Project, Brenden Blanco, OVS Orbit, Episode 23, https://ovsorbit.org/#e23 https://ovsorbit.org/"
"episode-23.mp3"

#: ../../bpf.rst:4682 ../../bpf.rst:4761 ../../bpf.rst:4766 ../../bpf.rst:4771 ../../bpf.rst:4776
#: ../../bpf.rst:4781 ../../bpf.rst:4786 ../../bpf.rst:4791 ../../bpf.rst:4796 ../../bpf.rst:5012
#: ../../bpf.rst:5018 ../../bpf.rst:5024 ../../bpf.rst:5030 ../../bpf.rst:5036 ../../bpf.rst:5042
#: ../../bpf.rst:5048 ../../bpf.rst:5055 ../../bpf.rst:5061 0e6a2b5078b14fa38ed93ce11e9d42ec
#: 17412092cf3546ea945df918a17e0ec0 23c746f55b6048cc9593e20e5db3fa38 27ddaf8809c94aa5b451cec239730840
#: 3d29680328c74e898d66ebfffa783518 68e0e9164fe9442da136951eb0c6f36a 7121cc80ac6145f690c5f567e8c7c203
#: 844a4a2282c24dde9824fa1666d905f3 9b7295db5c4c4b2897f49ffc755fa9ba 9bd493ef4a81426996e6484d67ecbc8a
#: 9c4b3836dec140dd8e4416af17cf75e4 a60315a79d8c43e69412e42517c4bb74 b46509ed8cad43f2bb26ce01e515f089
#: be9db0a4bc89429994a0ee17aa93086e c842558d532f42a6a55d47e7b935079b ca8e3a9bb6ae411cba1ca76e5bf284dd
#: caab1918d6954925a10e97429282f10f d9d1e85fc00448dcb5c4d1afbe8c62d6
msgid "Oct 2016,"
msgstr "Oct 2016,"

#: ../../bpf.rst:4678 4d186d96444848ed97ee25170ce5ac45
msgid ""
"Fast Linux Packet Forwarding, Thomas Graf, Software Gone Wild, Show 64, https://blog.ipspace.net/2016/10/fast-"
"linux-packet-forwarding-with.html https://www.ipspace.net/nuggets/podcast/Show_64-Cilium_with_Thomas_Graf.mp3"
msgstr ""
"Fast Linux Packet Forwarding, Thomas Graf, Software Gone Wild, Show 64, https://blog.ipspace.net/2016/10/fast-"
"linux-packet-forwarding-with.html https://www.ipspace.net/nuggets/podcast/Show_64-Cilium_with_Thomas_Graf.mp3"

#: ../../bpf.rst:4689 ../../bpf.rst:4806 ../../bpf.rst:5067 ../../bpf.rst:5073 ../../bpf.rst:5078
#: 47f11395c05345d8bc759b3527995e33 757fdcfd7d794a37a9988db5ab5d00c0 7704e11c5c4d49aa93b9ca46c5bbaf6c
#: dcf4c201d9c94aa8901a56c5b7e05dd3 e48541e224d34909a0d65034b5c62c46
msgid "Aug 2016,"
msgstr "Aug 2016,"

#: ../../bpf.rst:4685 ada33d52b1f8407aad7a3cc24ead9078
msgid ""
"P4 on the Edge, John Fastabend, OVS Orbit, Episode 11, https://ovsorbit.org/#e11 https://ovsorbit.org/episode-11."
"mp3"
msgstr ""
"P4 on the Edge, John Fastabend, OVS Orbit, Episode 11, https://ovsorbit.org/#e11 https://ovsorbit.org/episode-11."
"mp3"

#: ../../bpf.rst:4696 ../../bpf.rst:5096 1a0b98c07c69478295e46cb068b07363 69d9f2b461534677b9d82f2f7397661a
msgid "May 2016,"
msgstr "May 2016,"

#: ../../bpf.rst:4692 02953c0957314dc2856da7ddc308d67a
msgid "Cilium, Thomas Graf, OVS Orbit, Episode 4, https://ovsorbit.org/#e4 https://ovsorbit.org/episode-4.mp3"
msgstr "Cilium, Thomas Graf, OVS Orbit, Episode 4, https://ovsorbit.org/#e4 https://ovsorbit.org/episode-4.mp3"

#: ../../bpf.rst:4699 3a6ca8282bbb4a438f677162de422a22
msgid "Blog posts"
msgstr "相关博客"

#: ../../bpf.rst:4701 330267def4064223a465c154c9e042a0
msgid "The following (incomplete) list includes blog posts around BPF, XDP and related projects:"
msgstr "The following (incomplete) list includes blog posts around BPF, XDP and related projects:"

#: ../../bpf.rst:4704 d38e34393b2747c7969b60985921ad75
msgid ""
"An entertaining eBPF XDP adventure, Suchakra Sharma, https://suchakra.wordpress.com/2017/05/23/an-entertaining-"
"ebpf-xdp-adventure/"
msgstr ""
"An entertaining eBPF XDP adventure, Suchakra Sharma, https://suchakra.wordpress.com/2017/05/23/an-entertaining-"
"ebpf-xdp-adventure/"

#: ../../bpf.rst:4709 3691997add3a4dc4837b08cdaf4ec0e6
msgid "eBPF, part 2: Syscall and Map Types, Ferris Ellis, https://ferrisellis.com/posts/ebpf_syscall_and_maps/"
msgstr "eBPF, part 2: Syscall and Map Types, Ferris Ellis, https://ferrisellis.com/posts/ebpf_syscall_and_maps/"

#: ../../bpf.rst:4714 c9ada14895264088a07175d9bf2cd197
msgid ""
"Monitoring the Control Plane, Gary Berger, https://www.firstclassfunc.com/2018/07/monitoring-the-control-plane/"
msgstr ""
"USENIX/LISA 2016 Linux bcc/BPF Tools, Brendan Gregg, http://www.brendangregg.com/blog/2017-04-29/usenix-"
"lisa-2016-bcc-bpf-tools.html"

#: ../../bpf.rst:4719 d17ee7a560414171abac1d6ddcf1ce8a
msgid ""
"USENIX/LISA 2016 Linux bcc/BPF Tools, Brendan Gregg, http://www.brendangregg.com/blog/2017-04-29/usenix-"
"lisa-2016-bcc-bpf-tools.html"
msgstr ""
"USENIX/LISA 2016 Linux bcc/BPF Tools, Brendan Gregg, http://www.brendangregg.com/blog/2017-04-29/usenix-"
"lisa-2016-bcc-bpf-tools.html"

#: ../../bpf.rst:4724 d1544a6727ed4ad0ac016fe97c37ec6d
msgid ""
"Liveblog: Cilium for Network and Application Security with BPF and XDP, Scott Lowe, https://blog.scottlowe."
"org/2017/04/18/black-belt-cilium/"
msgstr ""
"Liveblog: Cilium for Network and Application Security with BPF and XDP, Scott Lowe, https://blog.scottlowe."
"org/2017/04/18/black-belt-cilium/"

#: ../../bpf.rst:4729 8cc72bc630e344f88d8f86e97c27471a
msgid ""
"eBPF, part 1: Past, Present, and Future, Ferris Ellis, https://ferrisellis.com/posts/ebpf_past_present_future/"
msgstr ""
"eBPF, part 1: Past, Present, and Future, Ferris Ellis, https://ferrisellis.com/posts/ebpf_past_present_future/"

#: ../../bpf.rst:4736 ../../bpf.rst:4947 ../../bpf.rst:4952 ../../bpf.rst:4958 ../../bpf.rst:4964
#: 7a55c61ded974d069fb16afbbabd2296 811bf4bd65054bb1948fedc92739a09a 8d3f253d062345a39684d0ad9c1ffbdf
#: ad053af2888d40b1bde52289f8a1a2e4 bae28411ac1f463e9af984f802e1aff5
msgid "Mar 2017,"
msgstr "Mar 2017,"

#: ../../bpf.rst:4734 d96c1c1977b049cca536d45c734a1e24
msgid ""
"Analyzing KVM Hypercalls with eBPF Tracing, Suchakra Sharma, https://suchakra.wordpress.com/2017/03/31/analyzing-"
"kvm-hypercalls-with-ebpf-tracing/"
msgstr ""
"Analyzing KVM Hypercalls with eBPF Tracing, Suchakra Sharma, https://suchakra.wordpress.com/2017/03/31/analyzing-"
"kvm-hypercalls-with-ebpf-tracing/"

#: ../../bpf.rst:4739 c9b56274a6bb4c4893bca8f19e209a39
msgid ""
"Golang bcc/BPF Function Tracing, Brendan Gregg, http://www.brendangregg.com/blog/2017-01-31/golang-bcc-bpf-"
"function-tracing.html"
msgstr ""
"Golang bcc/BPF Function Tracing, Brendan Gregg, http://www.brendangregg.com/blog/2017-01-31/golang-bcc-bpf-"
"function-tracing.html"

#: ../../bpf.rst:4746 ../../bpf.rst:4994 12c7a64ae2eb470f919b99fdfb583d16 1f1000c9f2db466c932c8e9b9dd3fd7b
msgid "Dec 2016,"
msgstr "Dec 2016,"

#: ../../bpf.rst:4744 7b96dbb4408d429d974b7d53b24de3f1
msgid ""
"Give me 15 minutes and I'll change your view of Linux tracing, Brendan Gregg, http://www.brendangregg.com/"
"blog/2016-12-27/linux-tracing-in-15-minutes.html"
msgstr ""
"Give me 15 minutes and I’ll change your view of Linux tracing, Brendan Gregg, http://www.brendangregg.com/"
"blog/2016-12-27/linux-tracing-in-15-minutes.html"

#: ../../bpf.rst:4751 ../../bpf.rst:4756 ../../bpf.rst:5000 ../../bpf.rst:5006 06c91ae95c1f48caacbe0a3eece5b71c
#: 218f2dd024a143d6a74180142f2afb9d d978c681d8a24080a99dfb800d4a1767 e5821a36a7ad441ca90f79a1f82745f0
msgid "Nov 2016,"
msgstr "Nov 2016,"

#: ../../bpf.rst:4749 b5d26f63f9fe49b1bddc5e6e8002f558
msgid ""
"Cilium: Networking and security for containers with BPF and XDP, Daniel Borkmann, https://opensource.googleblog."
"com/2016/11/cilium-networking-and-security.html"
msgstr ""
"Cilium: Networking and security for containers with BPF and XDP, Daniel Borkmann, https://opensource.googleblog."
"com/2016/11/cilium-networking-and-security.html"

#: ../../bpf.rst:4754 1cde38815ff44f74b07211a9717f9638
msgid ""
"Linux bcc/BPF tcplife: TCP Lifespans, Brendan Gregg, http://www.brendangregg.com/blog/2016-11-30/linux-bcc-"
"tcplife.html"
msgstr ""
"Linux bcc/BPF tcplife: TCP Lifespans, Brendan Gregg, http://www.brendangregg.com/blog/2016-11-30/linux-bcc-"
"tcplife.html"

#: ../../bpf.rst:4759 cb4c6ddf071941fb96f3522365835b64
msgid ""
"DTrace for Linux 2016, Brendan Gregg, http://www.brendangregg.com/blog/2016-10-27/dtrace-for-linux-2016.html"
msgstr ""
"DTrace for Linux 2016, Brendan Gregg, http://www.brendangregg.com/blog/2016-10-27/dtrace-for-linux-2016.html"

#: ../../bpf.rst:4764 945e8db47ac2422aadd61414c35695bb
msgid ""
"Linux 4.9's Efficient BPF-based Profiler, Brendan Gregg, http://www.brendangregg.com/blog/2016-10-21/linux-"
"efficient-profiler.html"
msgstr ""
"Linux 4.9’s Efficient BPF-based Profiler, Brendan Gregg, http://www.brendangregg.com/blog/2016-10-21/linux-"
"efficient-profiler.html"

#: ../../bpf.rst:4769 9fca6409d06e4a82a5839911433f3daa
msgid "Linux bcc tcptop, Brendan Gregg, http://www.brendangregg.com/blog/2016-10-15/linux-bcc-tcptop.html"
msgstr "Linux bcc tcptop, Brendan Gregg, http://www.brendangregg.com/blog/2016-10-15/linux-bcc-tcptop.html"

#: ../../bpf.rst:4774 571d113705db494b90c082c11a91eea9
msgid ""
"Linux bcc/BPF Node.js USDT Tracing, Brendan Gregg, http://www.brendangregg.com/blog/2016-10-12/linux-bcc-nodejs-"
"usdt.html"
msgstr ""
"Linux bcc/BPF Node.js USDT Tracing, Brendan Gregg, http://www.brendangregg.com/blog/2016-10-12/linux-bcc-nodejs-"
"usdt.html"

#: ../../bpf.rst:4779 262c67a7df5c41c59f9164917d1df17d
msgid ""
"Linux bcc/BPF Run Queue (Scheduler) Latency, Brendan Gregg, http://www.brendangregg.com/blog/2016-10-08/linux-"
"bcc-runqlat.html"
msgstr ""
"Linux bcc/BPF Run Queue (Scheduler) Latency, Brendan Gregg, http://www.brendangregg.com/blog/2016-10-08/linux-"
"bcc-runqlat.html"

#: ../../bpf.rst:4784 8482cc17ab8f4bfb8628b020eceba14c
msgid ""
"Linux bcc ext4 Latency Tracing, Brendan Gregg, http://www.brendangregg.com/blog/2016-10-06/linux-bcc-ext4dist-"
"ext4slower.html"
msgstr ""
"Linux bcc ext4 Latency Tracing, Brendan Gregg, http://www.brendangregg.com/blog/2016-10-06/linux-bcc-ext4dist-"
"ext4slower.html"

#: ../../bpf.rst:4789 1d74aa01b6f540349a56c1745cff2581
msgid ""
"Linux MySQL Slow Query Tracing with bcc/BPF, Brendan Gregg, http://www.brendangregg.com/blog/2016-10-04/linux-"
"bcc-mysqld-qslower.html"
msgstr ""
"Linux MySQL Slow Query Tracing with bcc/BPF, Brendan Gregg, http://www.brendangregg.com/blog/2016-10-04/linux-"
"bcc-mysqld-qslower.html"

#: ../../bpf.rst:4794 40aa6a3b5ff648d496f369373e835e4c
msgid ""
"Linux bcc Tracing Security Capabilities, Brendan Gregg, http://www.brendangregg.com/blog/2016-10-01/linux-bcc-"
"security-capabilities.html"
msgstr ""
"Linux bcc Tracing Security Capabilities, Brendan Gregg, http://www.brendangregg.com/blog/2016-10-01/linux-bcc-"
"security-capabilities.html"

#: ../../bpf.rst:4801 0037d0149d7f467aa2bd7af21aaa696d
msgid "Sep 2016,"
msgstr "Sep 2016,"

#: ../../bpf.rst:4799 357ebaf3ec9c4cffbb42d5994c490602
msgid ""
"Suricata bypass feature, Eric Leblond, https://www.stamus-networks.com/blog/2016/09/28/suricata-bypass-feature"
msgstr ""
"Suricata bypass feature, Eric Leblond, https://www.stamus-networks.com/blog/2016/09/28/suricata-bypass-feature"

#: ../../bpf.rst:4804 4d42815060d7427aae53ae634f89c30a
msgid ""
"Introducing the p0f BPF compiler, Gilberto Bertin, https://blog.cloudflare.com/introducing-the-p0f-bpf-compiler/"
msgstr ""
"Introducing the p0f BPF compiler, Gilberto Bertin, https://blog.cloudflare.com/introducing-the-p0f-bpf-compiler/"

#: ../../bpf.rst:4811 bef2d4e29cf4419fb5f62f500045da89
msgid "Jun 2016,"
msgstr "Jun 2016,"

#: ../../bpf.rst:4809 c497ea40fe694e908e3187475f029326
msgid ""
"Ubuntu Xenial bcc/BPF, Brendan Gregg, http://www.brendangregg.com/blog/2016-06-14/ubuntu-xenial-bcc-bpf.html"
msgstr ""
"Ubuntu Xenial bcc/BPF, Brendan Gregg, http://www.brendangregg.com/blog/2016-06-14/ubuntu-xenial-bcc-bpf.html"

#: ../../bpf.rst:4816 ../../bpf.rst:4821 ../../bpf.rst:5102 ../../bpf.rst:5107 71da24728f454872a9b4e59e74568b69
#: 8247adcc58f34465ba74fe5fa0635d16 8fcb1d4565784889980d989a93420706 c56d171774364d95808be367d3434485
msgid "Mar 2016,"
msgstr "Mar 2016,"

#: ../../bpf.rst:4814 26b03d68c5a44c0181e83253e1004816
msgid ""
"Linux BPF/bcc Road Ahead, March 2016, Brendan Gregg, http://www.brendangregg.com/blog/2016-03-28/linux-bpf-bcc-"
"road-ahead-2016.html"
msgstr ""
"Linux BPF/bcc Road Ahead, March 2016, Brendan Gregg, http://www.brendangregg.com/blog/2016-03-28/linux-bpf-bcc-"
"road-ahead-2016.html"

#: ../../bpf.rst:4819 5e9b73d2f76542ac9788a98e66379151
msgid ""
"Linux BPF Superpowers, Brendan Gregg, http://www.brendangregg.com/blog/2016-03-05/linux-bpf-superpowers.html"
msgstr ""
"Linux BPF Superpowers, Brendan Gregg, http://www.brendangregg.com/blog/2016-03-05/linux-bpf-superpowers.html"

#: ../../bpf.rst:4826 ../../bpf.rst:4831 ../../bpf.rst:4836 ../../bpf.rst:5114 0cabfe3a38ad4a2ea18db98ddff6913e
#: 2b52631c7b8445d5bb965d8236005d1e d22f1dac68f64d7c81d61e58cbe8c103 d94488afa91b4bc8b1a7bdbc9adac9df
msgid "Feb 2016,"
msgstr "Feb 2016,"

#: ../../bpf.rst:4824 34f79b9e51534d26af5f87df782b1c86
msgid ""
"Linux eBPF/bcc uprobes, Brendan Gregg, http://www.brendangregg.com/blog/2016-02-08/linux-ebpf-bcc-uprobes.html"
msgstr ""
"Linux eBPF/bcc uprobes, Brendan Gregg, http://www.brendangregg.com/blog/2016-02-08/linux-ebpf-bcc-uprobes.html"

#: ../../bpf.rst:4829 3804d0feed9b4b4f8f52908da220f8d3
msgid ""
"Who is waking the waker? (Linux chain graph prototype), Brendan Gregg, http://www.brendangregg.com/"
"blog/2016-02-05/ebpf-chaingraph-prototype.html"
msgstr ""
"Who is waking the waker? (Linux chain graph prototype), Brendan Gregg, http://www.brendangregg.com/"
"blog/2016-02-05/ebpf-chaingraph-prototype.html"

#: ../../bpf.rst:4834 1c1783cba9fd472e8d2489e8bf4e8b47
msgid ""
"Linux Wakeup and Off-Wake Profiling, Brendan Gregg, http://www.brendangregg.com/blog/2016-02-01/linux-wakeup-"
"offwake-profiling.html"
msgstr ""
"Linux Wakeup and Off-Wake Profiling, Brendan Gregg, http://www.brendangregg.com/blog/2016-02-01/linux-wakeup-"
"offwake-profiling.html"

#: ../../bpf.rst:4841 ../../bpf.rst:4846 ../../bpf.rst:5120 0d7fff61950b4d4e9207910285249d09
#: 31fbd99ec73d41d999754288e6f9a6c0 c2626f0b61cd40d382e7d46dc3acd646
msgid "Jan 2016,"
msgstr "Jan 2016,"

#: ../../bpf.rst:4839 2e705abca1164766848707d3a8b87cfe
msgid ""
"Linux eBPF Off-CPU Flame Graph, Brendan Gregg, http://www.brendangregg.com/blog/2016-01-20/ebpf-offcpu-flame-"
"graph.html"
msgstr ""
"Linux eBPF Off-CPU Flame Graph, Brendan Gregg, http://www.brendangregg.com/blog/2016-01-20/ebpf-offcpu-flame-"
"graph.html"

#: ../../bpf.rst:4844 15b8ebec1d7c477d8a88a92760f927c8
msgid ""
"Linux eBPF Stack Trace Hack, Brendan Gregg, http://www.brendangregg.com/blog/2016-01-18/ebpf-stack-trace-hack."
"html"
msgstr ""
"Linux eBPF Stack Trace Hack, Brendan Gregg, http://www.brendangregg.com/blog/2016-01-18/ebpf-stack-trace-hack."
"html"

#: ../../bpf.rst:4851 df73d4a00cd94afebb88c5117e38a70b
msgid "Sep 2015,"
msgstr "Sep 2015,"

#: ../../bpf.rst:4849 5e0b5b20348845e095a42457b721646c
msgid ""
"Linux Networking, Tracing and IO Visor, a New Systems Performance Tool for a Distributed World, Suchakra Sharma, "
"https://thenewstack.io/comparing-dtrace-iovisor-new-systems-performance-platform-advance-linux-networking-"
"virtualization/"
msgstr ""
"Linux Networking, Tracing and IO Visor, a New Systems Performance Tool for a Distributed World, Suchakra Sharma, "
"https://thenewstack.io/comparing-dtrace-iovisor-new-systems-performance-platform-advance-linux-networking-"
"virtualization/"

#: ../../bpf.rst:4856 ../../bpf.rst:5132 18ecf2ba517042999ab82a02ba11e969 99d46d4d66d443be95e1b50a53907fae
msgid "Aug 2015,"
msgstr "Aug 2015,"

#: ../../bpf.rst:4854 64232f1315584c09971a009c38d5224b
msgid "BPF Internals - II, Suchakra Sharma, https://suchakra.wordpress.com/2015/08/12/bpf-internals-ii/"
msgstr "BPF Internals - II, Suchakra Sharma, https://suchakra.wordpress.com/2015/08/12/bpf-internals-ii/"

#: ../../bpf.rst:4861 ../../bpf.rst:4866 0602d3c9993548fb9c05d32e2226f837 7f0fa5b8e1634fa9b29eb278f591276a
msgid "May 2015,"
msgstr "May 2015,"

#: ../../bpf.rst:4859 53735776b9864678a296bdbda2c44bd3
msgid "eBPF: One Small Step, Brendan Gregg, http://www.brendangregg.com/blog/2015-05-15/ebpf-one-small-step.html"
msgstr "eBPF: One Small Step, Brendan Gregg, http://www.brendangregg.com/blog/2015-05-15/ebpf-one-small-step.html"

#: ../../bpf.rst:4864 6b01e3bb3c6944bcace47a0f2d1a7c7e
msgid "BPF Internals - I, Suchakra Sharma, https://suchakra.wordpress.com/2015/05/18/bpf-internals-i/"
msgstr "BPF Internals - I, Suchakra Sharma, https://suchakra.wordpress.com/2015/05/18/bpf-internals-i/"

#: ../../bpf.rst:4871 2bc51637723b425299ca29a458b407d6
msgid "Jul 2014,"
msgstr "Jul 2014,"

#: ../../bpf.rst:4869 a5d03ef2bba241cca50038235ba84c7a
msgid "Introducing the BPF Tools, Marek Majkowski, https://blog.cloudflare.com/introducing-the-bpf-tools/"
msgstr "Introducing the BPF Tools, Marek Majkowski, https://blog.cloudflare.com/introducing-the-bpf-tools/"

#: ../../bpf.rst:4876 ddc7e2cc9ad340f4850111736692c03c
msgid "May 2014,"
msgstr "May 2014,"

#: ../../bpf.rst:4874 f03eb4965c4846ce91e8a83a9c8a6e89
msgid "BPF - the forgotten bytecode, Marek Majkowski, https://blog.cloudflare.com/bpf-the-forgotten-bytecode/"
msgstr "BPF - 被遗忘的字节码，Marek Majkowski，https://blog.cloudflare.com/bpf-the-forgotten-bytecode/"

#: ../../bpf.rst:4879 9af04982711a4d8cadfef8a46d5676a5
msgid "Books"
msgstr "书籍"

#: ../../bpf.rst:4881 b498048755824cf5a65b4fdc605ef458
msgid "BPF Performance Tools (Gregg, Addison Wesley, 2019)"
msgstr "BPF 性能工具（Gregg，Addison Wesley，2019）"

#: ../../bpf.rst:4884 e15c53be1f2244bba381ef8baea33694
msgid "Talks"
msgstr "分享"

#: ../../bpf.rst:4886 cd4c756118f0419ca71288b02a86050d
msgid "The following (incomplete) list includes talks and conference papers related to BPF and XDP:"
msgstr "The following (incomplete) list includes talks and conference papers related to BPF and XDP:"

#: ../../bpf.rst:4890 706f240092c34cd3a37e0b49d41dbd99
msgid ""
"PyCon 2017, Portland, Executing python functions in the linux kernel by transpiling to bpf, Alex Gartrell, "
"https://www.youtube.com/watch?v=CpqMroMBGP4"
msgstr ""
"PyCon 2017, Portland, Executing python functions in the linux kernel by transpiling to bpf, Alex Gartrell, "
"https://www.youtube.com/watch?v=CpqMroMBGP4"

#: ../../bpf.rst:4896 d2b40f1e2c0a4bbc8b83245bb3d0942d
msgid ""
"gluecon 2017, Denver, Cilium + BPF: Least Privilege Security on API Call Level for Microservices, Dan Wendlandt, "
"http://gluecon.com/#agenda"
msgstr ""
"gluecon 2017, Denver, Cilium + BPF: Least Privilege Security on API Call Level for Microservices, Dan Wendlandt, "
"http://gluecon.com/#agenda"

#: ../../bpf.rst:4902 d2f480d8b91140ee8714e09a817e1fe3
msgid ""
"Lund Linux Con, Lund, XDP - eXpress Data Path, Jesper Dangaard Brouer, http://people.netfilter.org/hawk/"
"presentations/LLC2017/XDP_DDoS_protecting_LLC2017.pdf"
msgstr ""
"Lund Linux Con, Lund, XDP - eXpress Data Path, Jesper Dangaard Brouer, http://people.netfilter.org/hawk/"
"presentations/LLC2017/XDP_DDoS_protecting_LLC2017.pdf"

#: ../../bpf.rst:4908 2be189ae16e74c6ea66cd0c97e5128ab
msgid ""
"Polytechnique Montreal, Trace Aggregation and Collection with eBPF, Suchakra Sharma, https://nova.polymtl.ca/"
"~suchakra/eBPF-5May2017.pdf"
msgstr ""
"Polytechnique Montreal, Trace Aggregation and Collection with eBPF, Suchakra Sharma, https://nova.polymtl.ca/"
"~suchakra/eBPF-5May2017.pdf"

#: ../../bpf.rst:4914 74365d50743f44e4934f7d802226e7f6
msgid ""
"DockerCon, Austin, Cilium - Network and Application Security with BPF and XDP, Thomas Graf, https://www."
"slideshare.net/ThomasGraf5/dockercon-2017-cilium-network-and-application-security-with-bpf-and-xdp"
msgstr ""
"DockerCon, Austin, Cilium - Network and Application Security with BPF and XDP, Thomas Graf, https://www."
"slideshare.net/ThomasGraf5/dockercon-2017-cilium-network-and-application-security-with-bpf-and-xdp"

#: ../../bpf.rst:4920 1c60115398df4a4492abad1364d8f34a
msgid ""
"NetDev 2.1, Montreal, XDP Mythbusters, David S. Miller, https://netdevconf.info/2.1/slides/apr7/miller-XDP-"
"MythBusters.pdf"
msgstr ""
"NetDev 2.1, Montreal, XDP Mythbusters, David S. Miller, https://netdevconf.info/2.1/slides/apr7/miller-XDP-"
"MythBusters.pdf"

#: ../../bpf.rst:4926 8f80aa81f4d54b7a859bbc9ab437a00f
msgid ""
"NetDev 2.1, Montreal, Droplet: DDoS countermeasures powered by BPF + XDP, Huapeng Zhou, Doug Porter, Ryan "
"Tierney, Nikita Shirokov, https://netdevconf.info/2.1/slides/apr6/zhou-netdev-xdp-2017.pdf"
msgstr ""
"NetDev 2.1, Montreal, Droplet: DDoS countermeasures powered by BPF + XDP, Huapeng Zhou, Doug Porter, Ryan "
"Tierney, Nikita Shirokov, https://netdevconf.info/2.1/slides/apr6/zhou-netdev-xdp-2017.pdf"

#: ../../bpf.rst:4932 2609df4f2eaa451e9945b2165bab8587
msgid ""
"NetDev 2.1, Montreal, XDP in practice: integrating XDP in our DDoS mitigation pipeline, Gilberto Bertin, https://"
"netdevconf.info/2.1/slides/apr6/bertin_Netdev-XDP.pdf"
msgstr ""
"NetDev 2.1, Montreal, XDP in practice: integrating XDP in our DDoS mitigation pipeline, Gilberto Bertin, https://"
"netdevconf.info/2.1/slides/apr6/bertin_Netdev-XDP.pdf"

#: ../../bpf.rst:4938 e55ce9c5917c4c05942fc3d81f167897
msgid ""
"NetDev 2.1, Montreal, XDP for the Rest of Us, Andy Gospodarek, Jesper Dangaard Brouer, https://netdevconf."
"info/2.1/slides/apr7/gospodarek-Netdev2.1-XDP-for-the-Rest-of-Us_Final.pdf"
msgstr ""
"NetDev 2.1, Montreal, XDP for the Rest of Us, Andy Gospodarek, Jesper Dangaard Brouer, https://netdevconf."
"info/2.1/slides/apr7/gospodarek-Netdev2.1-XDP-for-the-Rest-of-Us_Final.pdf"

#: ../../bpf.rst:4944 5da6c977985a4daf924dcdf4fc9ce14c
msgid ""
"SCALE15x, Pasadena, Linux 4.x Tracing: Performance Analysis with bcc/BPF, Brendan Gregg, https://www.slideshare."
"net/brendangregg/linux-4x-tracing-performance-analysis-with-bccbpf"
msgstr ""
"SCALE15x, Pasadena, Linux 4.x Tracing: Performance Analysis with bcc/BPF, Brendan Gregg, https://www.slideshare."
"net/brendangregg/linux-4x-tracing-performance-analysis-with-bccbpf"

#: ../../bpf.rst:4950 5da2e8f84a8e4f11bb67bddf83063cf5
msgid ""
"XDP Inside and Out, David S. Miller, https://raw.githubusercontent.com/iovisor/bpf-docs/master/"
"XDP_Inside_and_Out.pdf"
msgstr ""
"XDP Inside and Out, David S. Miller, https://raw.githubusercontent.com/iovisor/bpf-docs/master/"
"XDP_Inside_and_Out.pdf"

#: ../../bpf.rst:4955 f15510a834c740b3abfe10e328b5ce62
msgid ""
"OpenSourceDays, Copenhagen, XDP - eXpress Data Path, Used for DDoS protection, Jesper Dangaard Brouer, http://"
"people.netfilter.org/hawk/presentations/OpenSourceDays2017/XDP_DDoS_protecting_osd2017.pdf"
msgstr ""
"OpenSourceDays, Copenhagen, XDP - eXpress Data Path, Used for DDoS protection, Jesper Dangaard Brouer, http://"
"people.netfilter.org/hawk/presentations/OpenSourceDays2017/XDP_DDoS_protecting_osd2017.pdf"

#: ../../bpf.rst:4961 ac85aa5ec27d421f8cad14f4b756d072
msgid ""
"source{d}, Infrastructure 2017, Madrid, High-performance Linux monitoring with eBPF, Alfonso Acosta, https://www."
"youtube.com/watch?v=k4jqTLtdrxQ"
msgstr ""
"source{d}, Infrastructure 2017, Madrid, High-performance Linux monitoring with eBPF, Alfonso Acosta, https://www."
"youtube.com/watch?v=k4jqTLtdrxQ"

#: ../../bpf.rst:4967 7d43b23ba6144767b729fcd89bdf7013
msgid ""
"FOSDEM 2017, Brussels, Stateful packet processing with eBPF, an implementation of OpenState interface, Quentin "
"Monnet, https://archive.fosdem.org/2017/schedule/event/stateful_ebpf/"
msgstr ""
"FOSDEM 2017, Brussels, Stateful packet processing with eBPF, an implementation of OpenState interface, Quentin "
"Monnet, https://archive.fosdem.org/2017/schedule/event/stateful_ebpf/"

#: ../../bpf.rst:4973 d742b2ec30fa4977b13be2cd58299f3b
msgid ""
"FOSDEM 2017, Brussels, eBPF and XDP walkthrough and recent updates, Daniel Borkmann, http://borkmann.ch/"
"talks/2017_fosdem.pdf"
msgstr ""
"FOSDEM 2017, Brussels, eBPF and XDP walkthrough and recent updates, Daniel Borkmann, http://borkmann.ch/"
"talks/2017_fosdem.pdf"

#: ../../bpf.rst:4979 f5267801c77049f69c79ef0f18c504c8
msgid ""
"FOSDEM 2017, Brussels, Cilium - BPF & XDP for containers, Thomas Graf, https://archive.fosdem.org/2017/schedule/"
"event/cilium/"
msgstr ""
"FOSDEM 2017, Brussels, Cilium - BPF & XDP for containers, Thomas Graf, https://archive.fosdem.org/2017/schedule/"
"event/cilium/"

#: ../../bpf.rst:4985 cc43f14ca0e6424a965f869ffdcf84b0
msgid ""
"linuxconf.au, Hobart, BPF: Tracing and more, Brendan Gregg, https://www.slideshare.net/brendangregg/bpf-tracing-"
"and-more"
msgstr ""
"linuxconf.au, Hobart, BPF: Tracing and more, Brendan Gregg, https://www.slideshare.net/brendangregg/bpf-tracing-"
"and-more"

#: ../../bpf.rst:4991 0e80e7db9c13498391a576826e6f4741
msgid ""
"USENIX LISA 2016, Boston, Linux 4.x Tracing Tools: Using BPF Superpowers, Brendan Gregg, https://www.slideshare."
"net/brendangregg/linux-4x-tracing-tools-using-bpf-superpowers"
msgstr ""
"USENIX LISA 2016, Boston, Linux 4.x Tracing Tools: Using BPF Superpowers, Brendan Gregg, https://www.slideshare."
"net/brendangregg/linux-4x-tracing-tools-using-bpf-superpowers"

#: ../../bpf.rst:4997 f5c9befb70ca48a2807a45124d661f84
msgid ""
"Linux Plumbers, Santa Fe, Cilium: Networking & Security for Containers with BPF & XDP, Thomas Graf, https://www."
"slideshare.net/ThomasGraf5/clium-container-networking-with-bpf-xdp"
msgstr ""
"Linux Plumbers, Santa Fe, Cilium: Networking & Security for Containers with BPF & XDP, Thomas Graf, https://www."
"slideshare.net/ThomasGraf5/clium-container-networking-with-bpf-xdp"

#: ../../bpf.rst:5003 43fcee7946bc45a8bb92e6a013e2a339
msgid ""
"OVS Conference, Santa Clara, Offloading OVS Flow Processing using eBPF, William (Cheng-Chun) Tu, http://www."
"openvswitch.org/support/ovscon2016/7/1120-tu.pdf"
msgstr ""
"OVS Conference, Santa Clara, Offloading OVS Flow Processing using eBPF, William (Cheng-Chun) Tu, http://www."
"openvswitch.org/support/ovscon2016/7/1120-tu.pdf"

#: ../../bpf.rst:5009 11965a781e954400841e2b4a55672833
msgid ""
"One.com, Copenhagen, XDP - eXpress Data Path, Intro and future use-cases, Jesper Dangaard Brouer, http://people."
"netfilter.org/hawk/presentations/xdp2016/xdp_intro_and_use_cases_sep2016.pdf"
msgstr ""
"One.com, Copenhagen, XDP - eXpress Data Path, Intro and future use-cases, Jesper Dangaard Brouer, http://people."
"netfilter.org/hawk/presentations/xdp2016/xdp_intro_and_use_cases_sep2016.pdf"

#: ../../bpf.rst:5015 a7bbeda3d0b94f558fa3151bf8421144
msgid ""
"Docker Distributed Systems Summit, Berlin, Cilium: Networking & Security for Containers with BPF & XDP, Thomas "
"Graf, https://www.slideshare.net/Docker/cilium-bpf-xdp-for-containers-66969823"
msgstr ""
"Docker Distributed Systems Summit, Berlin, Cilium: Networking & Security for Containers with BPF & XDP, Thomas "
"Graf, https://www.slideshare.net/Docker/cilium-bpf-xdp-for-containers-66969823"

#: ../../bpf.rst:5021 7ecd0002694648ceba84489b7748b699
msgid ""
"NetDev 1.2, Tokyo, Data center networking stack, Tom Herbert, https://netdevconf.info/1.2/session.html?tom-"
"herbert"
msgstr ""
"NetDev 1.2, Tokyo, Data center networking stack, Tom Herbert, https://netdevconf.info/1.2/session.html?tom-"
"herbert"

#: ../../bpf.rst:5027 1502bc21172648d58e4f1ac90c88a79d
msgid ""
"NetDev 1.2, Tokyo, Fast Programmable Networks & Encapsulated Protocols, David S. Miller, https://netdevconf."
"info/1.2/session.html?david-miller-keynote"
msgstr ""
"NetDev 1.2, Tokyo, Fast Programmable Networks & Encapsulated Protocols, David S. Miller, https://netdevconf."
"info/1.2/session.html?david-miller-keynote"

#: ../../bpf.rst:5033 94ef45b44ddc42e8a2279c2d767ad4e7
msgid ""
"NetDev 1.2, Tokyo, XDP workshop - Introduction, experience, and future development, Tom Herbert, https://"
"netdevconf.info/1.2/session.html?herbert-xdp-workshop"
msgstr ""
"NetDev 1.2, Tokyo, XDP workshop - Introduction, experience, and future development, Tom Herbert, https://"
"netdevconf.info/1.2/session.html?herbert-xdp-workshop"

#: ../../bpf.rst:5039 2cfe33b9f6b5471f99875ba380ee6b3a
msgid ""
"NetDev1.2, Tokyo, The adventures of a Suricate in eBPF land, Eric Leblond, https://netdevconf.info/1.2/slides/"
"oct6/10_suricata_ebpf.pdf"
msgstr ""
"NetDev1.2, Tokyo, The adventures of a Suricate in eBPF land, Eric Leblond, https://netdevconf.info/1.2/slides/"
"oct6/10_suricata_ebpf.pdf"

#: ../../bpf.rst:5045 4bebaee175b14d4ba3c8e8e20e13cabf
msgid ""
"NetDev1.2, Tokyo, cls_bpf/eBPF updates since netdev 1.1, Daniel Borkmann, http://borkmann.ch/talks/2016_tcws.pdf"
msgstr ""
"NetDev1.2, Tokyo, cls_bpf/eBPF updates since netdev 1.1, Daniel Borkmann, http://borkmann.ch/talks/2016_tcws.pdf"

#: ../../bpf.rst:5051 0a918616830445ceaf7f001fa14536ad
msgid ""
"NetDev1.2, Tokyo, Advanced programmability and recent updates with tc’s cls_bpf, Daniel Borkmann, http://"
"borkmann.ch/talks/2016_netdev2.pdf https://netdevconf.info/1.2/papers/borkmann.pdf"
msgstr ""
"NetDev1.2, Tokyo, Advanced programmability and recent updates with tc’s cls_bpf, Daniel Borkmann, http://"
"borkmann.ch/talks/2016_netdev2.pdf https://netdevconf.info/1.2/papers/borkmann.pdf"

#: ../../bpf.rst:5058 22e6a3f50e08467fa9d72761f946d709
msgid ""
"NetDev 1.2, Tokyo, eBPF/XDP hardware offload to SmartNICs, Jakub Kicinski, Nic Viljoen, https://netdevconf."
"info/1.2/papers/eBPF_HW_OFFLOAD.pdf"
msgstr ""
"NetDev 1.2, Tokyo, eBPF/XDP hardware offload to SmartNICs, Jakub Kicinski, Nic Viljoen, https://netdevconf."
"info/1.2/papers/eBPF_HW_OFFLOAD.pdf"

#: ../../bpf.rst:5064 8b4d57b6565f480e88cef45477c5f939
msgid ""
"LinuxCon, Toronto, What Can BPF Do For You?, Brenden Blanco, https://events.static.linuxfound.org/sites/events/"
"files/slides/iovisor-lc-bof-2016.pdf"
msgstr ""
"LinuxCon, Toronto, What Can BPF Do For You?, Brenden Blanco, https://events.static.linuxfound.org/sites/events/"
"files/slides/iovisor-lc-bof-2016.pdf"

#: ../../bpf.rst:5070 d1c970be4da443ecb3d494807dff6576
msgid ""
"LinuxCon, Toronto, Cilium - Fast IPv6 Container Networking with BPF and XDP, Thomas Graf, https://www.slideshare."
"net/ThomasGraf5/cilium-fast-ipv6-container-networking-with-bpf-and-xdp"
msgstr ""
"LinuxCon, Toronto, Cilium - Fast IPv6 Container Networking with BPF and XDP, Thomas Graf, https://www.slideshare."
"net/ThomasGraf5/cilium-fast-ipv6-container-networking-with-bpf-and-xdp"

#: ../../bpf.rst:5076 09ad4ca8abed4f218809fb453ec746cc
msgid ""
"P4, EBPF and Linux TC Offload, Dinan Gunawardena, Jakub Kicinski, https://de.slideshare.net/Open-NFP/p4-epbf-and-"
"linux-tc-offload"
msgstr ""
"P4, EBPF and Linux TC Offload, Dinan Gunawardena, Jakub Kicinski, https://de.slideshare.net/Open-NFP/p4-epbf-and-"
"linux-tc-offload"

#: ../../bpf.rst:5084 ../../bpf.rst:5090 230a9fb3e90f47449a6e98b76a77c33d 3ae0afd651a7443cb56955896abbd48e
msgid "Jul 2016,"
msgstr "Jul 2016,"

#: ../../bpf.rst:5081 c0a5bfca8de7472b98eec07bb3693b54
msgid ""
"Linux Meetup, Santa Clara, eXpress Data Path, Brenden Blanco, https://www.slideshare.net/IOVisor/express-data-"
"path-linux-meetup-santa-clara-july-2016"
msgstr ""
"Linux Meetup, Santa Clara, eXpress Data Path, Brenden Blanco, https://www.slideshare.net/IOVisor/express-data-"
"path-linux-meetup-santa-clara-july-2016"

#: ../../bpf.rst:5087 5633fa03b27d4d4186b10f4849db8cc7
msgid ""
"Linux Meetup, Santa Clara, CETH for XDP, Yan Chan, Yunsong Lu, https://www.slideshare.net/IOVisor/ceth-for-xdp-"
"linux-meetup-santa-clara-july-2016"
msgstr ""
"Linux Meetup, Santa Clara, CETH for XDP, Yan Chan, Yunsong Lu, https://www.slideshare.net/IOVisor/ceth-for-xdp-"
"linux-meetup-santa-clara-july-2016"

#: ../../bpf.rst:5093 66b614393fd34b6c9054499b917d0b35
#, python-format
msgid ""
"P4 workshop, Stanford, P4 on the Edge, John Fastabend, https://schd.ws/hosted_files/2016p4workshop/1d/Intel"
"%20Fastabend-P4%20on%20the%20Edge.pdf"
msgstr ""
"P4 workshop, Stanford, P4 on the Edge, John Fastabend, https://schd.ws/hosted_files/2016p4workshop/1d/Intel"
"%20Fastabend-P4%20on%20the%20Edge.pdf"

#: ../../bpf.rst:5099 a86a0a7e42484f6c85962559e0c9b843
msgid ""
"Performance @Scale 2016, Menlo Park, Linux BPF Superpowers, Brendan Gregg, https://www.slideshare.net/"
"brendangregg/linux-bpf-superpowers"
msgstr ""
"Performance @Scale 2016, Menlo Park, Linux BPF Superpowers, Brendan Gregg, https://www.slideshare.net/"
"brendangregg/linux-bpf-superpowers"

#: ../../bpf.rst:5105 7c14574fe23a4dff858beafbb9b9f71e
msgid ""
"eXpress Data Path, Tom Herbert, Alexei Starovoitov, https://raw.githubusercontent.com/iovisor/bpf-docs/master/"
"Express_Data_Path.pdf"
msgstr ""
"eXpress Data Path, Tom Herbert, Alexei Starovoitov, https://raw.githubusercontent.com/iovisor/bpf-docs/master/"
"Express_Data_Path.pdf"

#: ../../bpf.rst:5110 93abc47f72ec4b68a14b569a6857a96f
msgid ""
"NetDev1.1, Seville, On getting tc classifier fully programmable with cls_bpf, Daniel Borkmann, http://borkmann."
"ch/talks/2016_netdev.pdf https://netdevconf.info/1.1/proceedings/papers/On-getting-tc-classifier-fully-"
"programmable-with-cls-bpf.pdf"
msgstr ""
"NetDev1.1, Seville, On getting tc classifier fully programmable with cls_bpf, Daniel Borkmann, http://borkmann."
"ch/talks/2016_netdev.pdf https://netdevconf.info/1.1/proceedings/papers/On-getting-tc-classifier-fully-"
"programmable-with-cls-bpf.pdf"

#: ../../bpf.rst:5117 22bf27842dbb48409acc0a3786c5062a
msgid "FOSDEM 2016, Brussels, Linux tc and eBPF, Daniel Borkmann, http://borkmann.ch/talks/2016_fosdem.pdf"
msgstr "FOSDEM 2016, Brussels, Linux tc and eBPF, Daniel Borkmann, http://borkmann.ch/talks/2016_fosdem.pdf"

#: ../../bpf.rst:5126 b5d9e875b6ad496d91c0c5652357be6d
msgid "Oct 2015,"
msgstr "Oct 2015,"

#: ../../bpf.rst:5123 22377951c540483f969daa5e3054c9e1
msgid ""
"LinuxCon Europe, Dublin, eBPF on the Mainframe, Michael Holzheu, https://events.static.linuxfound.org/sites/"
"events/files/slides/ebpf_on_the_mainframe_lcon_2015.pdf"
msgstr ""
"LinuxCon Europe, Dublin, eBPF on the Mainframe, Michael Holzheu, https://events.static.linuxfound.org/sites/"
"events/files/slides/ebpf_on_the_mainframe_lcon_2015.pdf"

#: ../../bpf.rst:5129 be46e4c8b2ef4987a1775b1205681ca2
msgid ""
"Tracing Summit, Seattle, LLTng's Trace Filtering and beyond (with some eBPF goodness, of course!), Suchakra "
"Sharma, https://raw.githubusercontent.com/iovisor/bpf-docs/master/ebpf_excerpt_20Aug2015.pdf"
msgstr ""
"Tracing Summit, Seattle, LLTng’s Trace Filtering and beyond (with some eBPF goodness, of course!), Suchakra "
"Sharma, https://raw.githubusercontent.com/iovisor/bpf-docs/master/ebpf_excerpt_20Aug2015.pdf"

#: ../../bpf.rst:5138 19bf69570a314d25a10c49e63e0c90c4
msgid "Jun 2015,"
msgstr "Jun 2015,"

#: ../../bpf.rst:5135 3b12ed9545fa46b88a7ae40aaf6b00b6
msgid ""
"LinuxCon Japan, Tokyo, Exciting Developments in Linux Tracing, Elena Zannoni, https://events.static.linuxfound."
"org/sites/events/files/slides/tracing-linux-ezannoni-linuxcon-ja-2015_0.pdf"
msgstr ""
"LinuxCon Japan, Tokyo, Exciting Developments in Linux Tracing, Elena Zannoni, https://events.static.linuxfound."
"org/sites/events/files/slides/tracing-linux-ezannoni-linuxcon-ja-2015_0.pdf"

#: ../../bpf.rst:5144 ../../bpf.rst:5150 ab18b4cd57c84a4fbbcf5b540544c4a8 be5392e8673e455cbb4a4aecc4270606
msgid "Feb 2015,"
msgstr "Feb 2015,"

#: ../../bpf.rst:5141 17177f6400c741eea0a7a60bcc9c97d4
msgid ""
"Collaboration Summit, Santa Rosa, BPF: In-kernel Virtual Machine, Alexei Starovoitov, https://events.static."
"linuxfound.org/sites/events/files/slides/bpf_collabsummit_2015feb20.pdf"
msgstr ""
"Collaboration Summit, Santa Rosa, BPF: In-kernel Virtual Machine, Alexei Starovoitov, https://events.static."
"linuxfound.org/sites/events/files/slides/bpf_collabsummit_2015feb20.pdf"

#: ../../bpf.rst:5147 62b08ffb81c9487f9e02f9213a128b3c
msgid ""
"NetDev 0.1, Ottawa, BPF: In-kernel Virtual Machine, Alexei Starovoitov, https://netdevconf.info/0.1/sessions/15."
"html"
msgstr ""
"NetDev 0.1, Ottawa, BPF: In-kernel Virtual Machine, Alexei Starovoitov, https://netdevconf.info/0.1/sessions/15."
"html"

#: ../../bpf.rst:5156 3e3ac07783ae4bfe830efa1919c09ca5
msgid "Feb 2014,"
msgstr "Feb 2014,"

#: ../../bpf.rst:5153 0f2964bbd7d64458b5bbe5470c1d126e
msgid ""
"DevConf.cz, Brno, tc and cls_bpf: lightweight packet classifying with BPF, Daniel Borkmann, http://borkmann.ch/"
"talks/2014_devconf.pdf"
msgstr ""
"DevConf.cz、Brno、tc 和 cls_bpf：使用 BPF 进行轻量级数据包分类，Daniel Borkmann，http://borkmann.ch/"
"talks/2014_devconf.pdf"

#: ../../bpf.rst:5159 8ef55dbc50844c85ac57fed2f4b9ad69
msgid "Further Documents"
msgstr "更多参考"

#: ../../bpf.rst:5161 198080a642a94933b615e94c7bbe19f9
msgid ""
"Dive into BPF: a list of reading material, Quentin Monnet (https://qmonnet.github.io/whirl-offload/2016/09/01/"
"dive-into-bpf/)"
msgstr "深入 BPF：阅读材料列表，Quentin Monnet (https://qmonnet.github.io/whirl-offload/2016/09/01/dive-into-bpf/)"

#: ../../bpf.rst:5165 02f8b6fcb60748f895381d5afaabf559
msgid ""
"XDP - eXpress Data Path, Jesper Dangaard Brouer (https://prototype-kernel.readthedocs.io/en/latest/networking/"
"XDP/index.html)"
msgstr ""
"XDP - eXpress 数据路径，Jesper Dangaard Brouer (https://prototype-kernel.readthedocs.io/en/latest/networking/XDP/"
"index.html)"
